(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/animations'),require('@angular/cdk/a11y'),require('@angular/common'),exports, require('@angular/core'), require('rxjs/operators'), require('@angular/animations'), require('@angular/common'), require('rxjs'), require('bezier-easing'), require('@angular/cdk/a11y')) :
    typeof define === 'function' && define.amd ? define('ng-carousel-cdk', ['@angular/core','@angular/animations','@angular/cdk/a11y','@angular/common','exports', '@angular/core', 'rxjs/operators', '@angular/animations', '@angular/common', 'rxjs', 'bezier-easing', '@angular/cdk/a11y'], factory) :
    (global = global || self, factory(global.ng.core,global.ng.animations,global.ng.cdk.a11y,global.ng.common,global['ng-carousel-cdk'] = {}, global.ng.core, global.rxjs.operators, global.ng.animations, global.ng.common, global.rxjs, global.bezier, global.ng.cdk.a11y));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3,exports, i0, operators, animations, common, rxjs, bezier, a11y) { 
var _c0 = ["galleryRef"];
function CarouselEngineComponent_li_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function CarouselEngineComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵtemplate(2, CarouselEngineComponent_li_4_ng_container_2_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var slide_r3 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    var _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵstyleProp("width", ɵngcc0.ɵɵpipeBind1(1, 7, ctx_r2.slideWidth$));
    ɵngcc0.ɵɵproperty("untabbable", !slide_r3.options.isActive)("untabbableFocusTrapRef", _r1)("untabbableFocused", ctx_r2.focused);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ɵngcc0.ɵɵpipeBind1(3, 9, ctx_r2.template$))("ngTemplateOutletContext", ctx_r2.contextOf(slide_r3));
} }
'use strict';

    bezier = bezier && Object.prototype.hasOwnProperty.call(bezier, 'default') ? bezier['default'] : bezier;

    /**
     * Represents how carousel calculates slide width. Be adviced
     * that actual enum value is used in code, so change with caution.
     */
    (function (CarouselWidthMode) {
        /**
         * When pixel management is provided, carousel calculates
         * slide width with pixels. Preferred to use in limited space
         * where carousel width is more or less is predefined.
         */
        CarouselWidthMode["PX"] = "px";
        /**
         * When percent management is provided, carousel calculates
         * slide width with relative instrument (via percents). Preferred
         * to use in full-width carousel, where carousel width is unknown.
         */
        CarouselWidthMode["PERCENT"] = "%";
    })(exports.CarouselWidthMode || (exports.CarouselWidthMode = {}));

    (function (CarouselAlignMode) {
        /**
         * Active slide is always centered in carousel viewport
         */
        CarouselAlignMode["CENTER"] = "center";
        /**
         * Active slide left border sticks to left border of
         * carousel
         */
        CarouselAlignMode["LEFT"] = "left";
    })(exports.CarouselAlignMode || (exports.CarouselAlignMode = {}));

    var CarouselConfig = /** @class */ (function () {
        function CarouselConfig(config) {
            /**
             * Array of data to display
             */
            this.items = [];
            /**
             * Describes how carousel calculates its content width.
             * Consult with corresponding enum to see what options
             * are available.
             */
            this.widthMode = exports.CarouselWidthMode.PERCENT;
            /**
             * Slide width. It could be pixels or percents, based on mode
             * configuration.
             */
            this.slideWidth = 100;
            /**
             * Describes how slides should be positioned relative to
             * carousel viewport
             */
            this.alignMode = exports.CarouselAlignMode.CENTER;
            /**
             * Whether autoplay is enabled
             */
            this.autoplayEnabled = true;
            /**
             * Time in ms of how long carousel would wait until automatic
             * slide increment. Respects `autoplayEnabled` value.
             */
            this.autoplayDelay = 6000;
            /**
             * Whether mouse drag or gesture panning enabled
             */
            this.dragEnabled = true;
            /**
             * Whether carousel should start from beginning after last
             * slide
             */
            this.shouldLoop = true;
            /**
             * Time in ms of how long transition between slides would last
             */
            this.transitionDuration = 280;
            /**
             * Whether carousel should automatically recalculate on window resize.
             * This option is recommended when using pixel width mode or left
             * alignment.
             */
            this.shouldRecalculateOnResize = true;
            /**
             * Value in current width mode units which are virtally added to both sides
             * of viewport. Slides within this virtual zone should always be presented
             * whether loop mode is on.
             */
            this.threshold = 5;
            // @TODO nullish coalescing here
            this.items = config && config.items || [];
            this.widthMode = config && config.widthMode || exports.CarouselWidthMode.PERCENT;
            this.alignMode = config && config.alignMode || exports.CarouselAlignMode.CENTER;
            this.slideWidth = config && typeof config.slideWidth === 'number'
                ? config.slideWidth
                : 100;
            this.autoplayEnabled = config && typeof config.autoplayEnabled === 'boolean'
                ? config.autoplayEnabled
                : true;
            this.autoplayDelay = config && typeof config.autoplayDelay === 'number'
                ? config.autoplayDelay
                : 6000;
            this.dragEnabled = config && typeof config.dragEnabled === 'boolean'
                ? config.dragEnabled
                : true;
            this.shouldLoop = config && typeof config.shouldLoop === 'boolean'
                ? config.shouldLoop
                : true;
            this.transitionDuration = config && typeof config.transitionDuration === 'number'
                ? config.transitionDuration
                : 600;
            this.shouldRecalculateOnResize = config && typeof config.shouldRecalculateOnResize === 'boolean'
                ? config.shouldRecalculateOnResize
                : true;
        }
        return CarouselConfig;
    }());

    var CarouselSlideDirective = /** @class */ (function () {
        function CarouselSlideDirective(templateRef) {
            this.templateRef = templateRef;
        }
CarouselSlideDirective.ɵfac = function CarouselSlideDirective_Factory(t) { return new (t || CarouselSlideDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
CarouselSlideDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CarouselSlideDirective, selectors: [["", "ngCarouselSlide", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselSlideDirective, [{
        type: i0.Directive,
        args: [{
                selector: '[ngCarouselSlide]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
        return CarouselSlideDirective;
    }());
    CarouselSlideDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };

    /**
     * Generator for `CarouselSlide` id, should be
     * singleton throughout single carousel.
     */
    var IdGenerator = /** @class */ (function () {
        function IdGenerator() {
            this.index = 0;
        }
        IdGenerator.prototype.next = function () {
            return this.index++;
        };
        return IdGenerator;
    }());

    /**
     * Autoplay state of current autoplay timer
     */
    var CarouselAutoplay = /** @class */ (function () {
        function CarouselAutoplay() {
            this.autoplaySuspenders = new Set();
            this.autoplaySubscription = null;
            this.interval = null;
        }
        return CarouselAutoplay;
    }());

    /**
     * Since we don't want excessive slide recalculation
     * while main inputs are still on their way, we should
     * collect them and then initialize carousel when
     * everything is ready.
     */
    var InitializationState = /** @class */ (function () {
        function InitializationState() {
            this.configInitialized = false;
            this.viewportWidthInitialized = false;
            /** Whether slides were created for the first time */
            this.firstInitalization = false;
        }
        return InitializationState;
    }());

    /**
     * Carousel state snapshot. Config is stored here
     * as well as other vital values like offset or
     * active slide index.
     */
    var CarouselState = /** @class */ (function () {
        function CarouselState(state) {
            /**
             * Container to measure gallery width. Type is HTMLElement but
             * reduced for the ease of testing.
             */
            this.widthContainer = null;
            /** Container that should be animated during index change */
            this.animatableContainer = null;
            /** Client-side config which regulates carousel behavior */
            this.config = new CarouselConfig();
            this.activeSlideIndex = 0;
            /** Item index of config's items array */
            this.activeItemIndex = 0;
            this.template = null;
            /** X position of leftmost carousel slide */
            this.offset = 0;
            this.slides = [];
            /** State of multiphase initialization */
            this.initializationState = new InitializationState();
            /** Currently played animation */
            this.animation = null;
            this.autoplay = new CarouselAutoplay();
            if (state) {
                Object.assign(this, state);
            }
        }
        return CarouselState;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var ProcedureError = /** @class */ (function (_super) {
        __extends(ProcedureError, _super);
        function ProcedureError(error) {
            var _this = _super.call(this) || this;
            _this.message = error.message;
            _this.stack = error.stack;
            return _this;
        }
        return ProcedureError;
    }(Error));

    /** Organizes array of procedures into single procedure, flattens inner procedures */
    function procedurePipe(procedureName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return function (state, parentProcedureName) {
            var e_1, _c;
            var _a, _b;
            var handler;
            var procedureIndex = 0;
            try {
                for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                    var procedure = args_1_1.value;
                    if (typeof procedure !== 'function') {
                        continue;
                    }
                    var procedureState = Object.entries((_a = handler === null || handler === void 0 ? void 0 : handler.procedureState) !== null && _a !== void 0 ? _a : {}).length
                        ? handler.procedureState
                        : state.procedureState;
                    var nextState = {
                        state: (_b = handler === null || handler === void 0 ? void 0 : handler.state) !== null && _b !== void 0 ? _b : state.state,
                        procedureState: procedureState || {},
                        environment: state.environment,
                    };
                    var procedureSlot = procedureName + "[" + procedureIndex + "]";
                    var procedureChainString = parentProcedureName
                        ? parentProcedureName + "->" + procedureSlot
                        : procedureSlot;
                    var localHandler = void 0;
                    while (typeof localHandler === 'function' || !localHandler) {
                        try {
                            localHandler = !localHandler
                                ? procedure(nextState, procedureChainString)
                                : localHandler(nextState, procedureChainString);
                        }
                        catch (e) {
                            if (!(e instanceof ProcedureError)) {
                                console.error("Procedure interrupted at " + procedureChainString);
                            }
                            throw new ProcedureError(e);
                        }
                    }
                    handler = localHandler;
                    procedureIndex++;
                    if (handler.shouldBreakProcedure) {
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (args_1_1 && !args_1_1.done && (_c = args_1.return)) _c.call(args_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return handler;
        };
    }

    var SLIDE_ID_GENERATOR = new i0.InjectionToken('slideIdGenerator');
    var ANIMATION_ID_GENERATOR = new i0.InjectionToken('slideIdGenerator');

    var ContinueWith = /** @class */ (function () {
        function ContinueWith(state, procedureState) {
            if (procedureState === void 0) { procedureState = {}; }
            this.state = state;
            this.procedureState = procedureState;
            this.shouldBreakProcedure = false;
        }
        return ContinueWith;
    }());

    /** Stops autoplay timer, provides side effect for provided autoplay */
    function disableAutoplay(suspender, autoplay) {
        if (autoplay === void 0) { autoplay = new CarouselAutoplay(); }
        var _a;
        (_a = autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplaySubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (!autoplay.autoplaySuspenders) {
            autoplay.autoplaySuspenders = new Set();
        }
        autoplay.autoplaySuspenders.add(suspender);
        return autoplay;
    }

    /**
     * Turns current autoplay timer off with a specified reason
     */
    function disableAutoplayProcedure(suspender) {
        if (suspender === void 0) { suspender = null; }
        return function (_a) {
            var state = _a.state;
            state = Object.assign({}, state);
            var autoplay = disableAutoplay(suspender, state.autoplay);
            state.autoplay = autoplay;
            return new ContinueWith(state);
        };
    }

    /** Starts carousel autoplay whether one is enabled */
    function enableAutoplay(autoplayEnabled, transitionDuration, autoplayDelay, isBrowser, autoplayAction, suspender, autoplay) {
        var _a;
        if (!autoplay) {
            autoplay = new CarouselAutoplay();
        }
        (_a = autoplay.autoplaySubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        if (!autoplay.autoplaySuspenders) {
            autoplay.autoplaySuspenders = new Set();
        }
        if (suspender) {
            autoplay.autoplaySuspenders.delete(suspender);
        }
        if (autoplayEnabled && !autoplay.autoplaySuspenders.size && isBrowser) {
            // Delay can't be smaller than transition itself in order to avoid endless animation
            autoplay.interval = Math.max(transitionDuration, autoplayDelay);
            autoplay.autoplaySubscription = rxjs.interval(autoplay.interval).subscribe(autoplayAction);
        }
        return autoplay;
    }

    /**
     * Enables autoplay when such option is available in config
     */
    function enableAutoplayProcedure(suspender) {
        if (suspender === void 0) { suspender = null; }
        return function (_c) {
            var state = _c.state, environment = _c.environment;
            var _a, _b;
            state = Object.assign({}, state);
            var autoplay = enableAutoplay(state.config.autoplayEnabled, state.config.transitionDuration, state.config.autoplayDelay, (_a = environment === null || environment === void 0 ? void 0 : environment.isBrowser) !== null && _a !== void 0 ? _a : false, (_b = environment === null || environment === void 0 ? void 0 : environment.autoplayAction) !== null && _b !== void 0 ? _b : (function () { }), suspender, state.autoplay);
            state.autoplay = autoplay;
            return new ContinueWith(state);
        };
    }

    /**
     * Width of carousel element in pixels. Try to call this as little as
     * possible, since getting this value triggers layout thrashing.
     */
    function getViewportWidthInPx(state) {
        var _a, _b;
        return (_b = (_a = state === null || state === void 0 ? void 0 : state.widthContainer) === null || _a === void 0 ? void 0 : _a.offsetWidth) !== null && _b !== void 0 ? _b : 100;
    }

    /**
     * Width of carousel element in current width mode.
     * Try to call this as little as possible, since getting this value
     * triggers layout thrashing.
     */
    function getViewportWidth(state) {
        var _a;
        return ((_a = state === null || state === void 0 ? void 0 : state.config) === null || _a === void 0 ? void 0 : _a.widthMode) === exports.CarouselWidthMode.PX
            ? getViewportWidthInPx(state)
            : 100;
    }

    /**
     * Result for helper function `calculateActiveSlide`
     */
    var CalculateActiveSlideResult = /** @class */ (function () {
        function CalculateActiveSlideResult(modifiedOffset, slideIndex) {
            if (modifiedOffset === void 0) { modifiedOffset = 0; }
            if (slideIndex === void 0) { slideIndex = 0; }
            this.modifiedOffset = modifiedOffset;
            this.slideIndex = slideIndex;
        }
        return CalculateActiveSlideResult;
    }());

    /**
     * Based on current whereabouts, returns most possible
     * active slide candidate and proposed offset for it
     */
    function calculateActiveSlide(slides, offset, alignMode, slideWidth, viewportWidth, swipeThresholdPercent, 
    /** Distance (whether in px or %) that is aligned to carousel width mode */
    swipeDistance) {
        if (swipeDistance === void 0) { swipeDistance = null; }
        var result = new CalculateActiveSlideResult(offset, 0);
        // Noop run if nothing to calculate
        if (!slides.length || slideWidth <= 0) {
            return result;
        }
        var slidesSumWidth = slideWidth * slides.length;
        // By given align mode, width mode and viewport width, calculate
        // carousel center position
        var carouselCenter = alignMode === exports.CarouselAlignMode.LEFT
            ? 0
            : viewportWidth / 2;
        // Slide center is not always its left side. On such occasion we should
        // correct its offset using specified align mode.
        var slideRightAmendment = alignMode === exports.CarouselAlignMode.LEFT
            ? slideWidth
            : slideWidth / 2;
        var slideLeftAmendment = alignMode === exports.CarouselAlignMode.LEFT
            ? 0
            : slideRightAmendment;
        // Preset if slides far behind carousel center
        if (offset + slidesSumWidth < carouselCenter) {
            result.slideIndex = slides.length - 1;
            result.modifiedOffset = carouselCenter - slidesSumWidth + slideRightAmendment;
            // Preset if slides far away from carousel center
        }
        else if (offset - slideLeftAmendment > carouselCenter) {
            result.slideIndex = 0;
            result.modifiedOffset = carouselCenter - slideLeftAmendment;
            // Any other cases (when slides intersect carousel center)
        }
        else {
            result.slideIndex = Math.floor(Math.abs(carouselCenter - offset) / slideWidth);
            result.modifiedOffset = carouselCenter - result.slideIndex * slideWidth - slideLeftAmendment;
        }
        // Swipe correction: animation must align with swipe direction meaning
        // when user swipes right, final animation should also lead to the right
        var swipeDirection = Math.sign(swipeDistance);
        var offsetDirection = offset > result.modifiedOffset
            ? -1
            : 1;
        var shouldApplySwipeAlignment = swipeDistance !== null
            && swipeThresholdPercent !== null
            && Math.abs(swipeDistance) > Math.abs(swipeThresholdPercent)
            && swipeDirection !== offsetDirection;
        if (shouldApplySwipeAlignment) {
            var appliedSwipeAlignment = result.slideIndex - swipeDirection;
            var newSlideIndex = Math.min(Math.max(0, appliedSwipeAlignment), slides.length - 1);
            if (newSlideIndex !== result.slideIndex) {
                result.slideIndex = newSlideIndex;
                result.modifiedOffset += swipeDirection * slideWidth;
            }
        }
        return result;
    }

    /**
     * Given current slide state, assigns active slide
     */
    function calculateActiveSlideProcedure() {
        return function (_c) {
            var state = _c.state, procedureState = _c.procedureState, environment = _c.environment;
            var _a, _b;
            var result = calculateActiveSlide(state.slides, state.offset, state.config.alignMode, state.config.slideWidth, getViewportWidth(state), Math.min(state.config.slideWidth / 2, environment.swipeThreshold), procedureState.passedDistance || null);
            state.activeSlideIndex = result.slideIndex;
            state.activeItemIndex = (_b = (_a = state.slides[result.slideIndex]) === null || _a === void 0 ? void 0 : _a.itemIndex) !== null && _b !== void 0 ? _b : 0;
            return new ContinueWith(state);
        };
    }

    var CalculateOffsetResult = /** @class */ (function () {
        function CalculateOffsetResult(offset) {
            this.offset = offset;
        }
        return CalculateOffsetResult;
    }());

    /**
     * Calculates offset by specified arguments as if current slide was centered
     */
    function calculateOffset(currentSlideIndex, alignMode, slideWidth, viewportWidth, slideQuantity, shouldLoop) {
        var activeSlideLeftPosition = alignMode === exports.CarouselAlignMode.CENTER
            ? (viewportWidth - slideWidth) / 2
            : 0;
        var slidesSumWidth = slideWidth * slideQuantity;
        var newOffset = activeSlideLeftPosition - (slideWidth * currentSlideIndex);
        // Edge case amendment for left-aligned non-looped slides:
        // non-looped slides might have their right or left edge visible
        // so we might amend offset for some situations
        if (!shouldLoop && alignMode === exports.CarouselAlignMode.LEFT) {
            // Calculate prequesites
            var rightmostPoint = newOffset + slidesSumWidth;
            var allSlidesVisible = slidesSumWidth <= viewportWidth;
            // Apply offset amendment
            if (!allSlidesVisible && rightmostPoint <= viewportWidth) {
                // Left aligned slides with their right edge visible:
                // righmost slide edge should stick to the right viewport edge
                newOffset = viewportWidth - slidesSumWidth;
            }
            else if (allSlidesVisible) {
                // Left aligned slides which are all visible:
                // just stick them to the left viewport edge
                newOffset = 0;
            }
        }
        var result = new CalculateOffsetResult(Math.round(newOffset));
        return result;
    }

    /**
     * Given current slide state, assigns carousel offset
     */
    function calculateOffsetProcedure() {
        return function (_a) {
            var state = _a.state, procedureState = _a.procedureState;
            state = Object.assign({}, state);
            var result = calculateOffset(state.activeSlideIndex, state.config.alignMode, state.config.slideWidth, getViewportWidth(state), state.slides.length, state.config.shouldLoop);
            state.offset = result.offset;
            return new ContinueWith(state, procedureState);
        };
    }

    /**
     * Destroys animation player without callback
     */
    function destroyAnimation(animation) {
        var _a, _b, _c;
        try {
            (_a = animation === null || animation === void 0 ? void 0 : animation.player) === null || _a === void 0 ? void 0 : _a.finish();
            (_b = animation === null || animation === void 0 ? void 0 : animation.player) === null || _b === void 0 ? void 0 : _b.destroy();
            // Ignore exception since player might be already destroyed
            // at this moment
        }
        catch (e) { }
        (_c = animation === null || animation === void 0 ? void 0 : animation.onDoneSubscription$) === null || _c === void 0 ? void 0 : _c.unsubscribe();
    }

    /**
     * Destroys and removes any ongoing animation state
     */
    function destroyAnimationProcedure() {
        return function (_a) {
            var state = _a.state;
            destroyAnimation(state.animation);
            state.animation = null;
            return new ContinueWith(state);
        };
    }

    /**
     * Slide model representation
     */
    var CarouselSlide = /** @class */ (function () {
        function CarouselSlide(
        /**
         * Id is used in trackBy and should be generated
         * with `IdGenerator`
         */
        id, 
        /**
         * Represents index from `items` array of carousel
         * config
         */
        itemIndex, 
        /**
         * Parameters that might be changed over time
         */
        options) {
            if (options === void 0) { options = {}; }
            this.id = id;
            this.itemIndex = itemIndex;
            this.options = options;
        }
        return CarouselSlide;
    }());

    var MarkVisibleAndActiveResult = /** @class */ (function () {
        // Viewport range is subarray of slides which are
        // currently in viewport
        function MarkVisibleAndActiveResult(slides, inViewportRangeStart, inViewportRangeEnd) {
            this.slides = slides;
            this.inViewportRangeStart = inViewportRangeStart;
            this.inViewportRangeEnd = inViewportRangeEnd;
        }
        return MarkVisibleAndActiveResult;
    }());

    /**
     * Returns cloned slides with modified `inViewport` and `isActive` fields
     */
    function markVisibleAndActive(slides, offset, slideWidth, viewportWidth, activeSlideIndex, threshold, alignMode) {
        if (!slides || !slides.length) {
            return new MarkVisibleAndActiveResult([], 0, 0);
        }
        var newSlides = [];
        /** Slide index representing first slide inside viewport */
        var inViewportStart = null;
        /** Slide index representing last slide inside viewport */
        var inViewportEnd = null;
        for (var i = 0, currentOffset = offset; i < slides.length; i++, currentOffset += slideWidth) {
            // Calculate slide options
            var slideBeforeViewportEnd = currentOffset < viewportWidth + threshold;
            var slideAfterViewportStart = currentOffset + slideWidth + threshold > 0;
            var inViewport = slideBeforeViewportEnd && slideAfterViewportStart;
            var options = {
                inViewport: inViewport,
                isActive: i === activeSlideIndex,
            };
            // Construct new slide
            var newSlide = new CarouselSlide(slides[i].id, slides[i].itemIndex, Object.assign({}, slides[i].options, options));
            newSlides.push(newSlide);
            // Detect viewport range
            if (inViewport && inViewportStart === null) {
                inViewportStart = i;
            }
            else if (!inViewport && inViewportStart !== null && inViewportEnd === null) {
                inViewportEnd = Math.max(0, i - 1);
            }
        }
        // Edge case when last slide was in viewport:
        // in such case viewport end index won't be assigned
        // inside slide cycle due to loop algorithm specifics
        if (inViewportStart !== null && inViewportEnd === null) {
            inViewportEnd = slides.length - 1;
        }
        if (activeSlideIndex >= 0 && activeSlideIndex <= slides.length - 1) { // Active slide might be outside slide range
            if (activeSlideIndex <= inViewportStart || inViewportStart === null) {
                var distanceToActiveSlideViewportStart = alignMode === exports.CarouselAlignMode.LEFT
                    ? threshold
                    : viewportWidth / 2 - slideWidth / 2 + threshold;
                var slidesToViewportStart = Math.ceil(distanceToActiveSlideViewportStart / slideWidth);
                inViewportStart = Math.max(0, activeSlideIndex - slidesToViewportStart);
            }
            if (activeSlideIndex >= inViewportEnd || inViewportEnd === null) {
                var distanceToActiveSlideViewportEnd = alignMode === exports.CarouselAlignMode.LEFT
                    ? viewportWidth + threshold
                    : viewportWidth / 2 + slideWidth / 2 + threshold;
                var slidesToViewportEnd = Math.ceil(distanceToActiveSlideViewportEnd / slideWidth);
                inViewportEnd = Math.min(slides.length - 1, activeSlideIndex + slidesToViewportEnd);
            }
        }
        var result = new MarkVisibleAndActiveResult(newSlides, inViewportStart || 0, inViewportEnd || 0);
        return result;
    }

    /**
     * Assigns inViewport and isActive option to each slide
     */
    function markVisibleAndActiveProcedure() {
        return function (_c) {
            var state = _c.state, procedureState = _c.procedureState;
            var _a, _b;
            var result = markVisibleAndActive(state.slides, state.offset, state.config.slideWidth, getViewportWidth(state), state.activeSlideIndex, state.config.threshold, state.config.alignMode);
            state.slides = result.slides;
            state.activeItemIndex = (_b = (_a = result.slides[state.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.itemIndex) !== null && _b !== void 0 ? _b : 0; // Undefined when no slides available
            procedureState.inViewportRange = [result.inViewportRangeStart, result.inViewportRangeEnd];
            return new ContinueWith(state, procedureState);
        };
    }

    var RemoveExcessiveResult = /** @class */ (function () {
        function RemoveExcessiveResult(slides, offset) {
            this.slides = slides;
            this.offset = offset;
        }
        return RemoveExcessiveResult;
    }());

    /**
     * Removes slides that should not exist in carousel
     * (e.g. copies which are outside viewport)
     */
    function removeExcessive(slides, offset, slideWidth, 
    /** First slide index that is inside viewport */
    viewportStart, 
    /** Last slide index that is inside viewport */
    viewportEnd) {
        if (!slides || !slides.length) {
            return new RemoveExcessiveResult([], offset);
        }
        // Validate inputs
        viewportStart = Math.max(0, Math.min(viewportStart, viewportEnd));
        viewportEnd = Math.min(viewportStart, slides.length - 1);
        var rightSlides = [];
        var leftSlides = [];
        var itemIndexes = new Set();
        var newOffset = offset;
        // Next fancy loop traverses through slides array, but in specified order:
        // first we travel through slides in viewport, so we can collect item ids,
        // next we go through right and left side outside viewport, cleaning all
        // found copies. Thus we can cleanse all copies in O(n)
        for (var i = viewportStart; i <= viewportEnd; i++) {
            itemIndexes.add(slides[i].itemIndex);
            rightSlides.push(slides[i]);
        }
        for (var i = viewportEnd + 1; i < slides.length; i++) {
            if (itemIndexes.has(slides[i].itemIndex)) {
                continue;
            }
            itemIndexes.add(slides[i].itemIndex);
            rightSlides.push(slides[i]);
        }
        for (var i = 0; i < viewportStart; i++) {
            if (itemIndexes.has(slides[i].itemIndex)) {
                newOffset += slideWidth;
                continue;
            }
            itemIndexes.add(slides[i].itemIndex);
            leftSlides.push(slides[i]);
        }
        var newSlides = __spread(leftSlides, rightSlides);
        return new RemoveExcessiveResult(newSlides, newOffset);
    }

    /**
     * Removes slide copies
     */
    function removeExcessiveProcedure() {
        return function (_a) {
            var state = _a.state, procedureState = _a.procedureState;
            var result = removeExcessive(state.slides, state.offset, state.config.slideWidth, procedureState.inViewportRange[0], procedureState.inViewportRange[1]);
            state.slides = result.slides;
            state.offset = result.offset;
            return new ContinueWith(state);
        };
    }

    /**
     * Result for helper function `moveOrCopySlidesTo`
     */
    var CopySlidesResult = /** @class */ (function () {
        function CopySlidesResult(slides, modifiedOffset, 
        /** Item indexes that should be marked as copy */
        unmarkedItemIndexes) {
            if (slides === void 0) { slides = []; }
            if (modifiedOffset === void 0) { modifiedOffset = 0; }
            if (unmarkedItemIndexes === void 0) { unmarkedItemIndexes = []; }
            this.slides = slides;
            this.modifiedOffset = modifiedOffset;
            this.unmarkedItemIndexes = unmarkedItemIndexes;
        }
        return CopySlidesResult;
    }());

    /**
     * Result for helper function `shuffleSlides`
     */
    var ShuffleSlidesResult = /** @class */ (function () {
        function ShuffleSlidesResult(slides, modifiedOffset) {
            if (slides === void 0) { slides = []; }
            if (modifiedOffset === void 0) { modifiedOffset = 0; }
            this.slides = slides;
            this.modifiedOffset = modifiedOffset;
        }
        return ShuffleSlidesResult;
    }());

    /**
     * Justifies existing slides in viewport by either
     * - Move slide from one side to another
     * - Copy slide from one side to another
     * - Create slide on one side
     *
     * Task of this function is to leave no empty spaces in viewport.
     *
     * **BE ADVICED**, that inViewport flag should be calculated for each slide
     * that should not be moved beforehand.
     */
    function shuffleSlides(slides, offset, slideWidth, viewportWidth, items, shouldLoop, threshold, idGenerator) {
        if (threshold === void 0) { threshold = 0; }
        if (idGenerator === void 0) { idGenerator = new IdGenerator(); }
        if (!slides || !slides.length) {
            return new ShuffleSlidesResult([], offset);
        }
        if (slideWidth <= 0 || !shouldLoop) {
            return new ShuffleSlidesResult(slides, offset);
        }
        var slideSumWidth = slides.length * slideWidth;
        // Calculate missing slides for left and right sides
        var leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));
        var rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));
        // Let's start to fill missing slides
        /**
         * Item indexes that should be marked as copies after
         * function completes
         */
        var unmarkedItemIndexes = [];
        // Should move slides to right side
        if (rightSideMissingSlides) {
            var rightSideMoveResult = moveOrCopySlidesToEnd(slides, offset, rightSideMissingSlides, slideWidth, items, idGenerator);
            slides = rightSideMoveResult.slides;
            offset = rightSideMoveResult.modifiedOffset;
            unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;
        }
        // Should move slides to left side
        if (leftSideMissingSlides) {
            var leftSideMoveResult = moveOrCopySlidesToStart(slides, offset, leftSideMissingSlides, slideWidth, items, idGenerator);
            slides = leftSideMoveResult.slides;
            offset = leftSideMoveResult.modifiedOffset;
            unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);
        }
        var result = new ShuffleSlidesResult(slides, offset);
        return result;
    }
    /**
     * Moves, copies or creates slides to the right side in order to fill
     * desired `quantity`.
     *
     * Quantity means of how much new slides will be added.
     * There are two options of how we could fill missing slides.
     * Imagine next slides row mapped to their item index:
     * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.
     * We can't just start to move/copy slides from the right part,
     * because we can't break sequence (meaning if we'll copy slide `5`
     * on the right to slide `3` on the left, they won't stack).
     * Slide `3` on the left awaits slide with item index `2` to be put
     * near him, so we should create some slides in between. This action
     * is named `Option FILL GAP`.
     *
     * `Option FILL GAP`:
     * How much slides are in between item index `5` and item index `3`?
     * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides
     * and subtract their length from `quantity`.
     * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
     * equals 1. Now we can start copy/move slides from the right part.
     * This action is called `Option COPY`
     *
     * `Option COPY`:
     * When meddling with slides from the other side, we have two options
     * of what to do with them: either copy or move. Slide can be moved
     * when it is not `inViewport`, meaning it has corresponding option
     * flag. Otherwise it should be copied.
     * In our example we should move one slide from the right part, since
     * `quantity` after `Option FILL` equals 1. Lets imagine that slide
     * wasn't in viewport and now our slide row has
     * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!
     */
    function moveOrCopySlidesToEnd(slides, offset, quantity, slideWidth, items, idGenerator) {
        if (idGenerator === void 0) { idGenerator = new IdGenerator(); }
        if (quantity < 1) {
            return new CopySlidesResult(slides, offset, []);
        }
        var newSlides = [];
        /** Item indexes that should be marked as copies later */
        var unmarkedItemIndexes = [];
        /** Used as argument for splice call later */
        var spliceQuantity = 0;
        /**
         * We can't increase quantity if we encountered slide
         * with inViewport flag
         */
        var canIncreaseQuantity = true;
        /**
         * Iterator index, used in COPY option. Determines which
         * slide should be picked from left side for analyzing.
         */
        var slideIndex = 0;
        /**
         * Once we finished with option FILL GAP, then
         * copy option should take place
         */
        var shouldCopy = false;
        // We going to iterate through item indexes starting from
        // last slide item index. Let's pick an item index
        // to start from.
        var lastSlide = slides[slides.length - 1];
        var lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;
        /**
         * Iterator index, used in FILL GAP and COPY options.
         * This index determines which item will next slide have.
         */
        var nextItemId = lastSlideHasLastItemIndex
            ? 0
            : lastSlide.itemIndex + 1;
        for (var i = 0; i < quantity; i++) {
            /**
             * Having this field as true means slides from left and right
             * side (including new slides) can stack and we can proceed to
             * COPY option
             */
            var firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;
            if (shouldCopy || firstSlideHasNextItemId) {
                // Option COPY
                shouldCopy = true;
                var currentSlide = slides[slideIndex];
                // Create new slide procedure
                var newOptions = Object.assign({}, currentSlide.options);
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                newOptions.isActive = false;
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                newOptions.inViewport = true;
                var newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
                newSlides.push(newSlide);
                // Splice arguments processing
                if (currentSlide.options.inViewport) {
                    canIncreaseQuantity = false;
                }
                // We can't increase quantity if we have reached end of slides.
                // It happens when quantity from argument is higher than
                // slides size.
                var canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
                if (canIncreaseQuantity && canIncrementSpliceQuantity) {
                    spliceQuantity++;
                }
                // Prepare slide to process
                slideIndex++;
                if (slideIndex >= slides.length) {
                    slideIndex = 0;
                }
            }
            else {
                // Option FILL GAP
                // Create new slide procedure
                var newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                    // Every filled item is considered to be in viewport,
                    // because why else would we call this function
                    // otherwise? To fill viewport obviously.
                    inViewport: true,
                    item: items[nextItemId],
                    // There should be an already existing isActive slide,
                    // so we turning isActive off for copy
                    isActive: false,
                });
                newSlides.push(newSlide);
                unmarkedItemIndexes.push(nextItemId);
            }
            // Pick index for next item
            nextItemId++;
            if (nextItemId >= items.length) {
                nextItemId = 0;
            }
        }
        if (spliceQuantity > 0) {
            slides.splice(0, spliceQuantity);
        }
        var resultSlides = __spread(slides, newSlides);
        var resultOffset = offset + spliceQuantity * slideWidth;
        return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);
    }
    /**
     * Moves, copies or creates slides to the left side in order to fill
     * desired `quantity`.
     *
     * Quantity means of how much new slides will be added.
     * There are two options of how we could fill missing slides.
     * Imagine next slides row mapped to their item index:
     * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.
     * We can't just start to move/copy slides from the left part,
     * because we can't break sequence (meaning if we'll copy slide `0`
     * on the right to slide `3` on the right, they won't stack).
     * Slide `3` on the right side awaits slide with item index `2` to be
     * put near him, so we should create some slides in between. This
     * action is named `Option FILL GAP`.
     *
     * `Option FILL GAP`:
     * How much slides are in between item index `0` and item index `3`?
     * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides
     * and subtract their length from `quantity`.
     * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
     * equals 2. Now we can start copy/move slides from the left part.
     * This action is called `Option COPY`
     *
     * `Option COPY`:
     * When meddling with slides from the other side, we have two options
     * of what to do with them: either copy or move. Slide can be moved
     * when it is not `inViewport`, meaning it has corresponding option
     * flag. Otherwise it should be copied.
     * In our example we should move two slides from the left part, since
     * `quantity` after `Option FILL` equals 2. Lets imagine that slides
     * weren't in viewport and now our row has
     * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!
     */
    function moveOrCopySlidesToStart(slides, offset, quantity, slideWidth, items, idGenerator) {
        if (idGenerator === void 0) { idGenerator = new IdGenerator(); }
        if (quantity < 1) {
            return new CopySlidesResult(slides, offset, []);
        }
        var newSlides = [];
        /** Item indexes that should be marked as copies later */
        var unmarkedItemIndexes = [];
        /** Used as argument for splice call later */
        var spliceFrom = null;
        /** Used as argument for splice call later */
        var spliceQuantity = 0;
        /**
         * Once we finished with option FILL GAP, then
         * copy option should take place
         */
        var shouldCopy = false;
        /**
         * Iterator index, used in COPY option. Determines which
         * slide should be picked from right side for analyzing.
         */
        var slideIndex = slides.length - 1;
        // We going to iterate through item indexes starting from
        // first slide item index. Let's pick an item index
        // to start from.
        var firstSlide = slides[0];
        var firstSlideHasFirstItemId = firstSlide.itemIndex === 0;
        /**
         * Iterator index, used in FILL GAP and COPY options.
         * This index determines which item will next slide have.
         */
        var nextItemId = firstSlideHasFirstItemId
            ? items.length - 1
            : firstSlide.itemIndex - 1;
        for (var i = 0; i < quantity; i++) {
            var lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;
            if (shouldCopy || lastSlideHasNextItemId) {
                // Option COPY
                shouldCopy = true;
                var currentSlide = slides[slideIndex];
                // Slide copy procedure
                var newOptions = Object.assign({}, currentSlide.options);
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                newOptions.isActive = false;
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                newOptions.inViewport = true;
                var newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
                newSlides.push(newSlide);
                // Prepare next slide index
                slideIndex--;
                if (slideIndex < 0) {
                    slideIndex = slides.length - 1;
                }
                // Splice arguments processing
                // spliceFrom can be assigned once and equals first inViewport
                // slide that we met
                if (spliceFrom === null && currentSlide.options.inViewport) {
                    spliceFrom = slides.length - spliceQuantity;
                }
                // We can't increase quantity if we have determined
                // from where we should splice slides
                var slideCopyNotEncountered = spliceFrom === null;
                // We can't have splice quantity higher than slides size.
                // It happens when quantity from argument is higher than
                // slides size.
                var canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
                if (slideCopyNotEncountered && canIncrementSpliceQuantity) {
                    spliceQuantity++;
                }
            }
            else {
                // Option FILL GAP
                // Slide copy procedure
                var newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                    // Every filled item is considered to be in viewport,
                    // because why else would we call this function
                    // otherwise? To fill viewport obviously.
                    inViewport: true,
                    item: items[nextItemId],
                    // There should be an already existing isActive slide,
                    // so we turning isActive off for copy
                    isActive: false,
                });
                newSlides.push(newSlide);
                unmarkedItemIndexes.push(nextItemId);
            }
            // Pick index for next item
            nextItemId--;
            if (nextItemId < 0) {
                nextItemId = items.length - 1;
            }
        }
        if (spliceQuantity > 0) {
            spliceFrom = spliceFrom === null
                ? slides.length - spliceQuantity
                : spliceFrom;
            slides.splice(spliceFrom, spliceQuantity);
        }
        var result = __spread(newSlides.reverse(), slides);
        return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);
    }

    /**
     * Moves slide from left side to right or vise versa
     * in order to balance weight or predict offset changes
     */
    function shuffleSlidesProcedure() {
        return function (_b) {
            var state = _b.state, procedureState = _b.procedureState, environment = _b.environment;
            var _a;
            var result = shuffleSlides(state.slides, state.offset, state.config.slideWidth, getViewportWidth(state), state.config.items, state.config.shouldLoop, state.config.threshold, (_a = environment === null || environment === void 0 ? void 0 : environment.slideIdGenerator) !== null && _a !== void 0 ? _a : new IdGenerator());
            state.slides = result.slides;
            state.activeSlideIndex = result.slides.findIndex(function (item) { return item.options.isActive; }) || 0;
            if (typeof procedureState.offsetSnapshot !== 'undefined') {
                procedureState.offsetSnapshot = result.modifiedOffset - state.offset + procedureState.offsetSnapshot;
            }
            state.offset = result.modifiedOffset;
            return new ContinueWith(state);
        };
    }

    /**
     * Cleans state from excessive slides and completes
     * corresponding duties after completed transition
     */
    function cleanupProcedure() {
        return procedurePipe('cleanup', destroyAnimationProcedure(), markVisibleAndActiveProcedure(), calculateOffsetProcedure(), calculateActiveSlideProcedure(), removeExcessiveProcedure(), shuffleSlidesProcedure(), calculateActiveSlideProcedure());
    }

    /** Converts passed distance to carousel width units */
    function normalizePassedDistanceProcedure(passedDistance) {
        return function (_a) {
            var state = _a.state, procedureState = _a.procedureState;
            procedureState.passedDistance = state.config.widthMode === exports.CarouselWidthMode.PERCENT
                ? 100 * passedDistance / getViewportWidthInPx(state)
                : passedDistance;
            return new ContinueWith(state, procedureState);
        };
    }

    /**
     * Calculates offset for animation specific tick
     */
    function animationOffsetSnapshot(currentPosition, totalDuration, from, to, offsetFallback, bezierFn) {
        if (typeof from === 'undefined' || typeof to === 'undefined') {
            return offsetFallback;
        }
        if (totalDuration <= 0 || currentPosition < 0 || to === from) {
            return to;
        }
        var animationDistance = Math.abs(to - from);
        var completedDistancePercent = currentPosition / totalDuration;
        var completedDistance = animationDistance * bezierFn(completedDistancePercent);
        var offsetSnapshot = to > from
            ? from + completedDistance
            : from - completedDistance;
        return offsetSnapshot;
    }

    /**
     * Assigns offset to state like if animation was paused.
     * If animation is not available, current offset will be assigned.
     */
    function animationOffsetSnapshotProcedure() {
        return function (_e) {
            var state = _e.state;
            var _a, _b, _c, _d;
            var time = new Date().getTime();
            var currentPosition = time - ((_b = (_a = state.animation) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : time);
            var result = animationOffsetSnapshot(currentPosition, state.config.transitionDuration, (_c = state.animation) === null || _c === void 0 ? void 0 : _c.from, (_d = state.animation) === null || _d === void 0 ? void 0 : _d.to, state.offset, state.animationBezierFn);
            state.offset = result;
            return new ContinueWith(state);
        };
    }

    /**
     * Animation state that is currently in process
     */
    var CarouselAnimation = /** @class */ (function () {
        function CarouselAnimation(from, to, player, onDoneSubscription$, startTime) {
            if (startTime === void 0) { startTime = new Date().getTime(); }
            this.from = from;
            this.to = to;
            this.player = player;
            this.onDoneSubscription$ = onDoneSubscription$;
            this.startTime = startTime;
        }
        return CarouselAnimation;
    }());

    function startAnimation(container, from, to, widthMode, transitionDuration, bezierArgs, isBrowser, afterAnimationAction, animationBuilder) {
        if (!isBrowser) {
            return null;
        }
        var cubicBezier = "cubic-bezier(" + bezierArgs[0] + "," + bezierArgs[1] + "," + bezierArgs[2] + "," + bezierArgs[3] + ")";
        var animationFactory = animationBuilder.build([
            animations.style({
                transform: "translateX(" + from + widthMode + ")",
            }),
            animations.animate(transitionDuration + "ms " + cubicBezier, animations.style({
                transform: "translateX(" + to + widthMode + ")",
            })),
        ]);
        var animationPlayer = animationFactory.create(container);
        // Wrap onDone into observable
        var boundFunction = rxjs.bindCallback(animationPlayer.onDone); // Wrap function into function that returns observable
        var onDone$ = boundFunction.call(animationPlayer); // Receive observable with context of animation player
        var subscription$ = onDone$
            .subscribe(function () {
            animationPlayer.destroy();
            afterAnimationAction();
        });
        var animation = new CarouselAnimation(from, to, animationPlayer, subscription$);
        animationPlayer.play();
        return animation;
    }

    /**
     * Creates new transition from one slide to another
     */
    function startAnimationProcedure() {
        return function (_d) {
            var state = _d.state, procedureState = _d.procedureState, environment = _d.environment;
            var _a, _b, _c;
            var animation = startAnimation(state.animatableContainer, procedureState.offsetSnapshot, state.offset, state.config.widthMode, state.config.transitionDuration, (_a = environment === null || environment === void 0 ? void 0 : environment.animationBezierArgs) !== null && _a !== void 0 ? _a : [], (_b = environment === null || environment === void 0 ? void 0 : environment.isBrowser) !== null && _b !== void 0 ? _b : false, (_c = environment === null || environment === void 0 ? void 0 : environment.afterAnimationAction) !== null && _c !== void 0 ? _c : (function () { }), environment === null || environment === void 0 ? void 0 : environment.animationBuilder);
            state.animation = animation;
            return new ContinueWith(state);
        };
    }

    /**
     * Save offset to procedure state until later use
     */
    function setOffsetSnapshotProcedure() {
        return function (_a) {
            var state = _a.state, procedureState = _a.procedureState;
            procedureState.offsetSnapshot = state.offset;
            return new ContinueWith(state, procedureState);
        };
    }

    /**
     * Calculates corresponding parts for current active slide
     */
    function setSlideIndexProcedure() {
        return procedurePipe('setSlideIndex', animationOffsetSnapshotProcedure(), destroyAnimationProcedure(), setOffsetSnapshotProcedure(), markVisibleAndActiveProcedure(), calculateOffsetProcedure(), shuffleSlidesProcedure(), startAnimationProcedure());
    }

    /**
     * Calculates state after user finish drag event
     */
    function dragEndProcedure(passedDistance) {
        return procedurePipe('dragEnd', enableAutoplayProcedure("drag" /* DRAG */), normalizePassedDistanceProcedure(passedDistance), calculateActiveSlideProcedure(), setSlideIndexProcedure());
    }

    /**
     * Return new offset modified by last drag operations.
     * Applies overscroll behavior when necessary.
     *
     * @returns modified offset
     */
    function dragOffsetSnapshot(
    /** X position in pixels from where drag event began */
    fromX, 
    /** destination X in pixels of last fired drag event */
    toX, currentOffset, widthMode, alignMode, shouldLoop, viewportWidth, viewportWidthInPx, slideWidth, slideSumWidth, 
    /** How much in percents user can overscroll unlooped carousel */
    maxOverscrollPercent, bezierFn, invertedBezierFn) {
        if (fromX === toX) {
            return currentOffset;
        }
        // Normalize all pixel values to current width mode
        if (widthMode === exports.CarouselWidthMode.PERCENT) {
            fromX = fromX * 100 / viewportWidthInPx;
            toX = toX * 100 / viewportWidthInPx;
        }
        var offsetDelta = toX - fromX;
        // 1st case: no bezier amendments, just return offset with applied delta
        if (shouldLoop) {
            return currentOffset + offsetDelta;
        }
        var overscrollStartPoint = detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn);
        // 2nd case where bezier correction haven't started yet,
        // meaning we're in safe zone at both side
        if (overscrollStartPoint === null) {
            var offsetFromSafeZone = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
            return offsetFromSafeZone;
        }
        // Seems like we already at overscroll zone, so let's see
        // the ways we could manage that
        /** Whether drag was performed from overscroll zone to same overscroll zone */
        var dragStaysInSameOverscrollZone = fromX > overscrollStartPoint
            ? toX > overscrollStartPoint
            : toX < overscrollStartPoint;
        // 3rd case: we should not amend when drag pointer is still in overscroll zone
        // after applying delta
        if (dragStaysInSameOverscrollZone) {
            var distanceBefore = fromX - overscrollStartPoint;
            var distanceAfter = toX - overscrollStartPoint;
            var distance = distanceBetween(distanceBefore, distanceAfter, viewportWidth, maxOverscrollPercent, bezierFn);
            currentOffset = currentOffset - distance;
            return currentOffset;
        }
        // 4th case where drag pointer has returned to safe zone.
        // We should do the same calculation like we did in 2nd case.
        var overscrollDistance = applyDeltaFromOverscrollZone(overscrollStartPoint - fromX, viewportWidth, maxOverscrollPercent, bezierFn);
        var distancetoSafeZone = overscrollStartPoint - fromX;
        currentOffset += overscrollDistance;
        fromX = overscrollStartPoint;
        offsetDelta -= distancetoSafeZone;
        var result = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
        return result;
    }
    /**
     * Applies bezier on distance and limit with max overscroll distance
     *
     * BE ADVICED, that all argument values should be converted to current width mode
     * beforehand.
     */
    function applyDeltaFromOverscrollZone(distance, viewportWidth, maxOverscrollPercent, bezierFn) {
        /** Viewport % from 0 to 1 of delta distance */
        var deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));
        /** Maximal distance of overscroll in pixels */
        var maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
        /**
         * How much delta is actually long when applying bezier
         * and aligning overscroll max distance
         */
        var deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);
        return deltaDistance;
    }
    /**
     * Applies delta to current offset which is currently in safe zone at this moment.
     * Applies bezier whether delta intersects overscroll zone.
     *
     * BE ADVICED, that all argument values should be converted to current width mode
     * beforehand.
     */
    function applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn) {
        var leftmostPoint = alignMode === exports.CarouselAlignMode.CENTER
            ? viewportWidth / 2 - slideWidth / 2
            : 0;
        var rightmostPoint = alignMode === exports.CarouselAlignMode.CENTER
            ? viewportWidth / 2 + slideWidth / 2
            : Math.min(viewportWidth, slideSumWidth);
        /** Whether left side of carousel is in viewport after applying delta */
        var leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;
        /** Whether right side of carousel is in viewport after applying delta */
        var rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;
        var canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)
            || (!rightSideExposedAfter && offsetDelta < 0);
        if (canSafelyTransit) {
            // We're still safe on both sides, just apply delta
            return currentOffset + offsetDelta;
        }
        /**
         * Distance between current offset and point
         * where overscroll begins
         */
        var distanceToSafeZone = 0;
        // Move offset to the point where overscroll begins
        if (leftSideExposedAfter) {
            distanceToSafeZone = currentOffset - leftmostPoint;
        }
        else if (rightSideExposedAfter) {
            distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;
        }
        /**
         * Distance between current offset and
         * overscroll zone starting point
         */
        var distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;
        currentOffset -= distanceToSafeZone;
        var overscrollDelta = applyDeltaFromOverscrollZone(distanceWithoutSafeZone, viewportWidth, maxOverscrollPercent, bezierFn);
        currentOffset += overscrollDelta;
        return currentOffset;
    }
    /**
     * Returns point where overscroll should potentially start
     * or null if carousel is currently in safe zone.
     */
    function detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn) {
        var leftmostPoint = alignMode === exports.CarouselAlignMode.CENTER
            ? viewportWidth / 2 - slideWidth / 2
            : 0;
        var rightmostPoint = alignMode === exports.CarouselAlignMode.CENTER
            ? viewportWidth / 2 + slideWidth / 2
            : Math.min(leftmostPoint + slideSumWidth, viewportWidth);
        /** Distance from current offset to safe zone */
        var overscrollConvertedDistance = null;
        // Special case when left-aligned carousel is lesser than viewport width
        if (alignMode === exports.CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {
            overscrollConvertedDistance = currentOffset;
        }
        else if (currentOffset > leftmostPoint) {
            overscrollConvertedDistance = currentOffset - leftmostPoint;
        }
        else if (currentOffset < rightmostPoint - slideSumWidth) {
            overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;
        }
        if (overscrollConvertedDistance === null) {
            return null;
        }
        var overscrollRealDistance = extractDeltaFromOverscrollZone(overscrollConvertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn);
        var overscrollStartPoint = fromX - overscrollRealDistance;
        return overscrollStartPoint;
    }
    /**
     * Converts distance with bezier applied to distance
     * without bezier
     */
    function extractDeltaFromOverscrollZone(convertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn) {
        var maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
        var bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);
        var deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);
        return deltaPercentage;
    }
    /**
     * Calculates overscroll distance between two points
     */
    function distanceBetween(firstPoint, secondPoint, viewportWidth, maxOverscrollPercent, bezierFn) {
        var overscrollBefore = applyDeltaFromOverscrollZone(firstPoint, viewportWidth, maxOverscrollPercent, bezierFn);
        var overscrollAfter = applyDeltaFromOverscrollZone(secondPoint, viewportWidth, maxOverscrollPercent, bezierFn);
        var distance = overscrollBefore - overscrollAfter;
        return distance;
    }

    /**
     * Assigns offset to state by given distance coordinates
     */
    function dragOffsetSnapshotProcedure(fromX, toX) {
        return function (_a) {
            var state = _a.state, environment = _a.environment;
            var result = dragOffsetSnapshot(fromX, toX, state.offset, state.config.widthMode, state.config.alignMode, state.config.shouldLoop, getViewportWidth(state), getViewportWidthInPx(state), state.config.slideWidth, state.slides.length * state.config.slideWidth, environment.maxOverscroll, state.dragBezierFn, state.invertedDragBezierFn);
            state.offset = result;
            return new ContinueWith(state);
        };
    }

    var BreakWith = /** @class */ (function () {
        function BreakWith(state, procedureState) {
            if (procedureState === void 0) { procedureState = null; }
            this.state = state;
            this.procedureState = procedureState;
            this.shouldBreakProcedure = true;
        }
        return BreakWith;
    }());

    /**
     * Would break procedure whether drag is disabled
     */
    function postponeDragEnabledProcedure() {
        return function (_b) {
            var state = _b.state;
            var _a;
            if ((_a = state === null || state === void 0 ? void 0 : state.config) === null || _a === void 0 ? void 0 : _a.dragEnabled) {
                return new ContinueWith(state);
            }
            return new BreakWith(state);
        };
    }

    /**
     * Processes state after single tick of drag event
     */
    function dragProcedure(fromX, toX) {
        return procedurePipe('drag', postponeDragEnabledProcedure(), animationOffsetSnapshotProcedure(), destroyAnimationProcedure(), dragOffsetSnapshotProcedure(fromX, toX), markVisibleAndActiveProcedure(), shuffleSlidesProcedure(), calculateActiveSlideProcedure(), markVisibleAndActiveProcedure());
    }

    /**
     * Processes state when drag event starts
     */
    function dragStartProcedure() {
        return procedurePipe('dragStart', postponeDragEnabledProcedure(), disableAutoplayProcedure("drag" /* DRAG */));
    }

    /**
     * Finds slide that is marked as `isActive` and returns its index
     */
    function findSlideIndex(slides, newItemIndex, currentSlideIndex) {
        var _a;
        if (!slides) {
            return 0;
        }
        var currentActiveSlide = slides[currentSlideIndex];
        if (!currentActiveSlide) {
            return 0;
        }
        var currentItemIndex = currentActiveSlide.itemIndex;
        var targetSlideIndex = null;
        if (newItemIndex === currentItemIndex || slides.length <= 1) {
            return currentSlideIndex;
        }
        else if (newItemIndex > currentItemIndex) {
            targetSlideIndex =
                iterateRightSide(slides, newItemIndex, currentSlideIndex)
                    || iterateLeftSide(slides, newItemIndex, currentSlideIndex);
        }
        else {
            targetSlideIndex =
                iterateLeftSide(slides, newItemIndex, currentSlideIndex)
                    || iterateRightSide(slides, newItemIndex, currentSlideIndex);
        }
        return (_a = targetSlideIndex === null || targetSlideIndex === void 0 ? void 0 : targetSlideIndex.foundIndex) !== null && _a !== void 0 ? _a : null;
    }
    function iterateRightSide(slides, newItemIndex, currentSlideIndex) {
        for (var i = currentSlideIndex + 1; i < slides.length; i++) {
            if (slides[i].itemIndex === newItemIndex) {
                return { foundIndex: i };
            }
        }
        return null;
    }
    function iterateLeftSide(slides, newItemIndex, currentSlideIndex) {
        for (var i = currentSlideIndex - 1; i >= 0; i--) {
            if (slides[i].itemIndex === newItemIndex) {
                return { foundIndex: i };
            }
        }
        return null;
    }

    /**
     * Assigns slide index by given item index
     */
    function findSlideIndexProcedure(itemIndex) {
        return function (_a) {
            var state = _a.state;
            var result = findSlideIndex(state.slides, itemIndex !== null && itemIndex !== void 0 ? itemIndex : state.activeItemIndex, state.activeSlideIndex);
            state.activeSlideIndex = result;
            state.activeItemIndex = itemIndex;
            return new ContinueWith(state);
        };
    }

    /**
     * Guard for assigning item index when no slides are available.
     * Would break procedure on such occasion.
     */
    function postponeItemIndexProcedure(newItemIndex) {
        return function (_a) {
            var state = _a.state;
            if (!state.slides || !state.slides.length) {
                state.postponedItemIndex = newItemIndex;
                return new BreakWith(state);
            }
            state.postponedItemIndex = null;
            return new ContinueWith(state);
        };
    }

    /** Assigns item index and shuffles slides accordingly */
    function goToProcedure(newItemIndex) {
        return procedurePipe('goTo', postponeItemIndexProcedure(newItemIndex), enableAutoplayProcedure(), findSlideIndexProcedure(newItemIndex), setSlideIndexProcedure());
    }

    /**
     * Fills empty carousel with slides without any
     * alignments
     */
    function initializeCarousel(items, idGenerator) {
        if (!items || !items.length || !idGenerator) {
            return [];
        }
        var newSlides = new Array(items.length);
        for (var i = 0; i < items.length; i++) {
            newSlides[i] = new CarouselSlide(idGenerator.next(), i, { item: items[i], isActive: i === 0 });
        }
        return newSlides;
    }

    /**
     * Creates new slide set from scratch
     */
    function initializeCarouselProcedure() {
        return function (_a) {
            var state = _a.state, environment = _a.environment;
            var result = initializeCarousel(state.config.items, environment.slideIdGenerator);
            state.slides = result;
            state.offset = 0;
            state.activeSlideIndex = 0;
            return new ContinueWith(state);
        };
    }

    /**
     * Would break procedure when carousel is not ready
     * for first initialization
     */
    function postponeInitializationProcedure() {
        return function (_b) {
            var state = _b.state;
            var _a;
            var phase = (_a = state === null || state === void 0 ? void 0 : state.initializationState) !== null && _a !== void 0 ? _a : new InitializationState();
            if (phase.configInitialized && phase.viewportWidthInitialized) {
                return new ContinueWith(state);
            }
            return new BreakWith(state);
        };
    }

    // Reference: https://easings.net/ru
    // Standard ease
    var ANIMATION_BEZIER_ARGS = [0.25, 0.1, 0.25, 1];
    // Ease out quad
    var DRAG_BEZIER_ARGS = [0.25, 0.46, 0.45, 0.94];
    /**
     * Creates bezier functions for different purposes
     */
    function setBeziersProcedure() {
        return function (_a) {
            var state = _a.state;
            if (!state.dragBezierFn) {
                state.dragBezierFn = bezier(DRAG_BEZIER_ARGS[0], DRAG_BEZIER_ARGS[1], DRAG_BEZIER_ARGS[2], DRAG_BEZIER_ARGS[3]);
            }
            if (!state.invertedDragBezierFn) {
                state.invertedDragBezierFn = bezier(1 - DRAG_BEZIER_ARGS[0], 1 - DRAG_BEZIER_ARGS[1], 1 - DRAG_BEZIER_ARGS[2], 1 - DRAG_BEZIER_ARGS[3]);
            }
            if (!state.animationBezierFn) {
                state.animationBezierFn = bezier(ANIMATION_BEZIER_ARGS[0], ANIMATION_BEZIER_ARGS[1], ANIMATION_BEZIER_ARGS[2], ANIMATION_BEZIER_ARGS[3]);
            }
            return new ContinueWith(state);
        };
    }

    /**
     * Set state as initialized
     */
    function setFirstInitializationProcedure() {
        return function (_a) {
            var state = _a.state;
            state.initializationState.firstInitalization = true;
            return new ContinueWith(state);
        };
    }

    function removePostponedIndexProcedure() {
        return function (_a) {
            var state = _a.state;
            state.postponedItemIndex = null;
            return new ContinueWith(state);
        };
    }

    /**
     * Saves freshly selected item index till later
     * until carousel is initialized
     */
    function setPostponedIndexProcedure() {
        return function (_a) {
            var state = _a.state;
            if (state.slides.length && state.postponedItemIndex) {
                var itemIndex = state.postponedItemIndex;
                return procedurePipe('setPostponedIndex', goToProcedure(itemIndex), removePostponedIndexProcedure());
            }
            return new ContinueWith(state);
        };
    }

    /**
     * Creates slides from scratch
     */
    function initializeProcedure() {
        return procedurePipe('initialize', postponeInitializationProcedure(), setFirstInitializationProcedure(), initializeCarouselProcedure(), calculateOffsetProcedure(), markVisibleAndActiveProcedure(), shuffleSlidesProcedure(), destroyAnimationProcedure(), enableAutoplayProcedure(), calculateActiveSlideProcedure(), setBeziersProcedure(), setPostponedIndexProcedure());
    }

    /**
     * Assigns carousel config, works as part of multiphase carousel initialization
     */
    function setConfigProcedure(newConfig) {
        return function (_a) {
            var state = _a.state;
            state.config = newConfig;
            state.initializationState.configInitialized = true;
            return new ContinueWith(state);
        };
    }

    /**
     * Assigns config and executes initialization effects
     */
    function initializeConfigProcedure(newConfig) {
        return procedurePipe('initializeConfig', setConfigProcedure(newConfig), initializeProcedure());
    }

    /**
     * Saves DOM element containers for carousel as part of initialization phase
     */
    function setContainersProcedure(widthContainer, animatableContainer) {
        return function (_a) {
            var state = _a.state;
            state.widthContainer = widthContainer;
            state.animatableContainer = animatableContainer;
            state.initializationState.viewportWidthInitialized = true;
            return new ContinueWith(state);
        };
    }

    /**
     * Assigns specified DOM containers to carousel state
     */
    function initializeContainersProcedure(widthContainer, animatableContainer) {
        return procedurePipe('initializeContainers', setContainersProcedure(widthContainer, animatableContainer), initializeProcedure());
    }

    /**
     * Returns next slide index as if user
     * clicked "next" button
     */
    function getNextIndex(slidesLength, activeSlideIndex, shouldLoop) {
        var newIndex = activeSlideIndex + 1;
        if (newIndex >= slidesLength) {
            newIndex = shouldLoop
                ? 0
                : slidesLength - 1;
        }
        return newIndex;
    }

    /**
     * Increments current item index
     */
    function getNextIndexProcedure() {
        return function (_a) {
            var state = _a.state;
            var result = getNextIndex(state.slides.length, state.activeSlideIndex, state.config.shouldLoop);
            state.activeSlideIndex = result;
            return new ContinueWith(state);
        };
    }

    /**
     * Increments current slide
     */
    function nextProcedure(omitAutoplayReset) {
        if (omitAutoplayReset === void 0) { omitAutoplayReset = false; }
        return procedurePipe('next', omitAutoplayReset ? enableAutoplayProcedure() : null, getNextIndexProcedure(), setSlideIndexProcedure());
    }

    /**
     * Returns previous slide index as if user
     * clicked "prev" button
     */
    function getPrevIndex(slidesLength, activeSlideIndex, shouldLoop) {
        var newIndex = activeSlideIndex - 1;
        if (newIndex < 0) {
            newIndex = shouldLoop
                ? slidesLength - 1
                : 0;
        }
        return newIndex;
    }

    /**
     * Decrements current item index
     */
    function getPrevIndexProcedure() {
        return function (_a) {
            var state = _a.state;
            var result = getPrevIndex(state.slides.length, state.activeSlideIndex, state.config.shouldLoop);
            state.activeSlideIndex = result;
            return new ContinueWith(state);
        };
    }

    /**
     * Decrements current slide
     */
    function prevProcedure() {
        return procedurePipe('prev', enableAutoplayProcedure(), getPrevIndexProcedure(), setSlideIndexProcedure());
    }

    /**
     * Programmaticaly recalculates current state
     */
    function recalculateProcedure() {
        return procedurePipe('recalculate', calculateOffsetProcedure(), markVisibleAndActiveProcedure(), shuffleSlidesProcedure());
    }

    /**
     * Assigns TemplateRef where slides would be rendered
     */
    function setTemplateProcedure(template) {
        return function (_a) {
            var state = _a.state;
            state.template = template;
            return new ContinueWith(state);
        };
    }

    /**
     * Short swipe might not change slide to next/prev.
     * This const specifies how much (% of viewport) swipe
     * should overcome to trigger next/prev slide change.
     */
    var MAX_SWIPE_THRESHOLD = 15;
    /**
     * How much % user can stretch carousel, when there's no more
     * drag available
     */
    var MAX_OVERSCROLL = 10;
    var CarouselService = /** @class */ (function () {
        function CarouselService(animationBuilder, slideIdGenerator, 
        // tslint:disable-next-line: ban-types
        platformId) {
            this.animationBuilder = animationBuilder;
            this.slideIdGenerator = slideIdGenerator;
            this.platformId = platformId;
            this.carouselState$ = new rxjs.BehaviorSubject(new CarouselState());
            /** Describes constant entities for procedures */
            this.procedureEnvironment = {
                slideIdGenerator: this.slideIdGenerator,
                isBrowser: common.isPlatformBrowser(this.platformId),
                autoplayAction: this.next.bind(this),
                afterAnimationAction: this.cleanup.bind(this),
                animationBuilder: this.animationBuilder,
                animationBezierArgs: ANIMATION_BEZIER_ARGS,
                swipeThreshold: MAX_SWIPE_THRESHOLD,
                maxOverscroll: MAX_OVERSCROLL,
            };
        }
        CarouselService.prototype.ngOnDestroy = function () {
            var _a, _b, _c;
            (_c = (_b = (_a = this.carouselState$.getValue()) === null || _a === void 0 ? void 0 : _a.autoplay) === null || _b === void 0 ? void 0 : _b.autoplaySubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
        };
        CarouselService.prototype.carouselStateChanges = function () {
            return this.carouselState$.asObservable();
        };
        CarouselService.prototype.setItemIndex = function (newItemIndex) {
            this.apply(goToProcedure(newItemIndex));
        };
        CarouselService.prototype.prev = function () {
            this.apply(prevProcedure());
        };
        /**
         * @param omitAutoplayReset whether autoplay timer should not be resetted
         */
        CarouselService.prototype.next = function (omitAutoplayReset) {
            if (omitAutoplayReset === void 0) { omitAutoplayReset = false; }
            this.apply(nextProcedure(omitAutoplayReset));
        };
        CarouselService.prototype.recalculate = function () {
            this.apply(recalculateProcedure());
        };
        /** Update state to announce that drag sequence just started */
        CarouselService.prototype.dragStart = function () {
            this.apply(dragStartProcedure());
        };
        /**
         * Update state to announce that drag sequence just ended
         * and perform necessary cleanups
         */
        CarouselService.prototype.dragEnd = function (passedDistance) {
            this.apply(dragEndProcedure(passedDistance));
        };
        /** Process single drag tick with given from and to coordinates */
        CarouselService.prototype.drag = function (fromX, toX) {
            this.apply(dragProcedure(fromX, toX));
        };
        CarouselService.prototype.setSlideTemplate = function (newTemplateRef) {
            this.apply(setTemplateProcedure(newTemplateRef));
        };
        CarouselService.prototype.disableAutoplay = function (suspender) {
            this.apply(disableAutoplayProcedure(suspender));
        };
        /**
         * Starts new autoplay timer
         */
        CarouselService.prototype.enableAutoplay = function (suspender) {
            if (suspender === void 0) { suspender = null; }
            this.apply(enableAutoplayProcedure(suspender));
        };
        CarouselService.prototype.setContainers = function (widthContainer, animatableContainer) {
            this.apply(initializeContainersProcedure(widthContainer, animatableContainer));
        };
        CarouselService.prototype.setConfig = function (newConfig) {
            this.apply(initializeConfigProcedure(newConfig));
        };
        CarouselService.prototype.cleanup = function () {
            this.apply(cleanupProcedure());
        };
        /**
         * Applies specified procedure to carousel state
         */
        CarouselService.prototype.apply = function (procedure) {
            var state = Object.assign({}, this.carouselState$.getValue());
            var result = procedurePipe('applier', procedure)({ state: state, procedureState: {}, environment: this.procedureEnvironment });
            this.carouselState$.next(result.state);
        };
CarouselService.ɵfac = function CarouselService_Factory(t) { return new (t || CarouselService)(ɵngcc0.ɵɵinject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵinject(SLIDE_ID_GENERATOR), ɵngcc0.ɵɵinject(i0.PLATFORM_ID)); };
CarouselService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselService, factory: function (t) { return CarouselService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselService, [{
        type: i0.Injectable
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: IdGenerator, decorators: [{
                type: i0.Inject,
                args: [SLIDE_ID_GENERATOR]
            }] }, { type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, null); })();
        return CarouselService;
    }());
    CarouselService.ctorParameters = function () { return [
        { type: animations.AnimationBuilder },
        { type: IdGenerator, decorators: [{ type: i0.Inject, args: [SLIDE_ID_GENERATOR,] }] },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };

    function idGeneratorFactory() {
        return new IdGenerator();
    }
    /**
     * Defines carousel API to work with
     */
    var CarouselComponent = /** @class */ (function () {
        function CarouselComponent(carousel) {
            this.carousel = carousel;
            this.itemIndexChange = this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return state.activeItemIndex; }));
        }
        Object.defineProperty(CarouselComponent.prototype, "slideRef", {
            set: function (newSlideRef) {
                this.carousel.setSlideTemplate(newSlideRef
                    ? newSlideRef.templateRef
                    : null);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CarouselComponent.prototype, "config", {
            set: function (newConfig) {
                newConfig = new CarouselConfig(newConfig);
                this.carousel.setConfig(newConfig);
            },
            enumerable: false,
            configurable: true
        });
        CarouselComponent.prototype.next = function () {
            this.carousel.next();
        };
        CarouselComponent.prototype.prev = function () {
            this.carousel.prev();
        };
        CarouselComponent.prototype.setIndex = function (newIndex) {
            this.carousel.setItemIndex(newIndex);
        };
        /**
         * Programmaticaly recalculates carousel position in case of
         * container size changes or other size interactions
         */
        CarouselComponent.prototype.recalculate = function () {
            this.carousel.recalculate();
        };
CarouselComponent.ɵfac = function CarouselComponent_Factory(t) { return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselService)); };
CarouselComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselComponent, selectors: [["ng-carousel"]], contentQueries: function CarouselComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CarouselSlideDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slideRef = _t.first);
    } }, inputs: { config: "config" }, outputs: { itemIndexChange: "itemIndexChange" }, exportAs: ["ngCarousel"], features: [ɵngcc0.ɵɵProvidersFeature([
            CarouselService,
            {
                provide: SLIDE_ID_GENERATOR,
                useFactory: idGeneratorFactory
            },
            {
                provide: ANIMATION_ID_GENERATOR,
                useFactory: idGeneratorFactory
            },
        ])], decls: 1, vars: 0, consts: [[1, "carousel-engine"]], template: function CarouselComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "carousel-engine", 0);
    } }, directives: function () { return [CarouselEngineComponent]; }, styles: [".carousel-engine{display:block;overflow:hidden;width:100%}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{
        type: i0.Component,
        args: [{
                selector: 'ng-carousel',
                template: "<carousel-engine class=\"carousel-engine\"></carousel-engine>\n",
                providers: [
                    CarouselService,
                    {
                        provide: SLIDE_ID_GENERATOR,
                        useFactory: idGeneratorFactory
                    },
                    {
                        provide: ANIMATION_ID_GENERATOR,
                        useFactory: idGeneratorFactory
                    },
                ],
                changeDetection: i0.ChangeDetectionStrategy.OnPush,
                encapsulation: i0.ViewEncapsulation.None,
                exportAs: 'ngCarousel',
                styles: [".carousel-engine{display:block;overflow:hidden;width:100%}"]
            }]
    }], function () { return [{ type: CarouselService }]; }, { itemIndexChange: [{
            type: i0.Output
        }], slideRef: [{
            type: i0.ContentChild,
            args: [CarouselSlideDirective]
        }], config: [{
            type: i0.Input
        }] }); })();
        return CarouselComponent;
    }());
    CarouselComponent.ctorParameters = function () { return [
        { type: CarouselService }
    ]; };
    CarouselComponent.propDecorators = {
        slideRef: [{ type: i0.ContentChild, args: [CarouselSlideDirective,] }],
        config: [{ type: i0.Input }],
        itemIndexChange: [{ type: i0.Output }]
    };

    var HammerProviderService = /** @class */ (function () {
        function HammerProviderService(
        // tslint:disable-next-line: ban-types
        platformId) {
            this.platformId = platformId;
            this.hammerAbsenceDeclared = false;
        }
        HammerProviderService.prototype.managerFor = function (element) {
            var hasGestures = common.isPlatformBrowser(this.platformId) && window.Hammer;
            if (!hasGestures) {
                if (i0.isDevMode() && !this.hammerAbsenceDeclared) {
                    console.warn('Ng-carousel could not listen to drag, because HammerJS was not found. Either disable drag or import HammerJS.');
                    this.hammerAbsenceDeclared = true;
                }
                return null;
            }
            var hammerManager = new Hammer(element);
            return hammerManager;
        };
HammerProviderService.ɵfac = function HammerProviderService_Factory(t) { return new (t || HammerProviderService)(ɵngcc0.ɵɵinject(i0.PLATFORM_ID)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HammerProviderService, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, null); })();
        return HammerProviderService;
    }());
    HammerProviderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HammerProviderService_Factory() { return new HammerProviderService(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: HammerProviderService, providedIn: "root" });
    HammerProviderService.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };

    var PreventGhostClickDirective = /** @class */ (function () {
        function PreventGhostClickDirective(elementRef, hammer) {
            this.elementRef = elementRef;
            this.hammer = hammer;
            this.shouldPreventClick = false;
        }
        PreventGhostClickDirective.prototype.processClickEvent = function (event) {
            if (this.shouldPreventClick) {
                event.preventDefault();
                event.stopImmediatePropagation();
            }
        };
        PreventGhostClickDirective.prototype.ngOnInit = function () {
            this.listenPanEndEvents();
        };
        PreventGhostClickDirective.prototype.ngOnDestroy = function () {
            if (this.hammerManager) {
                this.hammerManager.destroy();
            }
        };
        PreventGhostClickDirective.prototype.listenPanEndEvents = function () {
            var _this = this;
            this.hammerManager = this.hammer.managerFor(this.elementRef.nativeElement);
            if (!this.hammerManager) {
                return;
            }
            this.hammerManager.on('panend pancancel', function () {
                _this.shouldPreventClick = true;
                rxjs.asyncScheduler.schedule(function () {
                    _this.shouldPreventClick = false;
                });
            });
        };
PreventGhostClickDirective.ɵfac = function PreventGhostClickDirective_Factory(t) { return new (t || PreventGhostClickDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(HammerProviderService)); };
PreventGhostClickDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PreventGhostClickDirective, selectors: [["", "ngCarouselPreventGhostClick", ""]], hostBindings: function PreventGhostClickDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PreventGhostClickDirective_click_HostBindingHandler($event) { return ctx.processClickEvent($event); });
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PreventGhostClickDirective, [{
        type: i0.Directive,
        args: [{
                selector: '[ngCarouselPreventGhostClick]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: HammerProviderService }]; }, { processClickEvent: [{
            type: i0.HostListener,
            args: ['click', ['$event']]
        }] }); })();
        return PreventGhostClickDirective;
    }());
    PreventGhostClickDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: HammerProviderService }
    ]; };
    PreventGhostClickDirective.propDecorators = {
        processClickEvent: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };

    /**
     * Applies tabindex=-1 for interactive elements inside container
     */
    var FocusBlockDirective = /** @class */ (function () {
        function FocusBlockDirective(elementRef, interactivityChecker) {
            this.elementRef = elementRef;
            this.interactivityChecker = interactivityChecker;
            this.untabbable = false;
            /** Whether focus inside carousel */
            this.untabbableFocused = false;
            this.lastTabindexValueMap = new Map();
        }
        FocusBlockDirective.prototype.ngOnChanges = function (changes) {
            if (changes.untabbable && this.viewInitiated) {
                var change = changes.untabbable;
                if (change.currentValue === change.previousValue) {
                    return;
                }
                change.currentValue
                    ? this.blockTabindex()
                    : this.unblockTabindex();
                if (this.untabbableFocused && this.untabbableFocusTrapRef) {
                    this.untabbableFocusTrapRef.focusTrap.focusFirstTabbableElement();
                }
            }
        };
        FocusBlockDirective.prototype.ngAfterViewInit = function () {
            this.viewInitiated = true;
            this.untabbable
                ? this.blockTabindex()
                : this.unblockTabindex();
        };
        FocusBlockDirective.prototype.ngOnDestroy = function () {
            if (this.mutationObserver) {
                this.mutationObserver.disconnect();
                this.mutationObserver = null;
            }
        };
        FocusBlockDirective.prototype.blockTabindex = function () {
            var e_1, _a;
            var _this = this;
            var elements = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));
            try {
                for (var elements_1 = __values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
                    var element = elements_1_1.value;
                    this.blockElement(element);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (typeof window !== 'undefined' && 'MutationObserver' in window) {
                this.mutationObserver = new MutationObserver(function (mutationList) {
                    var e_2, _a;
                    var changesArray = Array.from(mutationList);
                    try {
                        for (var changesArray_1 = __values(changesArray), changesArray_1_1 = changesArray_1.next(); !changesArray_1_1.done; changesArray_1_1 = changesArray_1.next()) {
                            var change = changesArray_1_1.value;
                            if (change.type === 'attributes') {
                                _this.blockElement(change.target);
                            }
                            else if (change.type === 'childList') {
                                change.addedNodes.forEach(function (element) {
                                    _this.blockElement(element);
                                });
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (changesArray_1_1 && !changesArray_1_1.done && (_a = changesArray_1.return)) _a.call(changesArray_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                });
                this.mutationObserver.observe(this.elementRef.nativeElement, {
                    attributeFilter: ['tabindex'],
                    attributes: true,
                    childList: true,
                    subtree: true,
                });
            }
        };
        FocusBlockDirective.prototype.unblockTabindex = function () {
            var e_3, _a;
            if (this.mutationObserver) {
                this.mutationObserver.disconnect();
                this.mutationObserver = null;
            }
            var elements = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));
            try {
                for (var elements_2 = __values(elements), elements_2_1 = elements_2.next(); !elements_2_1.done; elements_2_1 = elements_2.next()) {
                    var element = elements_2_1.value;
                    this.unblockElement(element);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (elements_2_1 && !elements_2_1.done && (_a = elements_2.return)) _a.call(elements_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        FocusBlockDirective.prototype.blockElement = function (element) {
            // nodeType is text node, should not be blocked
            if (element.nodeType !== 3 && this.interactivityChecker.isFocusable(element) && this.interactivityChecker.isTabbable(element)) {
                var currentTabindexValue = element.getAttribute('tabindex');
                this.lastTabindexValueMap.set(element, currentTabindexValue);
                if (currentTabindexValue !== '-1') {
                    element.setAttribute('tabindex', '-1');
                }
            }
        };
        FocusBlockDirective.prototype.unblockElement = function (element) {
            if (this.lastTabindexValueMap.has(element) && typeof this.lastTabindexValueMap.get(element) === 'number') {
                element.setAttribute('tabindex', this.lastTabindexValueMap.get(element));
            }
            else {
                element.removeAttribute('tabindex');
            }
        };
FocusBlockDirective.ɵfac = function FocusBlockDirective_Factory(t) { return new (t || FocusBlockDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.InteractivityChecker)); };
FocusBlockDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FocusBlockDirective, selectors: [["", "untabbable", ""]], inputs: { untabbable: "untabbable", untabbableFocused: "untabbableFocused", untabbableFocusTrapRef: "untabbableFocusTrapRef" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FocusBlockDirective, [{
        type: i0.Directive,
        args: [{
                selector: '[untabbable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.InteractivityChecker }]; }, { untabbable: [{
            type: i0.Input
        }], untabbableFocused: [{
            type: i0.Input
        }], untabbableFocusTrapRef: [{
            type: i0.Input
        }] }); })();
        return FocusBlockDirective;
    }());
    FocusBlockDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: a11y.InteractivityChecker }
    ]; };
    FocusBlockDirective.propDecorators = {
        untabbable: [{ type: i0.Input }],
        untabbableFocusTrapRef: [{ type: i0.Input }],
        untabbableFocused: [{ type: i0.Input }]
    };

    /**
     * Template context for carousel slide
     */
    var CarouselSlideContext = /** @class */ (function () {
        function CarouselSlideContext($implicit, itemIndex, isActive, inViewport) {
            this.$implicit = $implicit;
            this.itemIndex = itemIndex;
            this.isActive = isActive;
            this.inViewport = inViewport;
        }
        return CarouselSlideContext;
    }());

    /**
     * Contains listeners and other DOM controllers
     */
    var CarouselEngineComponent = /** @class */ (function () {
        function CarouselEngineComponent(carousel, elementRef, renderer, hammer, 
        // tslint:disable-next-line: ban-types
        platformId) {
            this.carousel = carousel;
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.hammer = hammer;
            this.platformId = platformId;
            this.transformValue$ = this.transformValueChanges();
            this.slideWidth$ = this.slideWidthChanges();
            this.template$ = this.templateChanges();
            this.slides$ = this.slidesChanges();
            this.focused = false;
            this.destroyed$ = new rxjs.Subject();
        }
        Object.defineProperty(CarouselEngineComponent.prototype, "htmlElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        CarouselEngineComponent.prototype.ngOnInit = function () {
            this.listenToAutoplay();
            this.listenToDragEvents();
            this.listenToResizeEvents();
            this.listenToKeyEvents();
            this.listenToScrollEvents();
            this.carousel.setContainers(this.htmlElement, this.galleryRef.nativeElement);
        };
        CarouselEngineComponent.prototype.ngOnDestroy = function () {
            this.destroyMouseListeners();
            this.destroyHammer();
            this.destroyKeyboardListeners();
            this.destroyElementScrollListener();
            this.destroyed$.next();
            this.destroyed$.complete();
        };
        CarouselEngineComponent.prototype.trackByFn = function (index, item) {
            return item.id;
        };
        CarouselEngineComponent.prototype.contextOf = function (slide) {
            return new CarouselSlideContext(slide.options.item, slide.itemIndex, slide.options.isActive, slide.options.inViewport);
        };
        CarouselEngineComponent.prototype.focusIn = function () {
            this.focused = true;
            this.carousel.disableAutoplay("focus" /* FOCUS */);
        };
        CarouselEngineComponent.prototype.focusOut = function () {
            this.focused = false;
            this.carousel.enableAutoplay("focus" /* FOCUS */);
        };
        CarouselEngineComponent.prototype.destroyMouseListeners = function () {
            if (this.mouseEnterDestructor) {
                this.mouseEnterDestructor();
            }
            if (this.mouseLeaveDestructor) {
                this.mouseLeaveDestructor();
            }
        };
        CarouselEngineComponent.prototype.destroyHammer = function () {
            if (this.hammerManager) {
                this.hammerManager.destroy();
            }
        };
        CarouselEngineComponent.prototype.destroyKeyboardListeners = function () {
            if (this.keyboardListener) {
                this.keyboardListener();
            }
        };
        CarouselEngineComponent.prototype.destroyElementScrollListener = function () {
            if (this.containerScrollListener) {
                this.containerScrollListener();
            }
        };
        CarouselEngineComponent.prototype.transformValueChanges = function () {
            return this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return "translateX(" + state.offset + state.config.widthMode + ")"; }));
        };
        CarouselEngineComponent.prototype.slideWidthChanges = function () {
            return this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return "" + state.config.slideWidth + state.config.widthMode; }));
        };
        CarouselEngineComponent.prototype.slidesChanges = function () {
            return this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return state.slides; }));
        };
        CarouselEngineComponent.prototype.templateChanges = function () {
            return this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return state.template; }));
        };
        CarouselEngineComponent.prototype.listenToAutoplay = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return state.config.autoplayEnabled; }), operators.distinctUntilChanged(), operators.takeUntil(this.destroyed$))
                .subscribe(function (autoplayEnabled) {
                if (_this.mouseEnterDestructor) {
                    _this.mouseEnterDestructor();
                }
                if (_this.mouseLeaveDestructor) {
                    _this.mouseLeaveDestructor();
                }
                if (!autoplayEnabled) {
                    return;
                }
                _this.mouseEnterDestructor = _this.renderer.listen(_this.htmlElement, 'mouseenter', function () { return _this.carousel.disableAutoplay("mouse" /* MOUSE */); });
                _this.mouseLeaveDestructor = _this.renderer.listen(_this.htmlElement, 'mouseleave', function () { return _this.carousel.enableAutoplay("mouse" /* MOUSE */); });
            });
        };
        CarouselEngineComponent.prototype.listenToDragEvents = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            this.carousel.carouselStateChanges()
                .pipe(operators.map(function (state) { return state.config.dragEnabled; }), operators.distinctUntilChanged(), operators.takeUntil(this.destroyed$))
                .subscribe(function (dragEnabled) {
                if (_this.hammerManager) {
                    _this.hammerManager.destroy();
                }
                if (!dragEnabled) {
                    return;
                }
                _this.hammerManager = _this.hammer.managerFor(_this.htmlElement);
                if (!_this.hammerManager) {
                    return;
                }
                var lastDelta = 0;
                var lastTouchAction;
                _this.hammerManager.on('panstart', function (event) {
                    // Checking whether pan started with horizontal gesture,
                    // we should block all scroll attempts during current pan session then
                    // tslint:disable-next-line: no-bitwise
                    if (event.offsetDirection & Hammer.DIRECTION_HORIZONTAL) {
                        lastDelta = Math.round(event.deltaX);
                        _this.carousel.dragStart();
                        lastTouchAction = _this.htmlElement.style.touchAction;
                        _this.renderer.setStyle(_this.htmlElement, 'touch-action', 'none');
                    }
                });
                _this.hammerManager.on('panright panleft', function (event) {
                    // We should not treat vertical pans as horizontal.
                    // Be adviced that pan right/left events still counts
                    // vertical pans as legitimate horizontal pan.
                    // Next check clarifies that initial gesture was horizontal,
                    // otherwise this variable would be falsy
                    if (lastTouchAction) {
                        var x = Math.round(event.center.x);
                        var deltaX = Math.round(event.deltaX);
                        _this.carousel.drag(x, x + (deltaX - lastDelta));
                        lastDelta = deltaX;
                    }
                });
                _this.hammerManager.on('panend pancancel', function (event) {
                    if (lastTouchAction) {
                        _this.carousel.dragEnd(event.deltaX);
                        _this.renderer.setStyle(_this.htmlElement, 'touch-action', lastTouchAction);
                        lastTouchAction = null;
                    }
                });
            });
        };
        CarouselEngineComponent.prototype.listenToResizeEvents = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            this.carousel.carouselStateChanges()
                .pipe(operators.filter(function (state) { return state.config.shouldRecalculateOnResize; }), operators.switchMapTo(rxjs.fromEvent(window, 'resize')), operators.takeUntil(this.destroyed$))
                .subscribe(function () {
                _this.carousel.recalculate();
            });
        };
        CarouselEngineComponent.prototype.listenToKeyEvents = function () {
            var _this = this;
            if (!common.isPlatformBrowser(this.platformId)) {
                return;
            }
            this.keyboardListener = this.renderer.listen(this.htmlElement, 'keydown', function (event) {
                var key = event.key.toLowerCase();
                if (['arrowright', 'right'].includes(key)) {
                    _this.carousel.next();
                }
                else if (['arrowleft', 'left'].includes(key)) {
                    _this.carousel.prev();
                }
            });
        };
        /**
         * Horizontal scroll might accidentaly happen on parent container
         * when pressing arrow buttons too fast. We should return
         * container to initial position when that happens.
         */
        CarouselEngineComponent.prototype.listenToScrollEvents = function () {
            var _this = this;
            this.containerScrollListener = this.renderer.listen(this.htmlElement, 'scroll', function () {
                _this.htmlElement.scrollTo(0, 0);
            });
        };
CarouselEngineComponent.ɵfac = function CarouselEngineComponent_Factory(t) { return new (t || CarouselEngineComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HammerProviderService), ɵngcc0.ɵɵdirectiveInject(i0.PLATFORM_ID)); };
CarouselEngineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CarouselEngineComponent, selectors: [["carousel-engine"]], viewQuery: function CarouselEngineComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.galleryRef = _t.first);
    } }, decls: 6, vars: 9, consts: [[1, "ng-carousel-block", 3, "cdkTrapFocus", "focusin", "focusout"], ["galleryRef", "", "focusTrapRef", "cdkTrapFocus"], ["class", "ng-carousel-slide", 3, "width", "untabbable", "untabbableFocusTrapRef", "untabbableFocused", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "ng-carousel-slide", 3, "untabbable", "untabbableFocusTrapRef", "untabbableFocused"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function CarouselEngineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0, 1);
        ɵngcc0.ɵɵlistener("focusin", function CarouselEngineComponent_Template_ul_focusin_0_listener() { return ctx.focusIn(); })("focusout", function CarouselEngineComponent_Template_ul_focusout_0_listener() { return ctx.focusOut(); });
        ɵngcc0.ɵɵpipe(3, "async");
        ɵngcc0.ɵɵtemplate(4, CarouselEngineComponent_li_4_Template, 4, 11, "li", 2);
        ɵngcc0.ɵɵpipe(5, "async");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("transform", ɵngcc0.ɵɵpipeBind1(3, 5, ctx.transformValue$));
        ɵngcc0.ɵɵproperty("cdkTrapFocus", false);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(5, 7, ctx.slides$))("ngForTrackBy", ctx.trackByFn);
    } }, directives: [ɵngcc2.CdkTrapFocus, ɵngcc3.NgForOf, FocusBlockDirective, ɵngcc3.NgTemplateOutlet], pipes: [ɵngcc3.AsyncPipe], styles: [".ng-carousel-block{display:flex;margin:0;padding:0;width:100%;will-change:transform}.ng-carousel-slide{flex:none;list-style:none}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselEngineComponent, [{
        type: i0.Component,
        args: [{
                selector: 'carousel-engine',
                template: "<ul \n    #galleryRef\n    #focusTrapRef=\"cdkTrapFocus\"\n    [style.transform]=\"transformValue$ | async\"\n    [cdkTrapFocus]=\"false\"\n    (focusin)=\"focusIn()\"\n    (focusout)=\"focusOut()\"\n    class=\"ng-carousel-block\">\n    <li\n        *ngFor=\"let slide of (slides$ | async); trackBy: trackByFn;\"\n        [style.width]=\"slideWidth$ | async\"\n        [untabbable]=\"!slide.options.isActive\"\n        [untabbableFocusTrapRef]=\"focusTrapRef\"\n        [untabbableFocused]=\"focused\"\n        class=\"ng-carousel-slide\">\n        <ng-container *ngTemplateOutlet=\"(template$ | async); context: contextOf(slide);\"></ng-container>\n    </li>\n</ul>\n",
                changeDetection: i0.ChangeDetectionStrategy.OnPush,
                encapsulation: i0.ViewEncapsulation.None,
                styles: [".ng-carousel-block{display:flex;margin:0;padding:0;width:100%;will-change:transform}.ng-carousel-slide{flex:none;list-style:none}"]
            }]
    }], function () { return [{ type: CarouselService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: HammerProviderService }, { type: Object, decorators: [{
                type: i0.Inject,
                args: [i0.PLATFORM_ID]
            }] }]; }, { galleryRef: [{
            type: i0.ViewChild,
            args: ['galleryRef', { static: true }]
        }] }); })();
        return CarouselEngineComponent;
    }());
    CarouselEngineComponent.ctorParameters = function () { return [
        { type: CarouselService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: HammerProviderService },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    CarouselEngineComponent.propDecorators = {
        galleryRef: [{ type: i0.ViewChild, args: ['galleryRef', { static: true },] }]
    };

    var CarouselModule = /** @class */ (function () {
        function CarouselModule() {
        }
CarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CarouselModule });
CarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CarouselModule_Factory(t) { return new (t || CarouselModule)(); }, imports: [[
            common.CommonModule,
            a11y.A11yModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, { declarations: [CarouselComponent, CarouselSlideDirective, CarouselEngineComponent, FocusBlockDirective, PreventGhostClickDirective], imports: [ɵngcc3.CommonModule, ɵngcc2.A11yModule], exports: [CarouselComponent, CarouselSlideDirective, PreventGhostClickDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselModule, [{
        type: i0.NgModule,
        args: [{
                imports: [
                    common.CommonModule,
                    a11y.A11yModule,
                ],
                declarations: [
                    CarouselComponent,
                    CarouselSlideDirective,
                    CarouselEngineComponent,
                    FocusBlockDirective,
                    PreventGhostClickDirective,
                ],
                exports: [
                    CarouselComponent,
                    CarouselSlideDirective,
                    PreventGhostClickDirective,
                ]
            }]
    }], function () { return []; }, null); })();
        return CarouselModule;
    }());

    /*
     * Public API Surface of ng-carousel
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CarouselComponent = CarouselComponent;
    exports.CarouselConfig = CarouselConfig;
    exports.CarouselModule = CarouselModule;
    exports.CarouselSlideDirective = CarouselSlideDirective;
    exports.PreventGhostClickDirective = PreventGhostClickDirective;
    exports.idGeneratorFactory = idGeneratorFactory;
    exports.ɵa = IdGenerator;
    exports.ɵb = CarouselService;
    exports.ɵc = SLIDE_ID_GENERATOR;
    exports.ɵd = ANIMATION_ID_GENERATOR;
    exports.ɵe = CarouselEngineComponent;
    exports.ɵf = HammerProviderService;
    exports.ɵg = FocusBlockDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ng-carousel-cdk.umd.js.map