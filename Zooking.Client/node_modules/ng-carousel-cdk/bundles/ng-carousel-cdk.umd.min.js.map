{"version":3,"sources":["../../../projects/ng-carousel/src/lib/carousel-width-mode.ts","../../../projects/ng-carousel/src/lib/carousel-align-mode.ts","../../../projects/ng-carousel/src/lib/carousel-config.ts","../../../projects/ng-carousel/src/lib/carousel-slide.directive.ts","../../../projects/ng-carousel/src/lib/private/models/id-generator.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-autoplay.ts","../../../projects/ng-carousel/src/lib/private/models/initialization-state.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-state.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/ng-carousel/src/lib/private/models/procedure-error.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/procedure-pipe.ts","../../../projects/ng-carousel/src/lib/private/tokens.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/contiue-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width-in-px/get-viewport-width-in-px.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width/get-viewport-width.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/models/calculate-active-slide-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/models/calculate-offset-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/models/mark-visible-and-active-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/models/remove-excessive-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/copy-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/shuffle-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-offset-snapshot/set-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-end-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/normalize-passed-distance/normalize-passed-distance-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/break-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-drag-enabled/postpone-drag-enabled-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/go-to-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-item-index/postpone-item-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-beziers/set-beziers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-postponed-index/set-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/remove-postponed-index/remove-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-initialization/postpone-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-first-initalization/set-first-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-config/set-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-containers/set-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/next-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/prev-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index.ts","../../../projects/ng-carousel/src/lib/private/service/carousel.service.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/recalculate-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-start-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-template/set-template-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/cleanup-procedure.ts","../../../projects/ng-carousel/src/lib/carousel.component.ts","../../../projects/ng-carousel/src/lib/private/service/hammer-provider.service.ts","../../../projects/ng-carousel/src/lib/prevent-ghost-click.directive.ts","../../../projects/ng-carousel/src/lib/private/directives/untabbable.directive.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide-context.ts","../../../projects/ng-carousel/src/lib/private/views/carousel-engine.component.ts","../../../projects/ng-carousel/src/lib/carousel.module.ts"],"names":["CarouselWidthMode","CarouselAlignMode","config","this","items","widthMode","PERCENT","slideWidth","alignMode","CENTER","autoplayEnabled","autoplayDelay","dragEnabled","shouldLoop","transitionDuration","shouldRecalculateOnResize","threshold","templateRef","Directive","args","selector","TemplateRef","IdGenerator","index","prototype","next","CarouselAutoplay","autoplaySuspenders","Set","autoplaySubscription","interval","InitializationState","configInitialized","viewportWidthInitialized","firstInitalization","CarouselState","state","widthContainer","animatableContainer","CarouselConfig","activeSlideIndex","activeItemIndex","template","offset","slides","initializationState","animation","autoplay","Object","assign","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","create","__values","o","s","Symbol","iterator","m","i","length","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","ProcedureError","_super","_this","message","stack","__","constructor","__extends","Error","procedurePipe","procedureName","_i","parentProcedureName","handler","procedureIndex","args_1","args_1_1","procedure","procedureState","entries","_a","nextState","_b","environment","procedureSlot","procedureChainString","localHandler","console","shouldBreakProcedure","SLIDE_ID_GENERATOR","InjectionToken","ANIMATION_ID_GENERATOR","ContinueWith","disableAutoplayProcedure","suspender","unsubscribe","add","disableAutoplay","enableAutoplayProcedure","_c","isBrowser","autoplayAction","delete","size","Math","max","subscribe","enableAutoplay","getViewportWidthInPx","offsetWidth","getViewportWidth","PX","CalculateActiveSlideResult","modifiedOffset","slideIndex","calculateActiveSlideProcedure","result","viewportWidth","swipeThresholdPercent","swipeDistance","slidesSumWidth","carouselCenter","LEFT","slideRightAmendment","slideLeftAmendment","floor","abs","swipeDirection","sign","offsetDirection","appliedSwipeAlignment","newSlideIndex","min","calculateActiveSlide","swipeThreshold","passedDistance","itemIndex","CalculateOffsetResult","calculateOffsetProcedure","currentSlideIndex","slideQuantity","newOffset","allSlidesVisible","round","calculateOffset","destroyAnimationProcedure","player","finish","destroy","onDoneSubscription$","destroyAnimation","CarouselSlide","id","options","MarkVisibleAndActiveResult","inViewportRangeStart","inViewportRangeEnd","markVisibleAndActiveProcedure","newSlides","inViewportStart","inViewportEnd","currentOffset","inViewport","isActive","newSlide","distanceToActiveSlideViewportStart","slidesToViewportStart","ceil","distanceToActiveSlideViewportEnd","slidesToViewportEnd","markVisibleAndActive","inViewportRange","RemoveExcessiveResult","removeExcessiveProcedure","viewportStart","viewportEnd","rightSlides","leftSlides","itemIndexes","has","removeExcessive","CopySlidesResult","unmarkedItemIndexes","ShuffleSlidesResult","shuffleSlides","idGenerator","slideSumWidth","leftSideMissingSlides","rightSideMissingSlides","rightSideMoveResult","quantity","spliceQuantity","canIncreaseQuantity","shouldCopy","lastSlide","nextItemId","firstSlideHasNextItemId","currentSlide","newOptions","canIncrementSpliceQuantity","item","splice","resultSlides","moveOrCopySlidesToEnd","leftSideMoveResult","spliceFrom","firstSlide","lastSlideHasNextItemId","slideCopyNotEncountered","reverse","moveOrCopySlidesToStart","shuffleSlidesProcedure","slideIdGenerator","findIndex","offsetSnapshot","animationOffsetSnapshotProcedure","_e","time","Date","getTime","currentPosition","totalDuration","from","to","offsetFallback","bezierFn","completedDistance","animationOffsetSnapshot","startTime","_d","animationBezierFn","CarouselAnimation","startAnimationProcedure","container","bezierArgs","afterAnimationAction","animationBuilder","cubicBezier","animationPlayer","build","style","transform","animate","subscription$","bindCallback","onDone","play","startAnimation","animationBezierArgs","setSlideIndexProcedure","dragEndProcedure","normalizePassedDistanceProcedure","dragOffsetSnapshot","fromX","toX","viewportWidthInPx","maxOverscrollPercent","invertedBezierFn","offsetDelta","overscrollStartPoint","leftmostPoint","rightmostPoint","overscrollConvertedDistance","overscrollRealDistance","convertedDistance","maxOverscrollDistance","bezierValue","extractDeltaFromOverscrollZone","detectOverscrollStartPoint","applyDeltaFromSafeZone","firstPoint","secondPoint","overscrollBefore","applyDeltaFromOverscrollZone","overscrollAfter","distanceBetween","overscrollDistance","distancetoSafeZone","distance","leftSideExposedAfter","rightSideExposedAfter","distanceToSafeZone","BreakWith","postponeDragEnabledProcedure","dragProcedure","maxOverscroll","dragBezierFn","invertedDragBezierFn","dragOffsetSnapshotProcedure","iterateRightSide","newItemIndex","foundIndex","iterateLeftSide","findSlideIndexProcedure","currentActiveSlide","currentItemIndex","targetSlideIndex","findSlideIndex","goToProcedure","postponedItemIndex","postponeItemIndexProcedure","initializeCarouselProcedure","initializeCarousel","ANIMATION_BEZIER_ARGS","DRAG_BEZIER_ARGS","setPostponedIndexProcedure","initializeProcedure","phase","bezier","initializeConfigProcedure","newConfig","setConfigProcedure","initializeContainersProcedure","setContainersProcedure","nextProcedure","omitAutoplayReset","slidesLength","newIndex","prevProcedure","CarouselService","platformId","carouselState$","BehaviorSubject","procedureEnvironment","isPlatformBrowser","bind","cleanup","ngOnDestroy","getValue","carouselStateChanges","asObservable","setItemIndex","apply","prev","recalculate","dragStart","dragEnd","drag","setSlideTemplate","newTemplateRef","setContainers","setConfig","idGeneratorFactory","Injectable","AnimationBuilder","decorators","type","Inject","PLATFORM_ID","CarouselComponent","carousel","itemIndexChange","pipe","map","defineProperty","newSlideRef","setIndex","Component","providers","provide","useFactory","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","exportAs","ContentChild","CarouselSlideDirective","Input","Output","HammerProviderService","hammerAbsenceDeclared","managerFor","element","window","Hammer","isDevMode","warn","providedIn","PreventGhostClickDirective","elementRef","hammer","shouldPreventClick","processClickEvent","event","preventDefault","stopImmediatePropagation","ngOnInit","listenPanEndEvents","hammerManager","nativeElement","on","asyncScheduler","schedule","ElementRef","HostListener","FocusBlockDirective","interactivityChecker","untabbable","untabbableFocused","lastTabindexValueMap","Map","ngOnChanges","changes","viewInitiated","change","currentValue","previousValue","blockTabindex","unblockTabindex","untabbableFocusTrapRef","focusTrap","focusFirstTabbableElement","ngAfterViewInit","mutationObserver","disconnect","elements","querySelectorAll","elements_1","elements_1_1","blockElement","MutationObserver","mutationList","changesArray","changesArray_1","changesArray_1_1","target","addedNodes","forEach","observe","attributeFilter","attributes","childList","subtree","elements_2","elements_2_1","unblockElement","nodeType","isFocusable","isTabbable","currentTabindexValue","getAttribute","set","setAttribute","get","removeAttribute","InteractivityChecker","CarouselSlideContext","$implicit","CarouselEngineComponent","renderer","transformValue$","transformValueChanges","slideWidth$","slideWidthChanges","template$","templateChanges","slides$","slidesChanges","focused","destroyed$","Subject","listenToAutoplay","listenToDragEvents","listenToResizeEvents","listenToKeyEvents","listenToScrollEvents","htmlElement","galleryRef","destroyMouseListeners","destroyHammer","destroyKeyboardListeners","destroyElementScrollListener","complete","trackByFn","contextOf","slide","focusIn","focusOut","mouseEnterDestructor","mouseLeaveDestructor","keyboardListener","containerScrollListener","distinctUntilChanged","takeUntil","listen","lastTouchAction","lastDelta","DIRECTION_HORIZONTAL","deltaX","touchAction","setStyle","x","center","filter","switchMapTo","fromEvent","key","toLowerCase","includes","scrollTo","Renderer2","ViewChild","static","NgModule","imports","CommonModule","A11yModule","declarations","exports"],"mappings":"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","sourcesContent":["/**\n * Represents how carousel calculates slide width. Be adviced\n * that actual enum value is used in code, so change with caution.\n */\nexport enum CarouselWidthMode {\n    /**\n     * When pixel management is provided, carousel calculates\n     * slide width with pixels. Preferred to use in limited space\n     * where carousel width is more or less is predefined.\n     */\n    PX = 'px',\n    /**\n     * When percent management is provided, carousel calculates\n     * slide width with relative instrument (via percents). Preferred\n     * to use in full-width carousel, where carousel width is unknown.\n     */\n    PERCENT = '%',\n}\n","export enum CarouselAlignMode {\n    /**\n     * Active slide is always centered in carousel viewport\n     */\n    CENTER = 'center',\n    /**\n     * Active slide left border sticks to left border of\n     * carousel\n     */\n    LEFT = 'left',\n}\n","import { CarouselWidthMode } from './carousel-width-mode';\nimport { CarouselAlignMode } from './carousel-align-mode';\n\nexport class CarouselConfig {\n    /**\n     * Array of data to display\n     */\n    items?: any[] = [];\n    /**\n     * Describes how carousel calculates its content width.\n     * Consult with corresponding enum to see what options\n     * are available.\n     */\n    widthMode?: CarouselWidthMode = CarouselWidthMode.PERCENT;\n    /**\n     * Slide width. It could be pixels or percents, based on mode\n     * configuration.\n     */\n    slideWidth ? = 100;\n    /**\n     * Describes how slides should be positioned relative to\n     * carousel viewport\n     */\n    alignMode?: CarouselAlignMode = CarouselAlignMode.CENTER;\n    /**\n     * Whether autoplay is enabled\n     */\n    autoplayEnabled ? = true;\n    /**\n     * Time in ms of how long carousel would wait until automatic\n     * slide increment. Respects `autoplayEnabled` value.\n     */\n    autoplayDelay ? = 6000;\n    /**\n     * Whether mouse drag or gesture panning enabled\n     */\n    dragEnabled ? = true;\n    /**\n     * Whether carousel should start from beginning after last\n     * slide\n     */\n    shouldLoop ? = true;\n    /**\n     * Time in ms of how long transition between slides would last\n     */\n    transitionDuration ? = 280;\n    /**\n     * Whether carousel should automatically recalculate on window resize.\n     * This option is recommended when using pixel width mode or left\n     * alignment.\n     */\n    shouldRecalculateOnResize ? = true;\n    /**\n     * Value in current width mode units which are virtally added to both sides\n     * of viewport. Slides within this virtual zone should always be presented\n     * whether loop mode is on.\n     */\n    threshold ? = 5;\n\n    constructor(config?: CarouselConfig) {\n        // @TODO nullish coalescing here\n        this.items = config && config.items || [];\n        this.widthMode = config && config.widthMode || CarouselWidthMode.PERCENT;\n        this.alignMode = config && config.alignMode || CarouselAlignMode.CENTER;\n        this.slideWidth = config && typeof config.slideWidth === 'number'\n            ? config.slideWidth\n            : 100;\n        this.autoplayEnabled = config && typeof config.autoplayEnabled === 'boolean'\n            ? config.autoplayEnabled\n            : true;\n        this.autoplayDelay = config && typeof config.autoplayDelay === 'number'\n            ? config.autoplayDelay\n            : 6000;\n        this.dragEnabled = config && typeof config.dragEnabled === 'boolean'\n            ? config.dragEnabled\n            : true;\n        this.shouldLoop = config && typeof config.shouldLoop === 'boolean'\n            ? config.shouldLoop\n            : true;\n        this.transitionDuration = config && typeof config.transitionDuration === 'number'\n            ? config.transitionDuration\n            : 600;\n        this.shouldRecalculateOnResize = config && typeof config.shouldRecalculateOnResize === 'boolean'\n            ? config.shouldRecalculateOnResize\n            : true;\n    }\n}\n","import { Directive, TemplateRef } from '@angular/core';\n\n@Directive({\n    selector: '[ngCarouselSlide]',\n})\nexport class CarouselSlideDirective {\n\n    constructor(\n        public templateRef: TemplateRef<any>,\n    ) {\n    }\n\n}\n","/**\n * Generator for `CarouselSlide` id, should be\n * singleton throughout single carousel.\n */\nexport class IdGenerator {\n    private index = 0;\n\n    next(): number {\n        return this.index++;\n    }\n}\n","import { Subscription } from 'rxjs';\n\nimport { AutoplaySuspender } from './autoplay-suspender';\n\n/**\n * Autoplay state of current autoplay timer\n */\nexport class CarouselAutoplay {\n    autoplaySuspenders = new Set<AutoplaySuspender>();\n    autoplaySubscription: Subscription = null;\n    interval: number = null;\n}\n","/**\n * Since we don't want excessive slide recalculation\n * while main inputs are still on their way, we should\n * collect them and then initialize carousel when\n * everything is ready.\n */\nexport class InitializationState {\n    configInitialized = false;\n    viewportWidthInitialized = false;\n    /** Whether slides were created for the first time */\n    firstInitalization = false;\n}\n","import { TemplateRef } from '@angular/core';\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { CarouselAnimation } from './carousel-animation';\nimport { CarouselAutoplay } from './carousel-autoplay';\nimport { CarouselSlide } from './carousel-slide';\nimport { InitializationState } from './initialization-state';\n\n/**\n * Carousel state snapshot. Config is stored here\n * as well as other vital values like offset or\n * active slide index.\n */\nexport class CarouselState {\n    /**\n     * Container to measure gallery width. Type is HTMLElement but\n     * reduced for the ease of testing.\n     */\n    widthContainer: {offsetWidth: number} | null = null;\n    /** Container that should be animated during index change */\n    animatableContainer: HTMLElement | null = null;\n    /** Client-side config which regulates carousel behavior */\n    config: CarouselConfig = new CarouselConfig();\n    activeSlideIndex = 0;\n    /** Item index of config's items array */\n    activeItemIndex = 0;\n    template: TemplateRef<any> | null = null;\n    /** X position of leftmost carousel slide */\n    offset = 0;\n    slides: CarouselSlide[] = [];\n    /** State of multiphase initialization */\n    initializationState = new InitializationState();\n    /** Currently played animation */\n    animation: CarouselAnimation | null = null;\n    autoplay: CarouselAutoplay = new CarouselAutoplay();\n    dragBezierFn: EasingFunction;\n    /** Used to extract values to applied beziers */\n    invertedDragBezierFn: EasingFunction;\n    animationBezierFn: EasingFunction;\n    /**\n     * When no slides available and user intents to set index,\n     * this field would be initialized with desired index, which\n     * should be to activeSlideIndex when slides become available\n     */\n    postponedItemIndex: number;\n    /** Whether drag is in process right now */\n    isDragged: boolean;\n\n    constructor(state?: CarouselState) {\n        if (state) {\n            Object.assign(this, state);\n        }\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export class ProcedureError extends Error {\n    constructor(\n        error: Error,\n    ) {\n        super();\n        this.message = error.message;\n        this.stack = error.stack;\n    }\n}\n","import { ProcedureError } from '../procedure-error';\nimport { ComposedProcedure } from './composed-procedure.type';\nimport { ProcedureHandler } from './handler/procedure-handler.interface';\nimport { ProcedureResult } from './procedure-result.type';\nimport { ProcedureStateFacade } from './procedure-state-facade.interface';\nimport { Procedure } from './procedure.type';\n\n/** Organizes array of procedures into single procedure, flattens inner procedures */\nexport function procedurePipe(procedureName: string, ...args: (ComposedProcedure | null)[]): ProcedureResult {\n    return (state: ProcedureStateFacade, parentProcedureName?: string): ProcedureHandler => {\n        let handler: ProcedureHandler;\n        let procedureIndex = 0;\n        for (const procedure of args) {\n            if (typeof procedure !== 'function') {\n                continue;\n            }\n            const procedureState = Object.entries(handler?.procedureState ?? {}).length\n                ? handler.procedureState\n                : state.procedureState;\n            const nextState: ProcedureStateFacade = {\n                state: handler?.state ?? state.state,\n                procedureState: procedureState || {},\n                environment: state.environment,\n            };\n            const procedureSlot = `${procedureName}[${procedureIndex}]`;\n            const procedureChainString = parentProcedureName\n                ? `${parentProcedureName}->${procedureSlot}`\n                : procedureSlot;\n            let localHandler: ProcedureHandler | Procedure;\n            while (typeof localHandler === 'function' || !localHandler) {\n                try {\n                    localHandler = !localHandler\n                        ? procedure(nextState, procedureChainString)\n                        : (localHandler as Procedure)(nextState, procedureChainString);\n                } catch (e) {\n                    if (!(e instanceof ProcedureError)) {\n                        console.error(`Procedure interrupted at ${procedureChainString}`);\n                    }\n                    throw new ProcedureError(e);\n                }\n            }\n            handler = localHandler;\n            procedureIndex++;\n            if (handler.shouldBreakProcedure) {\n                break;\n            }\n        }\n\n        return handler;\n    };\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { IdGenerator } from './models/id-generator';\n\nexport const SLIDE_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\nexport const ANIMATION_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class ContinueWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = false;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: Partial<ProcedureCarouselState> = {},\n    ) {\n    }\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { disableAutoplay } from './disable-autoplay';\n\n/**\n * Turns current autoplay timer off with a specified reason\n */\nexport function disableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = disableAutoplay(\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Stops autoplay timer, provides side effect for provided autoplay */\nexport function disableAutoplay(\n    suspender: AutoplaySuspender,\n    autoplay: CarouselAutoplay = new CarouselAutoplay(),\n): CarouselAutoplay {\n    autoplay?.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    autoplay.autoplaySuspenders.add(suspender);\n\n    return autoplay;\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { enableAutoplay } from './enable-autoplay';\n\n/**\n * Enables autoplay when such option is available in config\n */\nexport function enableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = enableAutoplay(\n            state.config.autoplayEnabled,\n            state.config.transitionDuration,\n            state.config.autoplayDelay,\n            environment?.isBrowser ?? false,\n            environment?.autoplayAction ?? (() => {}),\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { interval } from 'rxjs';\n\nimport { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Starts carousel autoplay whether one is enabled */\nexport function enableAutoplay(\n    autoplayEnabled: boolean,\n    transitionDuration: number,\n    autoplayDelay: number,\n    isBrowser: boolean,\n    autoplayAction: () => void,\n    suspender?: AutoplaySuspender,\n    autoplay?: CarouselAutoplay,\n): CarouselAutoplay {\n    if (!autoplay) {\n        autoplay = new CarouselAutoplay();\n    }\n    autoplay.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    if (suspender) {\n        autoplay.autoplaySuspenders.delete(suspender);\n    }\n    if (autoplayEnabled && !autoplay.autoplaySuspenders.size && isBrowser) {\n        // Delay can't be smaller than transition itself in order to avoid endless animation\n        autoplay.interval = Math.max(transitionDuration, autoplayDelay);\n        autoplay.autoplaySubscription = interval(autoplay.interval).subscribe(autoplayAction);\n    }\n\n    return autoplay;\n}\n","import { CarouselState } from '../../../models/carousel-state';\n\n/**\n * Width of carousel element in pixels. Try to call this as little as\n * possible, since getting this value triggers layout thrashing.\n */\nexport function getViewportWidthInPx(state: CarouselState): number {\n    return state?.widthContainer?.offsetWidth ?? 100;\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselState } from '../../../models/carousel-state';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\n\n/**\n * Width of carousel element in current width mode.\n * Try to call this as little as possible, since getting this value\n * triggers layout thrashing.\n */\nexport function getViewportWidth(state: CarouselState): number {\n    return state?.config?.widthMode === CarouselWidthMode.PX\n        ? getViewportWidthInPx(state)\n        : 100;\n}\n","/**\n * Result for helper function `calculateActiveSlide`\n */\nexport class CalculateActiveSlideResult {\n\n    constructor(\n        public modifiedOffset: number = 0,\n        public slideIndex: number = 0,\n    ) {\n    }\n\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateActiveSlide } from './calculate-active-slide';\n\n/**\n * Given current slide state, assigns active slide\n */\nexport function calculateActiveSlideProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = calculateActiveSlide(\n            state.slides,\n            state.offset,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            Math.min(state.config.slideWidth / 2, environment.swipeThreshold),\n            procedureState.passedDistance || null,\n        );\n        state.activeSlideIndex = result.slideIndex;\n        state.activeItemIndex = state.slides[result.slideIndex]?.itemIndex ?? 0;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CalculateActiveSlideResult } from './models/calculate-active-slide-result';\n\n/**\n * Based on current whereabouts, returns most possible\n * active slide candidate and proposed offset for it\n */\nexport function calculateActiveSlide(\n    slides: CarouselSlide[],\n    offset: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    swipeThresholdPercent: number | null,\n    /** Distance (whether in px or %) that is aligned to carousel width mode */\n    swipeDistance: number | null = null,\n): CalculateActiveSlideResult {\n    const result = new CalculateActiveSlideResult(offset, 0);\n\n    // Noop run if nothing to calculate\n    if (!slides.length || slideWidth <= 0) {\n\n        return result;\n    }\n    const slidesSumWidth = slideWidth * slides.length;\n\n    // By given align mode, width mode and viewport width, calculate\n    // carousel center position\n    const carouselCenter = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : viewportWidth / 2;\n\n    // Slide center is not always its left side. On such occasion we should\n    // correct its offset using specified align mode.\n    const slideRightAmendment = alignMode === CarouselAlignMode.LEFT\n        ? slideWidth\n        : slideWidth / 2;\n    const slideLeftAmendment = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : slideRightAmendment;\n\n    // Preset if slides far behind carousel center\n    if (offset + slidesSumWidth < carouselCenter) {\n        result.slideIndex = slides.length - 1;\n        result.modifiedOffset = carouselCenter - slidesSumWidth + slideRightAmendment;\n\n    // Preset if slides far away from carousel center\n    } else if (offset - slideLeftAmendment > carouselCenter) {\n        result.slideIndex = 0;\n        result.modifiedOffset = carouselCenter - slideLeftAmendment;\n\n    // Any other cases (when slides intersect carousel center)\n    } else {\n        result.slideIndex = Math.floor(Math.abs(carouselCenter - offset) / slideWidth);\n        result.modifiedOffset = carouselCenter - result.slideIndex * slideWidth - slideLeftAmendment;\n    }\n\n    // Swipe correction: animation must align with swipe direction meaning\n    // when user swipes right, final animation should also lead to the right\n    const swipeDirection = Math.sign(swipeDistance);\n    const offsetDirection = offset > result.modifiedOffset\n        ? -1\n        : 1;\n    const shouldApplySwipeAlignment =\n        swipeDistance !== null\n        && swipeThresholdPercent !== null\n        && Math.abs(swipeDistance) > Math.abs(swipeThresholdPercent)\n        && swipeDirection !== offsetDirection;\n    if (shouldApplySwipeAlignment) {\n        const appliedSwipeAlignment = result.slideIndex - swipeDirection;\n        const newSlideIndex = Math.min(Math.max(0, appliedSwipeAlignment), slides.length - 1);\n        if (newSlideIndex !== result.slideIndex) {\n            result.slideIndex = newSlideIndex;\n            result.modifiedOffset += swipeDirection * slideWidth;\n        }\n    }\n\n    return result;\n}\n","export class CalculateOffsetResult {\n    constructor(\n        public offset: number,\n    ) {\n    }\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateOffset } from './calculate-offset';\n\n/**\n * Given current slide state, assigns carousel offset\n */\nexport function calculateOffsetProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        state = Object.assign({}, state);\n        const result = calculateOffset(\n            state.activeSlideIndex,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.slides.length,\n            state.config.shouldLoop,\n        );\n        state.offset = result.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CalculateOffsetResult } from './models/calculate-offset-result';\n\n/**\n * Calculates offset by specified arguments as if current slide was centered\n */\nexport function calculateOffset(\n    currentSlideIndex: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    slideQuantity: number,\n    shouldLoop: boolean,\n): CalculateOffsetResult {\n    const activeSlideLeftPosition = alignMode === CarouselAlignMode.CENTER\n        ? (viewportWidth - slideWidth) / 2\n        : 0;\n    const slidesSumWidth = slideWidth * slideQuantity;\n    let newOffset =  activeSlideLeftPosition - (slideWidth * currentSlideIndex);\n\n    // Edge case amendment for left-aligned non-looped slides:\n    // non-looped slides might have their right or left edge visible\n    // so we might amend offset for some situations\n    if (!shouldLoop && alignMode === CarouselAlignMode.LEFT) {\n        // Calculate prequesites\n        const rightmostPoint = newOffset + slidesSumWidth;\n        const allSlidesVisible = slidesSumWidth <= viewportWidth;\n\n        // Apply offset amendment\n        if (!allSlidesVisible && rightmostPoint <= viewportWidth) {\n            // Left aligned slides with their right edge visible:\n            // righmost slide edge should stick to the right viewport edge\n            newOffset = viewportWidth - slidesSumWidth;\n        } else if (allSlidesVisible) {\n            // Left aligned slides which are all visible:\n            // just stick them to the left viewport edge\n            newOffset = 0;\n        }\n    }\n    const result = new CalculateOffsetResult(Math.round(newOffset));\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { destroyAnimation } from './destroy-animation';\n\n/**\n * Destroys and removes any ongoing animation state\n */\nexport function destroyAnimationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        destroyAnimation(state.animation);\n        state.animation = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselAnimation } from '../../../models/carousel-animation';\n\n/**\n * Destroys animation player without callback\n */\nexport function destroyAnimation(\n    animation?: CarouselAnimation,\n): void {\n    try {\n        animation?.player?.finish();\n        animation?.player?.destroy();\n    // Ignore exception since player might be already destroyed\n    // at this moment\n    } catch (e) {}\n    animation?.onDoneSubscription$?.unsubscribe();\n}\n","import { CarouselSlideParams } from './carousel-slide-params';\n\n/**\n * Slide model representation\n */\nexport class CarouselSlide {\n\n    constructor(\n        /**\n         * Id is used in trackBy and should be generated\n         * with `IdGenerator`\n         */\n        public id: number,\n        /**\n         * Represents index from `items` array of carousel\n         * config\n         */\n        public itemIndex: number,\n        /**\n         * Parameters that might be changed over time\n         */\n        public options: Partial<CarouselSlideParams> = {},\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class MarkVisibleAndActiveResult {\n\n    // Viewport range is subarray of slides which are\n    // currently in viewport\n    constructor(\n        public slides: CarouselSlide[],\n        public inViewportRangeStart: number,\n        public inViewportRangeEnd: number,\n    ) {\n    }\n\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { markVisibleAndActive } from './mark-visible-and-active';\n\n/**\n * Assigns inViewport and isActive option to each slide\n */\nexport function markVisibleAndActiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        const result = markVisibleAndActive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.activeSlideIndex,\n            state.config.threshold,\n            state.config.alignMode,\n        );\n        state.slides = result.slides;\n        state.activeItemIndex = result.slides[state.activeSlideIndex]?.itemIndex ?? 0; // Undefined when no slides available\n        procedureState.inViewportRange = [result.inViewportRangeStart, result.inViewportRangeEnd];\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CarouselSlideParams } from '../../../models/carousel-slide-params';\nimport { MarkVisibleAndActiveResult } from './models/mark-visible-and-active-result';\n\n/**\n * Returns cloned slides with modified `inViewport` and `isActive` fields\n */\nexport function markVisibleAndActive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    activeSlideIndex: number,\n    threshold: number,\n    alignMode: CarouselAlignMode,\n): MarkVisibleAndActiveResult {\n    if (!slides || !slides.length) {\n\n        return new MarkVisibleAndActiveResult([], 0, 0);\n    }\n\n    const newSlides: CarouselSlide[] = [];\n    /** Slide index representing first slide inside viewport */\n    let inViewportStart: number = null;\n    /** Slide index representing last slide inside viewport */\n    let inViewportEnd: number = null;\n    for (let i = 0, currentOffset = offset; i < slides.length; i++, currentOffset += slideWidth) {\n        // Calculate slide options\n        const slideBeforeViewportEnd = currentOffset < viewportWidth + threshold;\n        const slideAfterViewportStart = currentOffset + slideWidth + threshold > 0;\n        const inViewport = slideBeforeViewportEnd && slideAfterViewportStart;\n        const options: Partial<CarouselSlideParams> = {\n            inViewport,\n            isActive: i === activeSlideIndex,\n        };\n\n        // Construct new slide\n        const newSlide = new CarouselSlide(\n            slides[i].id,\n            slides[i].itemIndex,\n            Object.assign({}, slides[i].options, options),\n        );\n        newSlides.push(newSlide);\n\n        // Detect viewport range\n        if (inViewport && inViewportStart === null) {\n            inViewportStart = i;\n        } else if (!inViewport && inViewportStart !== null && inViewportEnd === null) {\n            inViewportEnd = Math.max(0, i - 1);\n        }\n    }\n\n    // Edge case when last slide was in viewport:\n    // in such case viewport end index won't be assigned\n    // inside slide cycle due to loop algorithm specifics\n    if (inViewportStart !== null && inViewportEnd === null) {\n        inViewportEnd = slides.length - 1;\n    }\n\n    if (activeSlideIndex >= 0 && activeSlideIndex <= slides.length - 1) { // Active slide might be outside slide range\n        if (activeSlideIndex <= inViewportStart || inViewportStart === null) {\n            const distanceToActiveSlideViewportStart = alignMode === CarouselAlignMode.LEFT\n                ? threshold\n                : viewportWidth / 2 - slideWidth / 2 + threshold;\n            const slidesToViewportStart = Math.ceil(distanceToActiveSlideViewportStart / slideWidth);\n            inViewportStart = Math.max(0, activeSlideIndex - slidesToViewportStart);\n        }\n        if (activeSlideIndex >= inViewportEnd || inViewportEnd === null) {\n            const distanceToActiveSlideViewportEnd = alignMode === CarouselAlignMode.LEFT\n                ? viewportWidth + threshold\n                : viewportWidth / 2 + slideWidth / 2 + threshold;\n            const slidesToViewportEnd = Math.ceil(distanceToActiveSlideViewportEnd / slideWidth);\n            inViewportEnd = Math.min(slides.length - 1, activeSlideIndex + slidesToViewportEnd);\n        }\n    }\n\n    const result = new MarkVisibleAndActiveResult(newSlides, inViewportStart || 0, inViewportEnd || 0);\n\n    return result;\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class RemoveExcessiveResult {\n    constructor(\n        public slides: CarouselSlide[],\n        public offset: number,\n    ) {\n    }\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { removeExcessive } from './remove-excessive';\n\n/**\n * Removes slide copies\n */\nexport function removeExcessiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        const result = removeExcessive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            procedureState.inViewportRange[0],\n            procedureState.inViewportRange[1],\n        );\n        state.slides = result.slides;\n        state.offset = result.offset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { RemoveExcessiveResult } from './models/remove-excessive-result';\n\n/**\n * Removes slides that should not exist in carousel\n * (e.g. copies which are outside viewport)\n */\nexport function removeExcessive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    /** First slide index that is inside viewport */\n    viewportStart: number,\n    /** Last slide index that is inside viewport */\n    viewportEnd: number,\n): RemoveExcessiveResult {\n    if (!slides || !slides.length) {\n\n        return new RemoveExcessiveResult([], offset);\n    }\n    // Validate inputs\n    viewportStart = Math.max(0, Math.min(viewportStart, viewportEnd));\n    viewportEnd = Math.min(viewportStart, slides.length - 1);\n\n    const rightSlides: CarouselSlide[] = [];\n    const leftSlides: CarouselSlide[] = [];\n    const itemIndexes = new Set<number>();\n    let newOffset = offset;\n    // Next fancy loop traverses through slides array, but in specified order:\n    // first we travel through slides in viewport, so we can collect item ids,\n    // next we go through right and left side outside viewport, cleaning all\n    // found copies. Thus we can cleanse all copies in O(n)\n    for (let i = viewportStart; i <= viewportEnd; i++) {\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = viewportEnd + 1; i < slides.length; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = 0; i < viewportStart; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            newOffset += slideWidth;\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        leftSlides.push(slides[i]);\n    }\n\n    const newSlides = [\n        ...leftSlides,\n        ...rightSlides,\n    ];\n\n    return new RemoveExcessiveResult(newSlides, newOffset);\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `moveOrCopySlidesTo`\n */\nexport class CopySlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n        /** Item indexes that should be marked as copy */\n        public unmarkedItemIndexes = [],\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `shuffleSlides`\n */\nexport class ShuffleSlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { CopySlidesResult } from './models/copy-slides-result';\nimport { ShuffleSlidesResult } from './models/shuffle-slides-result';\n\n/**\n * Justifies existing slides in viewport by either\n * - Move slide from one side to another\n * - Copy slide from one side to another\n * - Create slide on one side\n *\n * Task of this function is to leave no empty spaces in viewport.\n *\n * **BE ADVICED**, that inViewport flag should be calculated for each slide\n * that should not be moved beforehand.\n */\nexport function shuffleSlides(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    items: any[],\n    shouldLoop: boolean,\n    threshold: number = 0,\n    idGenerator = new IdGenerator(),\n): ShuffleSlidesResult {\n    if (!slides || !slides.length) {\n\n        return new ShuffleSlidesResult([], offset);\n    }\n    if (slideWidth <= 0 || !shouldLoop) {\n\n        return new ShuffleSlidesResult(slides, offset);\n    }\n\n    const slideSumWidth = slides.length * slideWidth;\n\n    // Calculate missing slides for left and right sides\n    const leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));\n    const rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));\n\n    // Let's start to fill missing slides\n\n    /**\n     * Item indexes that should be marked as copies after\n     * function completes\n     */\n    let unmarkedItemIndexes = [];\n\n    // Should move slides to right side\n    if (rightSideMissingSlides) {\n        const rightSideMoveResult = moveOrCopySlidesToEnd(\n            slides,\n            offset,\n            rightSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = rightSideMoveResult.slides;\n        offset = rightSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;\n    }\n\n    // Should move slides to left side\n    if (leftSideMissingSlides) {\n        const leftSideMoveResult = moveOrCopySlidesToStart(\n            slides,\n            offset,\n            leftSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = leftSideMoveResult.slides;\n        offset = leftSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);\n    }\n\n    const result = new ShuffleSlidesResult(slides, offset);\n\n    return result;\n}\n\n/**\n * Moves, copies or creates slides to the right side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the right part,\n * because we can't break sequence (meaning if we'll copy slide `5`\n * on the right to slide `3` on the left, they won't stack).\n * Slide `3` on the left awaits slide with item index `2` to be put\n * near him, so we should create some slides in between. This action\n * is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `5` and item index `3`?\n * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 1. Now we can start copy/move slides from the right part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move one slide from the right part, since\n * `quantity` after `Option FILL` equals 1. Lets imagine that slide\n * wasn't in viewport and now our slide row has\n * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!\n */\nexport function moveOrCopySlidesToEnd(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * We can't increase quantity if we encountered slide\n     * with inViewport flag\n     */\n    let canIncreaseQuantity = true;\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from left side for analyzing.\n     */\n    let slideIndex = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    // We going to iterate through item indexes starting from\n    // last slide item index. Let's pick an item index\n    // to start from.\n    const lastSlide = slides[slides.length - 1];\n    const lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = lastSlideHasLastItemIndex\n        ? 0\n        : lastSlide.itemIndex + 1;\n\n    for (let i = 0; i < quantity; i++) {\n        /**\n         * Having this field as true means slides from left and right\n         * side (including new slides) can stack and we can proceed to\n         * COPY option\n         */\n        const firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;\n\n        if (shouldCopy || firstSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Create new slide procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions\n            );\n            newSlides.push(newSlide);\n\n            // Splice arguments processing\n\n            if (currentSlide.options.inViewport) {\n                canIncreaseQuantity = false;\n            }\n\n            // We can't increase quantity if we have reached end of slides.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (canIncreaseQuantity && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n\n            // Prepare slide to process\n            slideIndex++;\n            if (slideIndex >= slides.length) {\n                slideIndex = 0;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Create new slide procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId++;\n        if (nextItemId >= items.length) {\n            nextItemId = 0;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        slides.splice(0, spliceQuantity);\n    }\n    const resultSlides = [\n        ...slides,\n        ...newSlides\n    ];\n    const resultOffset = offset + spliceQuantity * slideWidth;\n\n    return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);\n}\n\n/**\n * Moves, copies or creates slides to the left side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the left part,\n * because we can't break sequence (meaning if we'll copy slide `0`\n * on the right to slide `3` on the right, they won't stack).\n * Slide `3` on the right side awaits slide with item index `2` to be\n * put near him, so we should create some slides in between. This\n * action is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `0` and item index `3`?\n * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 2. Now we can start copy/move slides from the left part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move two slides from the left part, since\n * `quantity` after `Option FILL` equals 2. Lets imagine that slides\n * weren't in viewport and now our row has\n * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!\n */\nexport function moveOrCopySlidesToStart(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceFrom = null;\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from right side for analyzing.\n     */\n    let slideIndex = slides.length - 1;\n\n    // We going to iterate through item indexes starting from\n    // first slide item index. Let's pick an item index\n    // to start from.\n    const firstSlide = slides[0];\n    const firstSlideHasFirstItemId = firstSlide.itemIndex === 0;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = firstSlideHasFirstItemId\n        ? items.length - 1\n        : firstSlide.itemIndex - 1;\n\n    for (let i = 0; i < quantity; i++) {\n        const lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;\n\n        if (shouldCopy || lastSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Slide copy procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions,\n            );\n            newSlides.push(newSlide);\n\n            // Prepare next slide index\n            slideIndex--;\n            if (slideIndex < 0) {\n                slideIndex = slides.length - 1;\n            }\n\n            // Splice arguments processing\n\n            // spliceFrom can be assigned once and equals first inViewport\n            // slide that we met\n            if (spliceFrom === null && currentSlide.options.inViewport) {\n                spliceFrom = slides.length - spliceQuantity;\n            }\n\n            // We can't increase quantity if we have determined\n            // from where we should splice slides\n            const slideCopyNotEncountered = spliceFrom === null;\n            // We can't have splice quantity higher than slides size.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (slideCopyNotEncountered && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Slide copy procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId--;\n        if (nextItemId < 0) {\n            nextItemId = items.length - 1;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        spliceFrom = spliceFrom === null\n            ? slides.length - spliceQuantity\n            : spliceFrom;\n        slides.splice(spliceFrom, spliceQuantity);\n    }\n    const result = [\n        ...newSlides.reverse(),\n        ...slides,\n    ];\n\n    return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { shuffleSlides } from './shuffle-slides';\n\n/**\n * Moves slide from left side to right or vise versa\n * in order to balance weight or predict offset changes\n */\nexport function shuffleSlidesProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = shuffleSlides(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.config.items,\n            state.config.shouldLoop,\n            state.config.threshold,\n            environment?.slideIdGenerator ?? new IdGenerator(),\n        );\n        state.slides = result.slides;\n        state.activeSlideIndex = result.slides.findIndex((item: CarouselSlide) => item.options.isActive) || 0;\n        if (typeof procedureState.offsetSnapshot !== 'undefined') {\n            procedureState.offsetSnapshot = result.modifiedOffset - state.offset + procedureState.offsetSnapshot;\n        }\n        state.offset = result.modifiedOffset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { animationOffsetSnapshot } from './animation-offset-snapshot';\n\n/**\n * Assigns offset to state like if animation was paused.\n * If animation is not available, current offset will be assigned.\n */\nexport function animationOffsetSnapshotProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const time = new Date().getTime();\n        const currentPosition = time - (state.animation?.startTime ?? time);\n        const result = animationOffsetSnapshot(\n            currentPosition,\n            state.config.transitionDuration,\n            state.animation?.from,\n            state.animation?.to,\n            state.offset,\n            state.animationBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { EasingFunction } from 'bezier-easing';\n\n/**\n * Calculates offset for animation specific tick\n */\nexport function animationOffsetSnapshot(\n    currentPosition: number,\n    totalDuration: number,\n    from: number,\n    to: number,\n    offsetFallback: number,\n    bezierFn: EasingFunction,\n): number {\n    if (typeof from === 'undefined' || typeof to === 'undefined') {\n\n        return offsetFallback;\n    }\n    if (totalDuration <= 0 || currentPosition < 0 || to === from) {\n\n        return to;\n    }\n    const animationDistance = Math.abs(to - from);\n    const completedDistancePercent = currentPosition / totalDuration;\n    const completedDistance = animationDistance * bezierFn(completedDistancePercent);\n    const offsetSnapshot = to > from\n        ? from + completedDistance\n        : from - completedDistance;\n\n    return offsetSnapshot;\n}\n","import { AnimationPlayer } from '@angular/animations';\nimport { Subscription } from 'rxjs';\n\n/**\n * Animation state that is currently in process\n */\nexport class CarouselAnimation {\n\n    constructor(\n        public from: number,\n        public to: number,\n        public player?: AnimationPlayer,\n        public onDoneSubscription$?: Subscription,\n        public startTime = new Date().getTime(),\n    ) {\n    }\n\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { startAnimation } from './start-animation';\n\n/**\n * Creates new transition from one slide to another\n */\nexport function startAnimationProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const animation = startAnimation(\n            state.animatableContainer,\n            procedureState.offsetSnapshot,\n            state.offset,\n            state.config.widthMode,\n            state.config.transitionDuration,\n            environment?.animationBezierArgs ?? [],\n            environment?.isBrowser ?? false,\n            environment?.afterAnimationAction ?? (() => {}),\n            environment?.animationBuilder,\n        );\n        state.animation = animation;\n\n        return new ContinueWith(state);\n    };\n}\n","import { animate, AnimationBuilder, style } from '@angular/animations';\nimport { bindCallback } from 'rxjs';\n\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselAnimation } from '../../../models/carousel-animation';\n\nexport function startAnimation(\n    container: HTMLElement,\n    from: number,\n    to: number,\n    widthMode: CarouselWidthMode,\n    transitionDuration: number,\n    bezierArgs: number[],\n    isBrowser: boolean,\n    afterAnimationAction: () => void,\n    animationBuilder: AnimationBuilder,\n): CarouselAnimation {\n    if (!isBrowser) {\n\n        return null;\n    }\n\n    const cubicBezier = `cubic-bezier(${bezierArgs[0]},${bezierArgs[1]},${bezierArgs[2]},${bezierArgs[3]})`;\n    const animationFactory = animationBuilder.build([\n        style({\n            transform: `translateX(${from}${widthMode})`,\n        }),\n        animate(`${transitionDuration}ms ${cubicBezier}`, style({\n            transform: `translateX(${to}${widthMode})`,\n        })),\n    ]);\n    const animationPlayer = animationFactory.create(container);\n    // Wrap onDone into observable\n    const boundFunction = bindCallback(animationPlayer.onDone); // Wrap function into function that returns observable\n    const onDone$ = boundFunction.call(animationPlayer); // Receive observable with context of animation player\n    const subscription$ = onDone$\n        .subscribe(() => {\n            animationPlayer.destroy();\n            afterAnimationAction();\n        });\n    const animation = new CarouselAnimation(\n        from,\n        to,\n        animationPlayer,\n        subscription$,\n    );\n    animationPlayer.play();\n\n    return animation;\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { startAnimationProcedure } from '../helpers/start-animation/start-animation-procedure';\nimport { setOffsetSnapshotProcedure } from './set-offset-snapshot/set-offset-snapshot-procedure';\n\n/**\n * Calculates corresponding parts for current active slide\n */\nexport function setSlideIndexProcedure(): Procedure {\n    return procedurePipe('setSlideIndex',\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        setOffsetSnapshotProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        shuffleSlidesProcedure(),\n        startAnimationProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Save offset to procedure state until later use\n */\nexport function setOffsetSnapshotProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.offsetSnapshot = state.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { normalizePassedDistanceProcedure } from './normalize-passed-distance/normalize-passed-distance-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Calculates state after user finish drag event\n */\nexport function dragEndProcedure(passedDistance: number): Procedure {\n    return procedurePipe('dragEnd',\n        enableAutoplayProcedure(AutoplaySuspender.DRAG),\n        normalizePassedDistanceProcedure(passedDistance),\n        calculateActiveSlideProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../../helpers/get-viewport-width-in-px/get-viewport-width-in-px';\n\n/** Converts passed distance to carousel width units */\nexport function normalizePassedDistanceProcedure(passedDistance: number): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.passedDistance = state.config.widthMode === CarouselWidthMode.PERCENT\n            ? 100 * passedDistance / getViewportWidthInPx(state)\n            : passedDistance;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\n\n/**\n * Return new offset modified by last drag operations.\n * Applies overscroll behavior when necessary.\n *\n * @returns modified offset\n */\nexport function dragOffsetSnapshot(\n    /** X position in pixels from where drag event began */\n    fromX: number,\n    /** destination X in pixels of last fired drag event */\n    toX: number,\n    currentOffset: number,\n    widthMode: CarouselWidthMode,\n    alignMode: CarouselAlignMode,\n    shouldLoop: boolean,\n    viewportWidth: number,\n    viewportWidthInPx: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    /** How much in percents user can overscroll unlooped carousel */\n    maxOverscrollPercent: number,\n    bezierFn: EasingFunction,\n    invertedBezierFn: EasingFunction,\n): number {\n    if (fromX === toX) {\n\n        return currentOffset;\n    }\n\n    // Normalize all pixel values to current width mode\n    if (widthMode === CarouselWidthMode.PERCENT) {\n        fromX = fromX * 100 / viewportWidthInPx;\n        toX = toX * 100 / viewportWidthInPx;\n    }\n\n    let offsetDelta = toX - fromX;\n\n    // 1st case: no bezier amendments, just return offset with applied delta\n    if (shouldLoop) {\n\n        return currentOffset + offsetDelta;\n    }\n\n    const overscrollStartPoint = detectOverscrollStartPoint(\n        fromX,\n        currentOffset,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        alignMode,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n\n    // 2nd case where bezier correction haven't started yet,\n    // meaning we're in safe zone at both side\n    if (overscrollStartPoint === null) {\n        const offsetFromSafeZone = applyDeltaFromSafeZone(\n            currentOffset,\n            offsetDelta,\n            alignMode,\n            viewportWidth,\n            slideWidth,\n            slideSumWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n\n        return offsetFromSafeZone;\n    }\n\n    // Seems like we already at overscroll zone, so let's see\n    // the ways we could manage that\n\n    /** Whether drag was performed from overscroll zone to same overscroll zone */\n    const dragStaysInSameOverscrollZone = fromX > overscrollStartPoint\n        ? toX > overscrollStartPoint\n        : toX < overscrollStartPoint;\n\n    // 3rd case: we should not amend when drag pointer is still in overscroll zone\n    // after applying delta\n    if (dragStaysInSameOverscrollZone) {\n        const distanceBefore = fromX - overscrollStartPoint;\n        const distanceAfter = toX - overscrollStartPoint;\n        const distance = distanceBetween(\n            distanceBefore,\n            distanceAfter,\n            viewportWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n        currentOffset = currentOffset - distance;\n\n        return currentOffset;\n    }\n\n    // 4th case where drag pointer has returned to safe zone.\n    // We should do the same calculation like we did in 2nd case.\n    const overscrollDistance = applyDeltaFromOverscrollZone(\n        overscrollStartPoint - fromX,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distancetoSafeZone = overscrollStartPoint - fromX;\n    currentOffset += overscrollDistance;\n    fromX = overscrollStartPoint;\n    offsetDelta -= distancetoSafeZone;\n\n    const result = applyDeltaFromSafeZone(\n        currentOffset,\n        offsetDelta,\n        alignMode,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n\n    return result;\n}\n\n/**\n * Applies bezier on distance and limit with max overscroll distance\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromOverscrollZone(\n    distance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    /** Viewport % from 0 to 1 of delta distance */\n    const deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));\n    /** Maximal distance of overscroll in pixels */\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    /**\n     * How much delta is actually long when applying bezier\n     * and aligning overscroll max distance\n     */\n    const deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);\n\n    return deltaDistance;\n}\n\n/**\n * Applies delta to current offset which is currently in safe zone at this moment.\n * Applies bezier whether delta intersects overscroll zone.\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromSafeZone(\n    currentOffset: number,\n    offsetDelta: number,\n    alignMode: CarouselAlignMode,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(viewportWidth, slideSumWidth);\n    /** Whether left side of carousel is in viewport after applying delta */\n    const leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;\n    /** Whether right side of carousel is in viewport after applying delta */\n    const rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;\n\n    const canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)\n        || (!rightSideExposedAfter && offsetDelta < 0);\n\n    if (canSafelyTransit) {\n        // We're still safe on both sides, just apply delta\n\n        return currentOffset + offsetDelta;\n    }\n\n    /**\n     * Distance between current offset and point\n     * where overscroll begins\n     */\n    let distanceToSafeZone = 0;\n    // Move offset to the point where overscroll begins\n    if (leftSideExposedAfter) {\n        distanceToSafeZone = currentOffset - leftmostPoint;\n    } else if (rightSideExposedAfter) {\n        distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;\n    }\n\n    /**\n     * Distance between current offset and\n     * overscroll zone starting point\n     */\n    const distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;\n    currentOffset -= distanceToSafeZone;\n\n    const overscrollDelta = applyDeltaFromOverscrollZone(\n        distanceWithoutSafeZone,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    currentOffset += overscrollDelta;\n\n    return currentOffset;\n}\n\n/**\n * Returns point where overscroll should potentially start\n * or null if carousel is currently in safe zone.\n */\nfunction detectOverscrollStartPoint(\n    fromX: number,\n    currentOffset: number,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    alignMode: CarouselAlignMode,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number | null {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(leftmostPoint + slideSumWidth, viewportWidth);\n\n    /** Distance from current offset to safe zone */\n    let overscrollConvertedDistance: number | null = null;\n    // Special case when left-aligned carousel is lesser than viewport width\n    if (alignMode === CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {\n        overscrollConvertedDistance = currentOffset;\n    } else if (currentOffset > leftmostPoint) {\n        overscrollConvertedDistance = currentOffset - leftmostPoint;\n    } else if (currentOffset < rightmostPoint - slideSumWidth) {\n        overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;\n    }\n    if (overscrollConvertedDistance === null) {\n\n        return null;\n    }\n    const overscrollRealDistance = extractDeltaFromOverscrollZone(\n        overscrollConvertedDistance,\n        viewportWidth,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n    const overscrollStartPoint = fromX - overscrollRealDistance;\n\n    return overscrollStartPoint;\n}\n\n/**\n * Converts distance with bezier applied to distance\n * without bezier\n */\nfunction extractDeltaFromOverscrollZone(\n    convertedDistance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number {\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    const bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);\n    const deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);\n\n    return deltaPercentage;\n}\n\n/**\n * Calculates overscroll distance between two points\n */\nfunction distanceBetween(\n    firstPoint: number,\n    secondPoint: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const overscrollBefore = applyDeltaFromOverscrollZone(\n        firstPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const overscrollAfter = applyDeltaFromOverscrollZone(\n        secondPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distance = overscrollBefore - overscrollAfter;\n\n    return distance;\n}\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class BreakWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = true;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: ProcedureCarouselState = null,\n    ) {\n    }\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure whether drag is disabled\n */\nexport function postponeDragEnabledProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (state?.config?.dragEnabled) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { dragOffsetSnapshotProcedure } from '../helpers/drag-offset/drag-offset-snapshot-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state after single tick of drag event\n */\nexport function dragProcedure(fromX: number, toX: number): Procedure {\n    return procedurePipe('drag',\n        postponeDragEnabledProcedure(),\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        dragOffsetSnapshotProcedure(fromX, toX),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n        markVisibleAndActiveProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { dragOffsetSnapshot } from './drag-offset-snapshot';\n\n/**\n * Assigns offset to state by given distance coordinates\n */\nexport function dragOffsetSnapshotProcedure(fromX: number, toX: number): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = dragOffsetSnapshot(\n            fromX,\n            toX,\n            state.offset,\n            state.config.widthMode,\n            state.config.alignMode,\n            state.config.shouldLoop,\n            getViewportWidth(state),\n            getViewportWidthInPx(state),\n            state.config.slideWidth,\n            state.slides.length * state.config.slideWidth,\n            environment.maxOverscroll,\n            state.dragBezierFn,\n            state.invertedDragBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IterateSideResult } from './models/iterate-side-result';\n\n/**\n * Finds slide that is marked as `isActive` and returns its index\n */\nexport function findSlideIndex(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): number {\n    if (!slides) {\n\n        return 0;\n    }\n    const currentActiveSlide = slides[currentSlideIndex];\n    if (!currentActiveSlide) {\n\n        return 0;\n    }\n    const currentItemIndex = currentActiveSlide.itemIndex;\n    let targetSlideIndex: IterateSideResult | null = null;\n    if (newItemIndex === currentItemIndex || slides.length <= 1) {\n\n        return currentSlideIndex;\n    } else if (newItemIndex > currentItemIndex) {\n        targetSlideIndex =\n            iterateRightSide(slides, newItemIndex, currentSlideIndex)\n            || iterateLeftSide(slides, newItemIndex, currentSlideIndex);\n    } else {\n        targetSlideIndex =\n            iterateLeftSide(slides, newItemIndex, currentSlideIndex)\n            || iterateRightSide(slides, newItemIndex, currentSlideIndex);\n    }\n\n    return targetSlideIndex?.foundIndex ?? null;\n}\n\nfunction iterateRightSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex + 1; i < slides.length; i++) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n\nfunction iterateLeftSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex - 1; i >= 0; i--) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { findSlideIndex } from './find-slide-index';\n\n/**\n * Assigns slide index by given item index\n */\nexport function findSlideIndexProcedure(itemIndex?: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = findSlideIndex(\n            state.slides,\n            itemIndex ?? state.activeItemIndex,\n            state.activeSlideIndex,\n        );\n        state.activeSlideIndex = result;\n        state.activeItemIndex = itemIndex;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { findSlideIndexProcedure } from '../helpers/find-slide-index/find-slide-index-procedure';\nimport { postponeItemIndexProcedure } from './postpone-item-index/postpone-item-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/** Assigns item index and shuffles slides accordingly */\nexport function goToProcedure(newItemIndex: number): Procedure {\n    return procedurePipe('goTo',\n        postponeItemIndexProcedure(newItemIndex),\n        enableAutoplayProcedure(),\n        findSlideIndexProcedure(newItemIndex),\n        setSlideIndexProcedure(),\n    );\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Guard for assigning item index when no slides are available.\n * Would break procedure on such occasion.\n */\nexport function postponeItemIndexProcedure(newItemIndex: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.slides || !state.slides.length) {\n            state.postponedItemIndex = newItemIndex;\n\n            return new BreakWith(state);\n        }\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { initializeCarousel } from './initialize-carousel';\n\n/**\n * Creates new slide set from scratch\n */\nexport function initializeCarouselProcedure(): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = initializeCarousel(\n            state.config.items,\n            environment.slideIdGenerator,\n        );\n        state.slides = result;\n        state.offset = 0;\n        state.activeSlideIndex = 0;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\n\n/**\n * Fills empty carousel with slides without any\n * alignments\n */\nexport function initializeCarousel(\n    items: any[],\n    idGenerator: IdGenerator,\n): CarouselSlide[] {\n    if (!items || !items.length || !idGenerator) {\n\n        return [];\n    }\n\n    const newSlides = new Array(items.length);\n\n    for (let i = 0; i < items.length; i++) {\n        newSlides[i] = new CarouselSlide(idGenerator.next(), i, {item: items[i], isActive: i === 0});\n    }\n\n    return newSlides;\n}\n","import bezier from 'bezier-easing';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n// Reference: https://easings.net/ru\n// Standard ease\nexport const ANIMATION_BEZIER_ARGS = [0.25, 0.1, 0.25, 1];\n// Ease out quad\nconst DRAG_BEZIER_ARGS = [0.25, 0.46, 0.45, 0.94];\n\n/**\n * Creates bezier functions for different purposes\n */\nexport function setBeziersProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.dragBezierFn) {\n            state.dragBezierFn = bezier(\n                DRAG_BEZIER_ARGS[0],\n                DRAG_BEZIER_ARGS[1],\n                DRAG_BEZIER_ARGS[2],\n                DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.invertedDragBezierFn) {\n            state.invertedDragBezierFn = bezier(\n                1 - DRAG_BEZIER_ARGS[0],\n                1 - DRAG_BEZIER_ARGS[1],\n                1 - DRAG_BEZIER_ARGS[2],\n                1 - DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.animationBezierFn) {\n            state.animationBezierFn = bezier(\n                ANIMATION_BEZIER_ARGS[0],\n                ANIMATION_BEZIER_ARGS[1],\n                ANIMATION_BEZIER_ARGS[2],\n                ANIMATION_BEZIER_ARGS[3],\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { ComposedProcedure } from '../../../models/procedure/composed-procedure.type';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { procedurePipe } from '../../../models/procedure/procedure-pipe';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { goToProcedure } from '../go-to-procedure';\nimport { removePostponedIndexProcedure } from '../remove-postponed-index/remove-postponed-index-procedure';\n\n/**\n * Saves freshly selected item index till later\n * until carousel is initialized\n */\nexport function setPostponedIndexProcedure(): ComposedProcedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler | Procedure => {\n        if (state.slides.length && state.postponedItemIndex) {\n            const itemIndex = state.postponedItemIndex;\n\n            return procedurePipe('setPostponedIndex',\n                goToProcedure(itemIndex),\n                removePostponedIndexProcedure(),\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\nexport function removePostponedIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade) => {\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { initializeCarouselProcedure } from '../helpers/initialize-carousel/initialize-carousel-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeInitializationProcedure } from './postpone-initialization/postpone-initialization-procedure';\nimport { setBeziersProcedure } from './set-beziers/set-beziers-procedure';\nimport { setFirstInitializationProcedure } from './set-first-initalization/set-first-initialization-procedure';\nimport { setPostponedIndexProcedure } from './set-postponed-index/set-postponed-index-procedure';\n\n/**\n * Creates slides from scratch\n */\nexport function initializeProcedure(): Procedure {\n    return procedurePipe('initialize',\n        postponeInitializationProcedure(),\n\n        setFirstInitializationProcedure(),\n        initializeCarouselProcedure(),\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        destroyAnimationProcedure(),\n        enableAutoplayProcedure(),\n        calculateActiveSlideProcedure(),\n        setBeziersProcedure(),\n\n        setPostponedIndexProcedure(),\n    );\n}\n","import { InitializationState } from '../../../models/initialization-state';\nimport { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure when carousel is not ready\n * for first initialization\n */\nexport function postponeInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const phase = state?.initializationState ?? new InitializationState();\n        if (phase.configInitialized && phase.viewportWidthInitialized) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Set state as initialized\n */\nexport function setFirstInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.initializationState.firstInitalization = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselConfig } from '../../../carousel-config';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setConfigProcedure } from './set-config/set-config-procedure';\n\n/**\n * Assigns config and executes initialization effects\n */\nexport function initializeConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return procedurePipe('initializeConfig',\n        setConfigProcedure(newConfig),\n        initializeProcedure(),\n    );\n}\n","import { CarouselConfig } from '../../../../carousel-config';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns carousel config, works as part of multiphase carousel initialization\n */\nexport function setConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.config = newConfig;\n        state.initializationState.configInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setContainersProcedure } from './set-containers/set-containers-procedure';\n\n/**\n * Assigns specified DOM containers to carousel state\n */\nexport function initializeContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return procedurePipe('initializeContainers',\n        setContainersProcedure(widthContainer, animatableContainer),\n        initializeProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Saves DOM element containers for carousel as part of initialization phase\n */\nexport function setContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.widthContainer = widthContainer;\n        state.animatableContainer = animatableContainer;\n        state.initializationState.viewportWidthInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getNextIndexProcedure } from '../helpers/get-next-index/get-next-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Increments current slide\n */\nexport function nextProcedure(omitAutoplayReset = false): Procedure {\n    return procedurePipe('next',\n        omitAutoplayReset ? enableAutoplayProcedure() : null,\n        getNextIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getNextIndex } from './get-next-index';\n\n/**\n * Increments current item index\n */\nexport function getNextIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getNextIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","/**\n * Returns next slide index as if user\n * clicked \"next\" button\n */\nexport function getNextIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex + 1;\n    if (newIndex >= slidesLength) {\n        newIndex = shouldLoop\n            ? 0\n            : slidesLength - 1;\n    }\n\n    return newIndex;\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getPrevIndexProcedure } from '../helpers/get-prev-index/get-prev-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Decrements current slide\n */\nexport function prevProcedure(): Procedure {\n    return procedurePipe('prev',\n        enableAutoplayProcedure(),\n        getPrevIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getPrevIndex } from './get-prev-index';\n\n/**\n * Decrements current item index\n */\nexport function getPrevIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getPrevIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","/**\n * Returns previous slide index as if user\n * clicked \"prev\" button\n */\nexport function getPrevIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex - 1;\n    if (newIndex < 0) {\n        newIndex = shouldLoop\n            ? slidesLength - 1\n            : 0;\n    }\n\n    return newIndex;\n}\n","import { AnimationBuilder } from '@angular/animations';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, OnDestroy, PLATFORM_ID, TemplateRef } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselState } from '../models/carousel-state';\nimport { IdGenerator } from '../models/id-generator';\nimport { ProcedureEnvironment } from '../models/procedure/procedure-environment.interface';\nimport { procedurePipe } from '../models/procedure/procedure-pipe';\nimport { Procedure } from '../models/procedure/procedure.type';\nimport { SLIDE_ID_GENERATOR } from '../tokens';\nimport { disableAutoplayProcedure } from './helpers/disable-autoplay/disable-autoplay-procedure';\nimport { enableAutoplayProcedure } from './helpers/enable-autoplay/enable-autoplay-procedure';\nimport { cleanupProcedure } from './procedures/cleanup-procedure';\nimport { dragEndProcedure } from './procedures/drag-end-procedure';\nimport { dragProcedure } from './procedures/drag-procedure';\nimport { dragStartProcedure } from './procedures/drag-start-procedure';\nimport { goToProcedure } from './procedures/go-to-procedure';\nimport { initializeConfigProcedure } from './procedures/initialize-config-procedure';\nimport { initializeContainersProcedure } from './procedures/initialize-containers-procedure';\nimport { nextProcedure } from './procedures/next-procedure';\nimport { prevProcedure } from './procedures/prev-procedure';\nimport { recalculateProcedure } from './procedures/recalculate-procedure';\nimport { ANIMATION_BEZIER_ARGS } from './procedures/set-beziers/set-beziers-procedure';\nimport { setTemplateProcedure } from './procedures/set-template/set-template-procedure';\n\n/**\n * Short swipe might not change slide to next/prev.\n * This const specifies how much (% of viewport) swipe\n * should overcome to trigger next/prev slide change.\n */\nconst MAX_SWIPE_THRESHOLD = 15;\n/**\n * How much % user can stretch carousel, when there's no more\n * drag available\n */\nconst MAX_OVERSCROLL = 10;\n\n@Injectable()\nexport class CarouselService implements OnDestroy {\n\n    private readonly carouselState$ = new BehaviorSubject<CarouselState>(new CarouselState());\n    /** Describes constant entities for procedures */\n    private readonly procedureEnvironment: ProcedureEnvironment = {\n        slideIdGenerator: this.slideIdGenerator,\n        isBrowser: isPlatformBrowser(this.platformId),\n        autoplayAction: this.next.bind(this),\n        afterAnimationAction: this.cleanup.bind(this),\n        animationBuilder: this.animationBuilder,\n        animationBezierArgs: ANIMATION_BEZIER_ARGS,\n        swipeThreshold: MAX_SWIPE_THRESHOLD,\n        maxOverscroll: MAX_OVERSCROLL,\n    };\n\n    constructor(\n        private animationBuilder: AnimationBuilder,\n        @Inject(SLIDE_ID_GENERATOR) private slideIdGenerator: IdGenerator,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnDestroy(): void {\n        this.carouselState$.getValue()?.autoplay?.autoplaySubscription?.unsubscribe();\n    }\n\n    carouselStateChanges(): Observable<CarouselState> {\n        return this.carouselState$.asObservable();\n    }\n\n    setItemIndex(newItemIndex: number): void {\n        this.apply(goToProcedure(newItemIndex));\n    }\n\n    prev(): void {\n        this.apply(prevProcedure());\n    }\n\n    /**\n     * @param omitAutoplayReset whether autoplay timer should not be resetted\n     */\n    next(omitAutoplayReset = false): void {\n        this.apply(nextProcedure(omitAutoplayReset));\n    }\n\n    recalculate(): void {\n        this.apply(recalculateProcedure());\n    }\n\n    /** Update state to announce that drag sequence just started */\n    dragStart(): void {\n        this.apply(dragStartProcedure());\n    }\n\n    /**\n     * Update state to announce that drag sequence just ended\n     * and perform necessary cleanups\n     */\n    dragEnd(passedDistance: number): void {\n        this.apply(dragEndProcedure(passedDistance));\n    }\n\n    /** Process single drag tick with given from and to coordinates */\n    drag(fromX: number, toX: number): void {\n        this.apply(dragProcedure(fromX, toX));\n    }\n\n    setSlideTemplate(newTemplateRef: TemplateRef<any> | null): void {\n        this.apply(setTemplateProcedure(newTemplateRef));\n    }\n\n    disableAutoplay(suspender: AutoplaySuspender): void {\n        this.apply(disableAutoplayProcedure(suspender));\n    }\n\n    /**\n     * Starts new autoplay timer\n     */\n    enableAutoplay(suspender: AutoplaySuspender = null): void {\n        this.apply(enableAutoplayProcedure(suspender));\n    }\n\n    setContainers(widthContainer: HTMLElement, animatableContainer: HTMLElement): void {\n        this.apply(initializeContainersProcedure(widthContainer, animatableContainer));\n    }\n\n    setConfig(newConfig: CarouselConfig): void {\n        this.apply(initializeConfigProcedure(newConfig));\n    }\n\n    private cleanup(): void {\n        this.apply(cleanupProcedure());\n    }\n\n    /**\n     * Applies specified procedure to carousel state\n     */\n    private apply(procedure: Procedure): void {\n        const state: CarouselState = Object.assign({}, this.carouselState$.getValue());\n        const result = procedurePipe('applier', procedure)({state, procedureState: {}, environment: this.procedureEnvironment});\n        this.carouselState$.next(result.state);\n    }\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Programmaticaly recalculates current state\n */\nexport function recalculateProcedure(): Procedure {\n    return procedurePipe('recalculate',\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n    );\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { disableAutoplayProcedure } from '../helpers/disable-autoplay/disable-autoplay-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state when drag event starts\n */\nexport function dragStartProcedure(): Procedure {\n    return procedurePipe('dragStart',\n        postponeDragEnabledProcedure(),\n        disableAutoplayProcedure(AutoplaySuspender.DRAG),\n    );\n}\n","import { TemplateRef } from '@angular/core';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns TemplateRef where slides would be rendered\n */\nexport function setTemplateProcedure(template: TemplateRef<any> | null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.template = template;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { removeExcessiveProcedure } from '../helpers/remove-excessive/remove-excessive-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Cleans state from excessive slides and completes\n * corresponding duties after completed transition\n */\nexport function cleanupProcedure(): Procedure {\n    return procedurePipe('cleanup',\n        destroyAnimationProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        calculateActiveSlideProcedure(),\n        removeExcessiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n    );\n}\n","import { ChangeDetectionStrategy, Component, ContentChild, Input, Output, ViewEncapsulation } from '@angular/core';\nimport { map } from 'rxjs/operators';\n\nimport { CarouselConfig } from './carousel-config';\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselState } from './private/models/carousel-state';\nimport { IdGenerator } from './private/models/id-generator';\nimport { CarouselService } from './private/service/carousel.service';\nimport { ANIMATION_ID_GENERATOR, SLIDE_ID_GENERATOR } from './private/tokens';\n\nexport function idGeneratorFactory(): IdGenerator {\n    return new IdGenerator();\n}\n\n@Component({\n    selector: 'ng-carousel',\n    templateUrl: 'carousel.component.html',\n    styleUrls: ['carousel.component.scss'],\n    providers: [\n        CarouselService,\n        {\n            provide: SLIDE_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n        {\n            provide: ANIMATION_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n    ],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    exportAs: 'ngCarousel',\n})\n/**\n * Defines carousel API to work with\n */\nexport class CarouselComponent {\n\n    @ContentChild(CarouselSlideDirective) set slideRef(newSlideRef: CarouselSlideDirective) {\n        this.carousel.setSlideTemplate(newSlideRef\n            ? newSlideRef.templateRef\n            : null\n        );\n    }\n\n    @Input() set config(newConfig: CarouselConfig) {\n        newConfig = new CarouselConfig(newConfig);\n        this.carousel.setConfig(newConfig);\n    }\n\n    @Output() itemIndexChange = this.carousel.carouselStateChanges()\n        .pipe(\n            map((state: CarouselState) => state.activeItemIndex),\n        );\n\n    constructor(\n        private carousel: CarouselService,\n    ) {\n    }\n\n    next(): void {\n        this.carousel.next();\n    }\n\n    prev(): void {\n        this.carousel.prev();\n    }\n\n    setIndex(newIndex: number): void {\n        this.carousel.setItemIndex(newIndex);\n    }\n\n    /**\n     * Programmaticaly recalculates carousel position in case of\n     * container size changes or other size interactions\n     */\n    recalculate(): void {\n        this.carousel.recalculate();\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, isDevMode, PLATFORM_ID } from '@angular/core';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class HammerProviderService {\n\n    private hammerAbsenceDeclared = false;\n\n    constructor(\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    public managerFor(element: HTMLElement): HammerManager | null {\n        const hasGestures = isPlatformBrowser(this.platformId) && (window as any).Hammer;\n        if (!hasGestures) {\n            if (isDevMode() && !this.hammerAbsenceDeclared) {\n                console.warn(\n                    'Ng-carousel could not listen to drag, because HammerJS was not found. Either disable drag or import HammerJS.'\n                );\n                this.hammerAbsenceDeclared = true;\n            }\n\n            return null;\n        }\n        const hammerManager = new Hammer(element);\n\n        return hammerManager;\n    }\n}\n","import { Directive, ElementRef, HostListener, OnDestroy, OnInit } from '@angular/core';\nimport { asyncScheduler } from 'rxjs';\n\nimport { HammerProviderService } from './private/service/hammer-provider.service';\n\n@Directive({\n    selector: '[ngCarouselPreventGhostClick]',\n})\nexport class PreventGhostClickDirective implements OnInit, OnDestroy {\n\n    private hammerManager: HammerManager;\n    private shouldPreventClick = false;\n\n    @HostListener('click', ['$event'])\n    private processClickEvent(event: Event): void {\n        if (this.shouldPreventClick) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n        }\n    }\n\n    constructor(\n        private elementRef: ElementRef,\n        private hammer: HammerProviderService,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenPanEndEvents();\n    }\n\n    ngOnDestroy() {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private listenPanEndEvents(): void {\n        this.hammerManager = this.hammer.managerFor(this.elementRef.nativeElement);\n        if (!this.hammerManager) {\n\n            return;\n        }\n        this.hammerManager.on('panend pancancel', () => {\n            this.shouldPreventClick = true;\n            asyncScheduler.schedule(() => {\n                this.shouldPreventClick = false;\n            });\n        });\n    }\n\n}\n","import { CdkTrapFocus, InteractivityChecker } from '@angular/cdk/a11y';\nimport { AfterViewInit, Directive, ElementRef, Input, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\n\n@Directive({\n    selector: '[untabbable]',\n})\n/**\n * Applies tabindex=-1 for interactive elements inside container\n */\nexport class FocusBlockDirective implements OnChanges, AfterViewInit, OnDestroy {\n\n    @Input() untabbable = false;\n    @Input() untabbableFocusTrapRef: CdkTrapFocus;\n    /** Whether focus inside carousel */\n    @Input() untabbableFocused = false;\n\n    private readonly lastTabindexValueMap = new Map<HTMLElement, string | null>();\n    private viewInitiated: boolean;\n    private mutationObserver: MutationObserver;\n\n    constructor(\n        private elementRef: ElementRef,\n        private interactivityChecker: InteractivityChecker,\n    ) {\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (changes.untabbable && this.viewInitiated) {\n            const change = changes.untabbable;\n            if (change.currentValue === change.previousValue) {\n\n                return;\n            }\n            change.currentValue\n                ? this.blockTabindex()\n                : this.unblockTabindex();\n            if (this.untabbableFocused && this.untabbableFocusTrapRef) {\n                this.untabbableFocusTrapRef.focusTrap.focusFirstTabbableElement();\n            }\n        }\n    }\n\n    ngAfterViewInit() {\n        this.viewInitiated = true;\n        this.untabbable\n            ? this.blockTabindex()\n            : this.unblockTabindex();\n    }\n\n    ngOnDestroy() {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n    }\n\n    private blockTabindex(): void {\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.blockElement(element);\n        }\n        if (typeof window !== 'undefined' && 'MutationObserver' in window) {\n            this.mutationObserver = new MutationObserver(\n                (mutationList: MutationRecord[]) => {\n                    const changesArray = Array.from(mutationList);\n                    for (const change of changesArray) {\n                        if (change.type === 'attributes') {\n                            this.blockElement(change.target as HTMLElement);\n                        } else if (change.type === 'childList') {\n                            change.addedNodes.forEach((element: Node) => {\n                                this.blockElement(element as HTMLElement);\n                            });\n                        }\n                    }\n                }\n            );\n            this.mutationObserver.observe(this.elementRef.nativeElement, {\n                attributeFilter: ['tabindex'],\n                attributes: true,\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n\n    private unblockTabindex(): void {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.unblockElement(element);\n        }\n    }\n\n    private blockElement(element: HTMLElement): void {\n        // nodeType is text node, should not be blocked\n        if (element.nodeType !== 3 && this.interactivityChecker.isFocusable(element) && this.interactivityChecker.isTabbable(element)) {\n            const currentTabindexValue = element.getAttribute('tabindex');\n            this.lastTabindexValueMap.set(element, currentTabindexValue);\n            if (currentTabindexValue !== '-1') {\n                element.setAttribute('tabindex', '-1');\n            }\n        }\n    }\n\n    private unblockElement(element: HTMLElement): void {\n        if (this.lastTabindexValueMap.has(element) && typeof this.lastTabindexValueMap.get(element) === 'number') {\n            element.setAttribute('tabindex', this.lastTabindexValueMap.get(element));\n        } else {\n            element.removeAttribute('tabindex');\n        }\n    }\n}\n","/**\n * Template context for carousel slide\n */\nexport class CarouselSlideContext {\n\n    constructor(\n        public $implicit: any,\n        public itemIndex: number,\n        public isActive: boolean,\n        public inViewport: boolean,\n    ) {\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, ElementRef, Inject, OnDestroy, OnInit, PLATFORM_ID, Renderer2, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { fromEvent, Observable, Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMapTo, takeUntil } from 'rxjs/operators';\n\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselSlide } from '../models/carousel-slide';\nimport { CarouselSlideContext } from '../models/carousel-slide-context';\nimport { CarouselState } from '../models/carousel-state';\nimport { CarouselService } from '../service/carousel.service';\nimport { HammerProviderService } from '../service/hammer-provider.service';\n\n@Component({\n  selector: 'carousel-engine',\n  templateUrl: './carousel-engine.component.html',\n  styleUrls: ['./carousel-engine.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\n/**\n * Contains listeners and other DOM controllers\n */\nexport class CarouselEngineComponent implements OnInit, OnDestroy {\n\n    @ViewChild('galleryRef', {static: true}) galleryRef: ElementRef;\n    public readonly transformValue$ = this.transformValueChanges();\n    public readonly slideWidth$ = this.slideWidthChanges();\n    public readonly template$ = this.templateChanges();\n    public readonly slides$ = this.slidesChanges();\n    public focused = false;\n    private readonly destroyed$ = new Subject<void>();\n    private mouseEnterDestructor: () => void;\n    private mouseLeaveDestructor: () => void;\n    private keyboardListener: () => void;\n    private containerScrollListener: () => void;\n    private hammerManager: HammerManager;\n\n    private get htmlElement(): HTMLElement {\n        return this.elementRef.nativeElement;\n    }\n\n    constructor(\n        private carousel: CarouselService,\n        private elementRef: ElementRef,\n        private renderer: Renderer2,\n        private hammer: HammerProviderService,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenToAutoplay();\n        this.listenToDragEvents();\n        this.listenToResizeEvents();\n        this.listenToKeyEvents();\n        this.listenToScrollEvents();\n        this.carousel.setContainers(this.htmlElement, this.galleryRef.nativeElement);\n    }\n\n    ngOnDestroy() {\n        this.destroyMouseListeners();\n        this.destroyHammer();\n        this.destroyKeyboardListeners();\n        this.destroyElementScrollListener();\n        this.destroyed$.next();\n        this.destroyed$.complete();\n    }\n\n    trackByFn(index: number, item: CarouselSlide): number {\n        return item.id;\n    }\n\n    contextOf(slide: CarouselSlide): CarouselSlideContext {\n        return new CarouselSlideContext(\n            slide.options.item,\n            slide.itemIndex,\n            slide.options.isActive,\n            slide.options.inViewport,\n        );\n    }\n\n    focusIn(): void {\n        this.focused = true;\n        this.carousel.disableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    focusOut(): void {\n        this.focused = false;\n        this.carousel.enableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    private destroyMouseListeners(): void {\n        if (this.mouseEnterDestructor) {\n            this.mouseEnterDestructor();\n        }\n        if (this.mouseLeaveDestructor) {\n            this.mouseLeaveDestructor();\n        }\n    }\n\n    private destroyHammer(): void {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private destroyKeyboardListeners(): void {\n        if (this.keyboardListener) {\n            this.keyboardListener();\n        }\n    }\n\n    private destroyElementScrollListener(): void {\n        if (this.containerScrollListener) {\n            this.containerScrollListener();\n        }\n    }\n\n    private transformValueChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `translateX(${state.offset}${state.config.widthMode})`),\n            );\n    }\n\n    private slideWidthChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `${state.config.slideWidth}${state.config.widthMode}`),\n            );\n    }\n\n    private slidesChanges(): Observable<CarouselSlide[]> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.slides),\n            );\n    }\n\n    private templateChanges(): Observable<TemplateRef<any>> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.template),\n            );\n    }\n\n    private listenToAutoplay(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.autoplayEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((autoplayEnabled: boolean) => {\n                if (this.mouseEnterDestructor) {\n                    this.mouseEnterDestructor();\n                }\n                if (this.mouseLeaveDestructor) {\n                    this.mouseLeaveDestructor();\n                }\n                if (!autoplayEnabled) {\n\n                    return;\n                }\n                this.mouseEnterDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseenter',\n                    () => this.carousel.disableAutoplay(AutoplaySuspender.MOUSE),\n                );\n                this.mouseLeaveDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseleave',\n                    () => this.carousel.enableAutoplay(AutoplaySuspender.MOUSE),\n                );\n            });\n    }\n\n    private listenToDragEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.dragEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((dragEnabled: boolean) => {\n                if (this.hammerManager) {\n                    this.hammerManager.destroy();\n                }\n                if (!dragEnabled) {\n\n                    return;\n                }\n                this.hammerManager = this.hammer.managerFor(this.htmlElement);\n                if (!this.hammerManager) {\n\n                    return;\n                }\n                let lastDelta = 0;\n                let lastTouchAction: string;\n\n                this.hammerManager.on('panstart', (event: HammerInput) => {\n                    // Checking whether pan started with horizontal gesture,\n                    // we should block all scroll attempts during current pan session then\n                    // tslint:disable-next-line: no-bitwise\n                    if (event.offsetDirection & Hammer.DIRECTION_HORIZONTAL) {\n                        lastDelta = Math.round(event.deltaX);\n                        this.carousel.dragStart();\n                        lastTouchAction = this.htmlElement.style.touchAction;\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', 'none');\n                    }\n                });\n\n                this.hammerManager.on('panright panleft', (event: HammerInput) => {\n                    // We should not treat vertical pans as horizontal.\n                    // Be adviced that pan right/left events still counts\n                    // vertical pans as legitimate horizontal pan.\n\n                    // Next check clarifies that initial gesture was horizontal,\n                    // otherwise this variable would be falsy\n                    if (lastTouchAction) {\n                        const x = Math.round(event.center.x);\n                        const deltaX = Math.round(event.deltaX);\n                        this.carousel.drag(x, x + (deltaX - lastDelta));\n                        lastDelta = deltaX;\n                    }\n                });\n\n                this.hammerManager.on('panend pancancel', (event: HammerInput) => {\n                    if (lastTouchAction) {\n                        this.carousel.dragEnd(event.deltaX);\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', lastTouchAction);\n                        lastTouchAction = null;\n                    }\n                });\n            });\n    }\n\n    private listenToResizeEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                filter((state: CarouselState) => state.config.shouldRecalculateOnResize),\n                switchMapTo(fromEvent(window, 'resize')),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe(() => {\n                this.carousel.recalculate();\n            });\n    }\n\n    private listenToKeyEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.keyboardListener = this.renderer.listen(\n            this.htmlElement,\n            'keydown',\n            (event: KeyboardEvent) => {\n                const key = event.key.toLowerCase();\n                if (['arrowright', 'right'].includes(key)) {\n                    this.carousel.next();\n                } else if (['arrowleft', 'left'].includes(key)) {\n                    this.carousel.prev();\n                }\n            }\n        );\n    }\n\n    /**\n     * Horizontal scroll might accidentaly happen on parent container\n     * when pressing arrow buttons too fast. We should return\n     * container to initial position when that happens.\n     */\n    private listenToScrollEvents(): void {\n        this.containerScrollListener = this.renderer.listen(this.htmlElement, 'scroll', () => {\n            this.htmlElement.scrollTo(0, 0);\n        });\n    }\n}\n","import { A11yModule } from '@angular/cdk/a11y';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselComponent } from './carousel.component';\nimport { PreventGhostClickDirective } from './prevent-ghost-click.directive';\nimport { FocusBlockDirective } from './private/directives/untabbable.directive';\nimport { CarouselEngineComponent } from './private/views/carousel-engine.component';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        A11yModule,\n    ],\n    declarations: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        CarouselEngineComponent,\n        FocusBlockDirective,\n        PreventGhostClickDirective,\n    ],\n    exports: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        PreventGhostClickDirective,\n    ],\n})\nexport class CarouselModule { }\n"]}