import { CarouselAlignMode } from '../../../../carousel-align-mode';
import { CarouselWidthMode } from '../../../../carousel-width-mode';
/**
 * Return new offset modified by last drag operations.
 * Applies overscroll behavior when necessary.
 *
 * @returns modified offset
 */
export function dragOffsetSnapshot(
/** X position in pixels from where drag event began */
fromX, 
/** destination X in pixels of last fired drag event */
toX, currentOffset, widthMode, alignMode, shouldLoop, viewportWidth, viewportWidthInPx, slideWidth, slideSumWidth, 
/** How much in percents user can overscroll unlooped carousel */
maxOverscrollPercent, bezierFn, invertedBezierFn) {
    if (fromX === toX) {
        return currentOffset;
    }
    // Normalize all pixel values to current width mode
    if (widthMode === CarouselWidthMode.PERCENT) {
        fromX = fromX * 100 / viewportWidthInPx;
        toX = toX * 100 / viewportWidthInPx;
    }
    let offsetDelta = toX - fromX;
    // 1st case: no bezier amendments, just return offset with applied delta
    if (shouldLoop) {
        return currentOffset + offsetDelta;
    }
    const overscrollStartPoint = detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn);
    // 2nd case where bezier correction haven't started yet,
    // meaning we're in safe zone at both side
    if (overscrollStartPoint === null) {
        const offsetFromSafeZone = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
        return offsetFromSafeZone;
    }
    // Seems like we already at overscroll zone, so let's see
    // the ways we could manage that
    /** Whether drag was performed from overscroll zone to same overscroll zone */
    const dragStaysInSameOverscrollZone = fromX > overscrollStartPoint
        ? toX > overscrollStartPoint
        : toX < overscrollStartPoint;
    // 3rd case: we should not amend when drag pointer is still in overscroll zone
    // after applying delta
    if (dragStaysInSameOverscrollZone) {
        const distanceBefore = fromX - overscrollStartPoint;
        const distanceAfter = toX - overscrollStartPoint;
        const distance = distanceBetween(distanceBefore, distanceAfter, viewportWidth, maxOverscrollPercent, bezierFn);
        currentOffset = currentOffset - distance;
        return currentOffset;
    }
    // 4th case where drag pointer has returned to safe zone.
    // We should do the same calculation like we did in 2nd case.
    const overscrollDistance = applyDeltaFromOverscrollZone(overscrollStartPoint - fromX, viewportWidth, maxOverscrollPercent, bezierFn);
    const distancetoSafeZone = overscrollStartPoint - fromX;
    currentOffset += overscrollDistance;
    fromX = overscrollStartPoint;
    offsetDelta -= distancetoSafeZone;
    const result = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
    return result;
}
/**
 * Applies bezier on distance and limit with max overscroll distance
 *
 * BE ADVICED, that all argument values should be converted to current width mode
 * beforehand.
 */
function applyDeltaFromOverscrollZone(distance, viewportWidth, maxOverscrollPercent, bezierFn) {
    /** Viewport % from 0 to 1 of delta distance */
    const deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));
    /** Maximal distance of overscroll in pixels */
    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
    /**
     * How much delta is actually long when applying bezier
     * and aligning overscroll max distance
     */
    const deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);
    return deltaDistance;
}
/**
 * Applies delta to current offset which is currently in safe zone at this moment.
 * Applies bezier whether delta intersects overscroll zone.
 *
 * BE ADVICED, that all argument values should be converted to current width mode
 * beforehand.
 */
function applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn) {
    const leftmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 - slideWidth / 2
        : 0;
    const rightmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 + slideWidth / 2
        : Math.min(viewportWidth, slideSumWidth);
    /** Whether left side of carousel is in viewport after applying delta */
    const leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;
    /** Whether right side of carousel is in viewport after applying delta */
    const rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;
    const canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)
        || (!rightSideExposedAfter && offsetDelta < 0);
    if (canSafelyTransit) {
        // We're still safe on both sides, just apply delta
        return currentOffset + offsetDelta;
    }
    /**
     * Distance between current offset and point
     * where overscroll begins
     */
    let distanceToSafeZone = 0;
    // Move offset to the point where overscroll begins
    if (leftSideExposedAfter) {
        distanceToSafeZone = currentOffset - leftmostPoint;
    }
    else if (rightSideExposedAfter) {
        distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;
    }
    /**
     * Distance between current offset and
     * overscroll zone starting point
     */
    const distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;
    currentOffset -= distanceToSafeZone;
    const overscrollDelta = applyDeltaFromOverscrollZone(distanceWithoutSafeZone, viewportWidth, maxOverscrollPercent, bezierFn);
    currentOffset += overscrollDelta;
    return currentOffset;
}
/**
 * Returns point where overscroll should potentially start
 * or null if carousel is currently in safe zone.
 */
function detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn) {
    const leftmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 - slideWidth / 2
        : 0;
    const rightmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 + slideWidth / 2
        : Math.min(leftmostPoint + slideSumWidth, viewportWidth);
    /** Distance from current offset to safe zone */
    let overscrollConvertedDistance = null;
    // Special case when left-aligned carousel is lesser than viewport width
    if (alignMode === CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {
        overscrollConvertedDistance = currentOffset;
    }
    else if (currentOffset > leftmostPoint) {
        overscrollConvertedDistance = currentOffset - leftmostPoint;
    }
    else if (currentOffset < rightmostPoint - slideSumWidth) {
        overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;
    }
    if (overscrollConvertedDistance === null) {
        return null;
    }
    const overscrollRealDistance = extractDeltaFromOverscrollZone(overscrollConvertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn);
    const overscrollStartPoint = fromX - overscrollRealDistance;
    return overscrollStartPoint;
}
/**
 * Converts distance with bezier applied to distance
 * without bezier
 */
function extractDeltaFromOverscrollZone(convertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn) {
    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
    const bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);
    const deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);
    return deltaPercentage;
}
/**
 * Calculates overscroll distance between two points
 */
function distanceBetween(firstPoint, secondPoint, viewportWidth, maxOverscrollPercent, bezierFn) {
    const overscrollBefore = applyDeltaFromOverscrollZone(firstPoint, viewportWidth, maxOverscrollPercent, bezierFn);
    const overscrollAfter = applyDeltaFromOverscrollZone(secondPoint, viewportWidth, maxOverscrollPercent, bezierFn);
    const distance = overscrollBefore - overscrollAfter;
    return distance;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1vZmZzZXQtc25hcHNob3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1jYXJvdXNlbC9zcmMvbGliL3ByaXZhdGUvc2VydmljZS9oZWxwZXJzL2RyYWctb2Zmc2V0L2RyYWctb2Zmc2V0LXNuYXBzaG90LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBRXBFOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQjtBQUM5Qix1REFBdUQ7QUFDdkQsS0FBYTtBQUNiLHVEQUF1RDtBQUN2RCxHQUFXLEVBQ1gsYUFBcUIsRUFDckIsU0FBNEIsRUFDNUIsU0FBNEIsRUFDNUIsVUFBbUIsRUFDbkIsYUFBcUIsRUFDckIsaUJBQXlCLEVBQ3pCLFVBQWtCLEVBQ2xCLGFBQXFCO0FBQ3JCLGlFQUFpRTtBQUNqRSxvQkFBNEIsRUFDNUIsUUFBd0IsRUFDeEIsZ0JBQWdDO0lBRWhDLElBQUksS0FBSyxLQUFLLEdBQUcsRUFBRTtRQUVmLE9BQU8sYUFBYSxDQUFDO0tBQ3hCO0lBRUQsbURBQW1EO0lBQ25ELElBQUksU0FBUyxLQUFLLGlCQUFpQixDQUFDLE9BQU8sRUFBRTtRQUN6QyxLQUFLLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxpQkFBaUIsQ0FBQztRQUN4QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxpQkFBaUIsQ0FBQztLQUN2QztJQUVELElBQUksV0FBVyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7SUFFOUIsd0VBQXdFO0lBQ3hFLElBQUksVUFBVSxFQUFFO1FBRVosT0FBTyxhQUFhLEdBQUcsV0FBVyxDQUFDO0tBQ3RDO0lBRUQsTUFBTSxvQkFBb0IsR0FBRywwQkFBMEIsQ0FDbkQsS0FBSyxFQUNM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LEVBQzNCLGFBQWEsRUFDYixvQkFBb0IsRUFDcEIsZ0JBQWdCLENBQ25CLENBQUM7SUFDRixNQUFNLG9CQUFvQixHQUFHLEtBQUssR0FBRyxzQkFBc0IsQ0FBQztJQUU1RCxPQUFPLG9CQUFvQixDQUFDO0FBQ2hDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLDhCQUE4QixDQUNuQyxpQkFBeUIsRUFDekIsYUFBcUIsRUFDckIsb0JBQTRCLEVBQzVCLGdCQUE2QztJQUU3QyxNQUFNLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxvQkFBb0IsR0FBRyxHQUFHLENBQUM7SUFDekUsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3hFLE1BQU0sZUFBZSxHQUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxHQUFHLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFckcsT0FBTyxlQUFlLENBQUM7QUFDM0IsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxlQUFlLENBQ3BCLFVBQWtCLEVBQ2xCLFdBQW1CLEVBQ25CLGFBQXFCLEVBQ3JCLG9CQUE0QixFQUM1QixRQUFxQztJQUVyQyxNQUFNLGdCQUFnQixHQUFHLDRCQUE0QixDQUNqRCxVQUFVLEVBQ1YsYUFBYSxFQUNiLG9CQUFvQixFQUNwQixRQUFRLENBQ1gsQ0FBQztJQUNGLE1BQU0sZUFBZSxHQUFHLDRCQUE0QixDQUNoRCxXQUFXLEVBQ1gsYUFBYSxFQUNiLG9CQUFvQixFQUNwQixRQUFRLENBQ1gsQ0FBQztJQUNGLE1BQU0sUUFBUSxHQUFHLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztJQUVwRCxPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBFYXNpbmdGdW5jdGlvbiB9IGZyb20gJ2Jlemllci1lYXNpbmcnO1xuXG5pbXBvcnQgeyBDYXJvdXNlbEFsaWduTW9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL2Nhcm91c2VsLWFsaWduLW1vZGUnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxXaWR0aE1vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9jYXJvdXNlbC13aWR0aC1tb2RlJztcblxuLyoqXG4gKiBSZXR1cm4gbmV3IG9mZnNldCBtb2RpZmllZCBieSBsYXN0IGRyYWcgb3BlcmF0aW9ucy5cbiAqIEFwcGxpZXMgb3ZlcnNjcm9sbCBiZWhhdmlvciB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcmV0dXJucyBtb2RpZmllZCBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYWdPZmZzZXRTbmFwc2hvdChcbiAgICAvKiogWCBwb3NpdGlvbiBpbiBwaXhlbHMgZnJvbSB3aGVyZSBkcmFnIGV2ZW50IGJlZ2FuICovXG4gICAgZnJvbVg6IG51bWJlcixcbiAgICAvKiogZGVzdGluYXRpb24gWCBpbiBwaXhlbHMgb2YgbGFzdCBmaXJlZCBkcmFnIGV2ZW50ICovXG4gICAgdG9YOiBudW1iZXIsXG4gICAgY3VycmVudE9mZnNldDogbnVtYmVyLFxuICAgIHdpZHRoTW9kZTogQ2Fyb3VzZWxXaWR0aE1vZGUsXG4gICAgYWxpZ25Nb2RlOiBDYXJvdXNlbEFsaWduTW9kZSxcbiAgICBzaG91bGRMb29wOiBib29sZWFuLFxuICAgIHZpZXdwb3J0V2lkdGg6IG51bWJlcixcbiAgICB2aWV3cG9ydFdpZHRoSW5QeDogbnVtYmVyLFxuICAgIHNsaWRlV2lkdGg6IG51bWJlcixcbiAgICBzbGlkZVN1bVdpZHRoOiBudW1iZXIsXG4gICAgLyoqIEhvdyBtdWNoIGluIHBlcmNlbnRzIHVzZXIgY2FuIG92ZXJzY3JvbGwgdW5sb29wZWQgY2Fyb3VzZWwgKi9cbiAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudDogbnVtYmVyLFxuICAgIGJlemllckZuOiBFYXNpbmdGdW5jdGlvbixcbiAgICBpbnZlcnRlZEJlemllckZuOiBFYXNpbmdGdW5jdGlvbixcbik6IG51bWJlciB7XG4gICAgaWYgKGZyb21YID09PSB0b1gpIHtcblxuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgYWxsIHBpeGVsIHZhbHVlcyB0byBjdXJyZW50IHdpZHRoIG1vZGVcbiAgICBpZiAod2lkdGhNb2RlID09PSBDYXJvdXNlbFdpZHRoTW9kZS5QRVJDRU5UKSB7XG4gICAgICAgIGZyb21YID0gZnJvbVggKiAxMDAgLyB2aWV3cG9ydFdpZHRoSW5QeDtcbiAgICAgICAgdG9YID0gdG9YICogMTAwIC8gdmlld3BvcnRXaWR0aEluUHg7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldERlbHRhID0gdG9YIC0gZnJvbVg7XG5cbiAgICAvLyAxc3QgY2FzZTogbm8gYmV6aWVyIGFtZW5kbWVudHMsIGp1c3QgcmV0dXJuIG9mZnNldCB3aXRoIGFwcGxpZWQgZGVsdGFcbiAgICBpZiAoc2hvdWxkTG9vcCkge1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50T2Zmc2V0ICsgb2Zmc2V0RGVsdGE7XG4gICAgfVxuXG4gICAgY29uc3Qgb3ZlcnNjcm9sbFN0YXJ0UG9pbnQgPSBkZXRlY3RPdmVyc2Nyb2xsU3RhcnRQb2ludChcbiAgICAgICAgZnJvbVgsXG4gICAgICAgIGN1cnJlbnRPZmZzZXQsXG4gICAgICAgIHZpZXdwb3J0V2lkdGgsXG4gICAgICAgIHNsaWRlV2lkdGgsXG4gICAgICAgIHNsaWRlU3VtV2lkdGgsXG4gICAgICAgIGFsaWduTW9kZSxcbiAgICAgICAgbWF4T3ZlcnNjcm9sbFBlcmNlbnQsXG4gICAgICAgIGludmVydGVkQmV6aWVyRm4sXG4gICAgKTtcblxuICAgIC8vIDJuZCBjYXNlIHdoZXJlIGJlemllciBjb3JyZWN0aW9uIGhhdmVuJ3Qgc3RhcnRlZCB5ZXQsXG4gICAgLy8gbWVhbmluZyB3ZSdyZSBpbiBzYWZlIHpvbmUgYXQgYm90aCBzaWRlXG4gICAgaWYgKG92ZXJzY3JvbGxTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEZyb21TYWZlWm9uZSA9IGFwcGx5RGVsdGFGcm9tU2FmZVpvbmUoXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0LFxuICAgICAgICAgICAgb2Zmc2V0RGVsdGEsXG4gICAgICAgICAgICBhbGlnbk1vZGUsXG4gICAgICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICAgICAgc2xpZGVXaWR0aCxcbiAgICAgICAgICAgIHNsaWRlU3VtV2lkdGgsXG4gICAgICAgICAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudCxcbiAgICAgICAgICAgIGJlemllckZuLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXRGcm9tU2FmZVpvbmU7XG4gICAgfVxuXG4gICAgLy8gU2VlbXMgbGlrZSB3ZSBhbHJlYWR5IGF0IG92ZXJzY3JvbGwgem9uZSwgc28gbGV0J3Mgc2VlXG4gICAgLy8gdGhlIHdheXMgd2UgY291bGQgbWFuYWdlIHRoYXRcblxuICAgIC8qKiBXaGV0aGVyIGRyYWcgd2FzIHBlcmZvcm1lZCBmcm9tIG92ZXJzY3JvbGwgem9uZSB0byBzYW1lIG92ZXJzY3JvbGwgem9uZSAqL1xuICAgIGNvbnN0IGRyYWdTdGF5c0luU2FtZU92ZXJzY3JvbGxab25lID0gZnJvbVggPiBvdmVyc2Nyb2xsU3RhcnRQb2ludFxuICAgICAgICA/IHRvWCA+IG92ZXJzY3JvbGxTdGFydFBvaW50XG4gICAgICAgIDogdG9YIDwgb3ZlcnNjcm9sbFN0YXJ0UG9pbnQ7XG5cbiAgICAvLyAzcmQgY2FzZTogd2Ugc2hvdWxkIG5vdCBhbWVuZCB3aGVuIGRyYWcgcG9pbnRlciBpcyBzdGlsbCBpbiBvdmVyc2Nyb2xsIHpvbmVcbiAgICAvLyBhZnRlciBhcHBseWluZyBkZWx0YVxuICAgIGlmIChkcmFnU3RheXNJblNhbWVPdmVyc2Nyb2xsWm9uZSkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZUJlZm9yZSA9IGZyb21YIC0gb3ZlcnNjcm9sbFN0YXJ0UG9pbnQ7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlQWZ0ZXIgPSB0b1ggLSBvdmVyc2Nyb2xsU3RhcnRQb2ludDtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZUJldHdlZW4oXG4gICAgICAgICAgICBkaXN0YW5jZUJlZm9yZSxcbiAgICAgICAgICAgIGRpc3RhbmNlQWZ0ZXIsXG4gICAgICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICAgICAgbWF4T3ZlcnNjcm9sbFBlcmNlbnQsXG4gICAgICAgICAgICBiZXppZXJGbixcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudE9mZnNldCA9IGN1cnJlbnRPZmZzZXQgLSBkaXN0YW5jZTtcblxuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICB9XG5cbiAgICAvLyA0dGggY2FzZSB3aGVyZSBkcmFnIHBvaW50ZXIgaGFzIHJldHVybmVkIHRvIHNhZmUgem9uZS5cbiAgICAvLyBXZSBzaG91bGQgZG8gdGhlIHNhbWUgY2FsY3VsYXRpb24gbGlrZSB3ZSBkaWQgaW4gMm5kIGNhc2UuXG4gICAgY29uc3Qgb3ZlcnNjcm9sbERpc3RhbmNlID0gYXBwbHlEZWx0YUZyb21PdmVyc2Nyb2xsWm9uZShcbiAgICAgICAgb3ZlcnNjcm9sbFN0YXJ0UG9pbnQgLSBmcm9tWCxcbiAgICAgICAgdmlld3BvcnRXaWR0aCxcbiAgICAgICAgbWF4T3ZlcnNjcm9sbFBlcmNlbnQsXG4gICAgICAgIGJlemllckZuLFxuICAgICk7XG4gICAgY29uc3QgZGlzdGFuY2V0b1NhZmVab25lID0gb3ZlcnNjcm9sbFN0YXJ0UG9pbnQgLSBmcm9tWDtcbiAgICBjdXJyZW50T2Zmc2V0ICs9IG92ZXJzY3JvbGxEaXN0YW5jZTtcbiAgICBmcm9tWCA9IG92ZXJzY3JvbGxTdGFydFBvaW50O1xuICAgIG9mZnNldERlbHRhIC09IGRpc3RhbmNldG9TYWZlWm9uZTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5RGVsdGFGcm9tU2FmZVpvbmUoXG4gICAgICAgIGN1cnJlbnRPZmZzZXQsXG4gICAgICAgIG9mZnNldERlbHRhLFxuICAgICAgICBhbGlnbk1vZGUsXG4gICAgICAgIHZpZXdwb3J0V2lkdGgsXG4gICAgICAgIHNsaWRlV2lkdGgsXG4gICAgICAgIHNsaWRlU3VtV2lkdGgsXG4gICAgICAgIG1heE92ZXJzY3JvbGxQZXJjZW50LFxuICAgICAgICBiZXppZXJGbixcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIGJlemllciBvbiBkaXN0YW5jZSBhbmQgbGltaXQgd2l0aCBtYXggb3ZlcnNjcm9sbCBkaXN0YW5jZVxuICpcbiAqIEJFIEFEVklDRUQsIHRoYXQgYWxsIGFyZ3VtZW50IHZhbHVlcyBzaG91bGQgYmUgY29udmVydGVkIHRvIGN1cnJlbnQgd2lkdGggbW9kZVxuICogYmVmb3JlaGFuZC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWx0YUZyb21PdmVyc2Nyb2xsWm9uZShcbiAgICBkaXN0YW5jZTogbnVtYmVyLFxuICAgIHZpZXdwb3J0V2lkdGg6IG51bWJlcixcbiAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudDogbnVtYmVyLFxuICAgIGJlemllckZuOiBCZXppZXJFYXNpbmcuRWFzaW5nRnVuY3Rpb24sXG4pOiBudW1iZXIge1xuICAgIC8qKiBWaWV3cG9ydCAlIGZyb20gMCB0byAxIG9mIGRlbHRhIGRpc3RhbmNlICovXG4gICAgY29uc3QgZGVsdGFQZXJjZW50YWdlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oTWF0aC5hYnMoZGlzdGFuY2UpIC8gdmlld3BvcnRXaWR0aCwgMSkpO1xuICAgIC8qKiBNYXhpbWFsIGRpc3RhbmNlIG9mIG92ZXJzY3JvbGwgaW4gcGl4ZWxzICovXG4gICAgY29uc3QgbWF4T3ZlcnNjcm9sbERpc3RhbmNlID0gdmlld3BvcnRXaWR0aCAqIG1heE92ZXJzY3JvbGxQZXJjZW50IC8gMTAwO1xuICAgIC8qKlxuICAgICAqIEhvdyBtdWNoIGRlbHRhIGlzIGFjdHVhbGx5IGxvbmcgd2hlbiBhcHBseWluZyBiZXppZXJcbiAgICAgKiBhbmQgYWxpZ25pbmcgb3ZlcnNjcm9sbCBtYXggZGlzdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdCBkZWx0YURpc3RhbmNlID0gbWF4T3ZlcnNjcm9sbERpc3RhbmNlICogYmV6aWVyRm4oZGVsdGFQZXJjZW50YWdlKSAqIE1hdGguc2lnbihkaXN0YW5jZSk7XG5cbiAgICByZXR1cm4gZGVsdGFEaXN0YW5jZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIGRlbHRhIHRvIGN1cnJlbnQgb2Zmc2V0IHdoaWNoIGlzIGN1cnJlbnRseSBpbiBzYWZlIHpvbmUgYXQgdGhpcyBtb21lbnQuXG4gKiBBcHBsaWVzIGJlemllciB3aGV0aGVyIGRlbHRhIGludGVyc2VjdHMgb3ZlcnNjcm9sbCB6b25lLlxuICpcbiAqIEJFIEFEVklDRUQsIHRoYXQgYWxsIGFyZ3VtZW50IHZhbHVlcyBzaG91bGQgYmUgY29udmVydGVkIHRvIGN1cnJlbnQgd2lkdGggbW9kZVxuICogYmVmb3JlaGFuZC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWx0YUZyb21TYWZlWm9uZShcbiAgICBjdXJyZW50T2Zmc2V0OiBudW1iZXIsXG4gICAgb2Zmc2V0RGVsdGE6IG51bWJlcixcbiAgICBhbGlnbk1vZGU6IENhcm91c2VsQWxpZ25Nb2RlLFxuICAgIHZpZXdwb3J0V2lkdGg6IG51bWJlcixcbiAgICBzbGlkZVdpZHRoOiBudW1iZXIsXG4gICAgc2xpZGVTdW1XaWR0aDogbnVtYmVyLFxuICAgIG1heE92ZXJzY3JvbGxQZXJjZW50OiBudW1iZXIsXG4gICAgYmV6aWVyRm46IEJlemllckVhc2luZy5FYXNpbmdGdW5jdGlvbixcbik6IG51bWJlciB7XG4gICAgY29uc3QgbGVmdG1vc3RQb2ludCA9IGFsaWduTW9kZSA9PT0gQ2Fyb3VzZWxBbGlnbk1vZGUuQ0VOVEVSXG4gICAgICAgID8gdmlld3BvcnRXaWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMlxuICAgICAgICA6IDA7XG4gICAgY29uc3QgcmlnaHRtb3N0UG9pbnQgPSBhbGlnbk1vZGUgPT09IENhcm91c2VsQWxpZ25Nb2RlLkNFTlRFUlxuICAgICAgICA/IHZpZXdwb3J0V2lkdGggLyAyICsgc2xpZGVXaWR0aCAvIDJcbiAgICAgICAgOiBNYXRoLm1pbih2aWV3cG9ydFdpZHRoLCBzbGlkZVN1bVdpZHRoKTtcbiAgICAvKiogV2hldGhlciBsZWZ0IHNpZGUgb2YgY2Fyb3VzZWwgaXMgaW4gdmlld3BvcnQgYWZ0ZXIgYXBwbHlpbmcgZGVsdGEgKi9cbiAgICBjb25zdCBsZWZ0U2lkZUV4cG9zZWRBZnRlciA9IGN1cnJlbnRPZmZzZXQgKyBvZmZzZXREZWx0YSA+IGxlZnRtb3N0UG9pbnQ7XG4gICAgLyoqIFdoZXRoZXIgcmlnaHQgc2lkZSBvZiBjYXJvdXNlbCBpcyBpbiB2aWV3cG9ydCBhZnRlciBhcHBseWluZyBkZWx0YSAqL1xuICAgIGNvbnN0IHJpZ2h0U2lkZUV4cG9zZWRBZnRlciA9IGN1cnJlbnRPZmZzZXQgKyBzbGlkZVN1bVdpZHRoICsgb2Zmc2V0RGVsdGEgPCByaWdodG1vc3RQb2ludDtcblxuICAgIGNvbnN0IGNhblNhZmVseVRyYW5zaXQgPSAoIWxlZnRTaWRlRXhwb3NlZEFmdGVyICYmIG9mZnNldERlbHRhID4gMClcbiAgICAgICAgfHwgKCFyaWdodFNpZGVFeHBvc2VkQWZ0ZXIgJiYgb2Zmc2V0RGVsdGEgPCAwKTtcblxuICAgIGlmIChjYW5TYWZlbHlUcmFuc2l0KSB7XG4gICAgICAgIC8vIFdlJ3JlIHN0aWxsIHNhZmUgb24gYm90aCBzaWRlcywganVzdCBhcHBseSBkZWx0YVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50T2Zmc2V0ICsgb2Zmc2V0RGVsdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG9mZnNldCBhbmQgcG9pbnRcbiAgICAgKiB3aGVyZSBvdmVyc2Nyb2xsIGJlZ2luc1xuICAgICAqL1xuICAgIGxldCBkaXN0YW5jZVRvU2FmZVpvbmUgPSAwO1xuICAgIC8vIE1vdmUgb2Zmc2V0IHRvIHRoZSBwb2ludCB3aGVyZSBvdmVyc2Nyb2xsIGJlZ2luc1xuICAgIGlmIChsZWZ0U2lkZUV4cG9zZWRBZnRlcikge1xuICAgICAgICBkaXN0YW5jZVRvU2FmZVpvbmUgPSBjdXJyZW50T2Zmc2V0IC0gbGVmdG1vc3RQb2ludDtcbiAgICB9IGVsc2UgaWYgKHJpZ2h0U2lkZUV4cG9zZWRBZnRlcikge1xuICAgICAgICBkaXN0YW5jZVRvU2FmZVpvbmUgPSBjdXJyZW50T2Zmc2V0ICsgc2xpZGVTdW1XaWR0aCAtIHJpZ2h0bW9zdFBvaW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIGJldHdlZW4gY3VycmVudCBvZmZzZXQgYW5kXG4gICAgICogb3ZlcnNjcm9sbCB6b25lIHN0YXJ0aW5nIHBvaW50XG4gICAgICovXG4gICAgY29uc3QgZGlzdGFuY2VXaXRob3V0U2FmZVpvbmUgPSBvZmZzZXREZWx0YSArIGRpc3RhbmNlVG9TYWZlWm9uZTtcbiAgICBjdXJyZW50T2Zmc2V0IC09IGRpc3RhbmNlVG9TYWZlWm9uZTtcblxuICAgIGNvbnN0IG92ZXJzY3JvbGxEZWx0YSA9IGFwcGx5RGVsdGFGcm9tT3ZlcnNjcm9sbFpvbmUoXG4gICAgICAgIGRpc3RhbmNlV2l0aG91dFNhZmVab25lLFxuICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudCxcbiAgICAgICAgYmV6aWVyRm4sXG4gICAgKTtcbiAgICBjdXJyZW50T2Zmc2V0ICs9IG92ZXJzY3JvbGxEZWx0YTtcblxuICAgIHJldHVybiBjdXJyZW50T2Zmc2V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgcG9pbnQgd2hlcmUgb3ZlcnNjcm9sbCBzaG91bGQgcG90ZW50aWFsbHkgc3RhcnRcbiAqIG9yIG51bGwgaWYgY2Fyb3VzZWwgaXMgY3VycmVudGx5IGluIHNhZmUgem9uZS5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0T3ZlcnNjcm9sbFN0YXJ0UG9pbnQoXG4gICAgZnJvbVg6IG51bWJlcixcbiAgICBjdXJyZW50T2Zmc2V0OiBudW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyLFxuICAgIHNsaWRlV2lkdGg6IG51bWJlcixcbiAgICBzbGlkZVN1bVdpZHRoOiBudW1iZXIsXG4gICAgYWxpZ25Nb2RlOiBDYXJvdXNlbEFsaWduTW9kZSxcbiAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudDogbnVtYmVyLFxuICAgIGludmVydGVkQmV6aWVyRm46IEJlemllckVhc2luZy5FYXNpbmdGdW5jdGlvbixcbik6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IGxlZnRtb3N0UG9pbnQgPSBhbGlnbk1vZGUgPT09IENhcm91c2VsQWxpZ25Nb2RlLkNFTlRFUlxuICAgICAgICA/IHZpZXdwb3J0V2lkdGggLyAyIC0gc2xpZGVXaWR0aCAvIDJcbiAgICAgICAgOiAwO1xuICAgIGNvbnN0IHJpZ2h0bW9zdFBvaW50ID0gYWxpZ25Nb2RlID09PSBDYXJvdXNlbEFsaWduTW9kZS5DRU5URVJcbiAgICAgICAgPyB2aWV3cG9ydFdpZHRoIC8gMiArIHNsaWRlV2lkdGggLyAyXG4gICAgICAgIDogTWF0aC5taW4obGVmdG1vc3RQb2ludCArIHNsaWRlU3VtV2lkdGgsIHZpZXdwb3J0V2lkdGgpO1xuXG4gICAgLyoqIERpc3RhbmNlIGZyb20gY3VycmVudCBvZmZzZXQgdG8gc2FmZSB6b25lICovXG4gICAgbGV0IG92ZXJzY3JvbGxDb252ZXJ0ZWREaXN0YW5jZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gbGVmdC1hbGlnbmVkIGNhcm91c2VsIGlzIGxlc3NlciB0aGFuIHZpZXdwb3J0IHdpZHRoXG4gICAgaWYgKGFsaWduTW9kZSA9PT0gQ2Fyb3VzZWxBbGlnbk1vZGUuTEVGVCAmJiBzbGlkZVN1bVdpZHRoIDwgdmlld3BvcnRXaWR0aCAmJiBjdXJyZW50T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIG92ZXJzY3JvbGxDb252ZXJ0ZWREaXN0YW5jZSA9IGN1cnJlbnRPZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0ID4gbGVmdG1vc3RQb2ludCkge1xuICAgICAgICBvdmVyc2Nyb2xsQ29udmVydGVkRGlzdGFuY2UgPSBjdXJyZW50T2Zmc2V0IC0gbGVmdG1vc3RQb2ludDtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRPZmZzZXQgPCByaWdodG1vc3RQb2ludCAtIHNsaWRlU3VtV2lkdGgpIHtcbiAgICAgICAgb3ZlcnNjcm9sbENvbnZlcnRlZERpc3RhbmNlID0gY3VycmVudE9mZnNldCAtIHJpZ2h0bW9zdFBvaW50ICsgc2xpZGVTdW1XaWR0aDtcbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxDb252ZXJ0ZWREaXN0YW5jZSA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvdmVyc2Nyb2xsUmVhbERpc3RhbmNlID0gZXh0cmFjdERlbHRhRnJvbU92ZXJzY3JvbGxab25lKFxuICAgICAgICBvdmVyc2Nyb2xsQ29udmVydGVkRGlzdGFuY2UsXG4gICAgICAgIHZpZXdwb3J0V2lkdGgsXG4gICAgICAgIG1heE92ZXJzY3JvbGxQZXJjZW50LFxuICAgICAgICBpbnZlcnRlZEJlemllckZuLFxuICAgICk7XG4gICAgY29uc3Qgb3ZlcnNjcm9sbFN0YXJ0UG9pbnQgPSBmcm9tWCAtIG92ZXJzY3JvbGxSZWFsRGlzdGFuY2U7XG5cbiAgICByZXR1cm4gb3ZlcnNjcm9sbFN0YXJ0UG9pbnQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgZGlzdGFuY2Ugd2l0aCBiZXppZXIgYXBwbGllZCB0byBkaXN0YW5jZVxuICogd2l0aG91dCBiZXppZXJcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdERlbHRhRnJvbU92ZXJzY3JvbGxab25lKFxuICAgIGNvbnZlcnRlZERpc3RhbmNlOiBudW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyLFxuICAgIG1heE92ZXJzY3JvbGxQZXJjZW50OiBudW1iZXIsXG4gICAgaW52ZXJ0ZWRCZXppZXJGbjogQmV6aWVyRWFzaW5nLkVhc2luZ0Z1bmN0aW9uLFxuKTogbnVtYmVyIHtcbiAgICBjb25zdCBtYXhPdmVyc2Nyb2xsRGlzdGFuY2UgPSB2aWV3cG9ydFdpZHRoICogbWF4T3ZlcnNjcm9sbFBlcmNlbnQgLyAxMDA7XG4gICAgY29uc3QgYmV6aWVyVmFsdWUgPSBNYXRoLmFicyhjb252ZXJ0ZWREaXN0YW5jZSAvIG1heE92ZXJzY3JvbGxEaXN0YW5jZSk7XG4gICAgY29uc3QgZGVsdGFQZXJjZW50YWdlID0gaW52ZXJ0ZWRCZXppZXJGbihiZXppZXJWYWx1ZSkgKiB2aWV3cG9ydFdpZHRoICogTWF0aC5zaWduKGNvbnZlcnRlZERpc3RhbmNlKTtcblxuICAgIHJldHVybiBkZWx0YVBlcmNlbnRhZ2U7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBvdmVyc2Nyb2xsIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW4oXG4gICAgZmlyc3RQb2ludDogbnVtYmVyLFxuICAgIHNlY29uZFBvaW50OiBudW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyLFxuICAgIG1heE92ZXJzY3JvbGxQZXJjZW50OiBudW1iZXIsXG4gICAgYmV6aWVyRm46IEJlemllckVhc2luZy5FYXNpbmdGdW5jdGlvbixcbik6IG51bWJlciB7XG4gICAgY29uc3Qgb3ZlcnNjcm9sbEJlZm9yZSA9IGFwcGx5RGVsdGFGcm9tT3ZlcnNjcm9sbFpvbmUoXG4gICAgICAgIGZpcnN0UG9pbnQsXG4gICAgICAgIHZpZXdwb3J0V2lkdGgsXG4gICAgICAgIG1heE92ZXJzY3JvbGxQZXJjZW50LFxuICAgICAgICBiZXppZXJGbixcbiAgICApO1xuICAgIGNvbnN0IG92ZXJzY3JvbGxBZnRlciA9IGFwcGx5RGVsdGFGcm9tT3ZlcnNjcm9sbFpvbmUoXG4gICAgICAgIHNlY29uZFBvaW50LFxuICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICBtYXhPdmVyc2Nyb2xsUGVyY2VudCxcbiAgICAgICAgYmV6aWVyRm4sXG4gICAgKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IG92ZXJzY3JvbGxCZWZvcmUgLSBvdmVyc2Nyb2xsQWZ0ZXI7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG4iXX0=