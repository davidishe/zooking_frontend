import { CarouselSlide } from '../../../models/carousel-slide';
import { IdGenerator } from '../../../models/id-generator';
import { CopySlidesResult } from './models/copy-slides-result';
import { ShuffleSlidesResult } from './models/shuffle-slides-result';
/**
 * Justifies existing slides in viewport by either
 * - Move slide from one side to another
 * - Copy slide from one side to another
 * - Create slide on one side
 *
 * Task of this function is to leave no empty spaces in viewport.
 *
 * **BE ADVICED**, that inViewport flag should be calculated for each slide
 * that should not be moved beforehand.
 */
export function shuffleSlides(slides, offset, slideWidth, viewportWidth, items, shouldLoop, threshold = 0, idGenerator = new IdGenerator()) {
    if (!slides || !slides.length) {
        return new ShuffleSlidesResult([], offset);
    }
    if (slideWidth <= 0 || !shouldLoop) {
        return new ShuffleSlidesResult(slides, offset);
    }
    const slideSumWidth = slides.length * slideWidth;
    // Calculate missing slides for left and right sides
    const leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));
    const rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));
    // Let's start to fill missing slides
    /**
     * Item indexes that should be marked as copies after
     * function completes
     */
    let unmarkedItemIndexes = [];
    // Should move slides to right side
    if (rightSideMissingSlides) {
        const rightSideMoveResult = moveOrCopySlidesToEnd(slides, offset, rightSideMissingSlides, slideWidth, items, idGenerator);
        slides = rightSideMoveResult.slides;
        offset = rightSideMoveResult.modifiedOffset;
        unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;
    }
    // Should move slides to left side
    if (leftSideMissingSlides) {
        const leftSideMoveResult = moveOrCopySlidesToStart(slides, offset, leftSideMissingSlides, slideWidth, items, idGenerator);
        slides = leftSideMoveResult.slides;
        offset = leftSideMoveResult.modifiedOffset;
        unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);
    }
    const result = new ShuffleSlidesResult(slides, offset);
    return result;
}
/**
 * Moves, copies or creates slides to the right side in order to fill
 * desired `quantity`.
 *
 * Quantity means of how much new slides will be added.
 * There are two options of how we could fill missing slides.
 * Imagine next slides row mapped to their item index:
 * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.
 * We can't just start to move/copy slides from the right part,
 * because we can't break sequence (meaning if we'll copy slide `5`
 * on the right to slide `3` on the left, they won't stack).
 * Slide `3` on the left awaits slide with item index `2` to be put
 * near him, so we should create some slides in between. This action
 * is named `Option FILL GAP`.
 *
 * `Option FILL GAP`:
 * How much slides are in between item index `5` and item index `3`?
 * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides
 * and subtract their length from `quantity`.
 * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
 * equals 1. Now we can start copy/move slides from the right part.
 * This action is called `Option COPY`
 *
 * `Option COPY`:
 * When meddling with slides from the other side, we have two options
 * of what to do with them: either copy or move. Slide can be moved
 * when it is not `inViewport`, meaning it has corresponding option
 * flag. Otherwise it should be copied.
 * In our example we should move one slide from the right part, since
 * `quantity` after `Option FILL` equals 1. Lets imagine that slide
 * wasn't in viewport and now our slide row has
 * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!
 */
export function moveOrCopySlidesToEnd(slides, offset, quantity, slideWidth, items, idGenerator = new IdGenerator()) {
    if (quantity < 1) {
        return new CopySlidesResult(slides, offset, []);
    }
    const newSlides = [];
    /** Item indexes that should be marked as copies later */
    const unmarkedItemIndexes = [];
    /** Used as argument for splice call later */
    let spliceQuantity = 0;
    /**
     * We can't increase quantity if we encountered slide
     * with inViewport flag
     */
    let canIncreaseQuantity = true;
    /**
     * Iterator index, used in COPY option. Determines which
     * slide should be picked from left side for analyzing.
     */
    let slideIndex = 0;
    /**
     * Once we finished with option FILL GAP, then
     * copy option should take place
     */
    let shouldCopy = false;
    // We going to iterate through item indexes starting from
    // last slide item index. Let's pick an item index
    // to start from.
    const lastSlide = slides[slides.length - 1];
    const lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;
    /**
     * Iterator index, used in FILL GAP and COPY options.
     * This index determines which item will next slide have.
     */
    let nextItemId = lastSlideHasLastItemIndex
        ? 0
        : lastSlide.itemIndex + 1;
    for (let i = 0; i < quantity; i++) {
        /**
         * Having this field as true means slides from left and right
         * side (including new slides) can stack and we can proceed to
         * COPY option
         */
        const firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;
        if (shouldCopy || firstSlideHasNextItemId) {
            // Option COPY
            shouldCopy = true;
            const currentSlide = slides[slideIndex];
            // Create new slide procedure
            const newOptions = Object.assign({}, currentSlide.options);
            // There should be an already existing isActive slide,
            // so we turning isActive off for copy
            newOptions.isActive = false;
            // Every filled item is considered to be in viewport,
            // because why else would we call this function
            // otherwise? To fill viewport obviously.
            newOptions.inViewport = true;
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
            newSlides.push(newSlide);
            // Splice arguments processing
            if (currentSlide.options.inViewport) {
                canIncreaseQuantity = false;
            }
            // We can't increase quantity if we have reached end of slides.
            // It happens when quantity from argument is higher than
            // slides size.
            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
            if (canIncreaseQuantity && canIncrementSpliceQuantity) {
                spliceQuantity++;
            }
            // Prepare slide to process
            slideIndex++;
            if (slideIndex >= slides.length) {
                slideIndex = 0;
            }
        }
        else {
            // Option FILL GAP
            // Create new slide procedure
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                inViewport: true,
                item: items[nextItemId],
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                isActive: false,
            });
            newSlides.push(newSlide);
            unmarkedItemIndexes.push(nextItemId);
        }
        // Pick index for next item
        nextItemId++;
        if (nextItemId >= items.length) {
            nextItemId = 0;
        }
    }
    if (spliceQuantity > 0) {
        slides.splice(0, spliceQuantity);
    }
    const resultSlides = [
        ...slides,
        ...newSlides
    ];
    const resultOffset = offset + spliceQuantity * slideWidth;
    return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);
}
/**
 * Moves, copies or creates slides to the left side in order to fill
 * desired `quantity`.
 *
 * Quantity means of how much new slides will be added.
 * There are two options of how we could fill missing slides.
 * Imagine next slides row mapped to their item index:
 * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.
 * We can't just start to move/copy slides from the left part,
 * because we can't break sequence (meaning if we'll copy slide `0`
 * on the right to slide `3` on the right, they won't stack).
 * Slide `3` on the right side awaits slide with item index `2` to be
 * put near him, so we should create some slides in between. This
 * action is named `Option FILL GAP`.
 *
 * `Option FILL GAP`:
 * How much slides are in between item index `0` and item index `3`?
 * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides
 * and subtract their length from `quantity`.
 * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
 * equals 2. Now we can start copy/move slides from the left part.
 * This action is called `Option COPY`
 *
 * `Option COPY`:
 * When meddling with slides from the other side, we have two options
 * of what to do with them: either copy or move. Slide can be moved
 * when it is not `inViewport`, meaning it has corresponding option
 * flag. Otherwise it should be copied.
 * In our example we should move two slides from the left part, since
 * `quantity` after `Option FILL` equals 2. Lets imagine that slides
 * weren't in viewport and now our row has
 * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!
 */
export function moveOrCopySlidesToStart(slides, offset, quantity, slideWidth, items, idGenerator = new IdGenerator()) {
    if (quantity < 1) {
        return new CopySlidesResult(slides, offset, []);
    }
    const newSlides = [];
    /** Item indexes that should be marked as copies later */
    const unmarkedItemIndexes = [];
    /** Used as argument for splice call later */
    let spliceFrom = null;
    /** Used as argument for splice call later */
    let spliceQuantity = 0;
    /**
     * Once we finished with option FILL GAP, then
     * copy option should take place
     */
    let shouldCopy = false;
    /**
     * Iterator index, used in COPY option. Determines which
     * slide should be picked from right side for analyzing.
     */
    let slideIndex = slides.length - 1;
    // We going to iterate through item indexes starting from
    // first slide item index. Let's pick an item index
    // to start from.
    const firstSlide = slides[0];
    const firstSlideHasFirstItemId = firstSlide.itemIndex === 0;
    /**
     * Iterator index, used in FILL GAP and COPY options.
     * This index determines which item will next slide have.
     */
    let nextItemId = firstSlideHasFirstItemId
        ? items.length - 1
        : firstSlide.itemIndex - 1;
    for (let i = 0; i < quantity; i++) {
        const lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;
        if (shouldCopy || lastSlideHasNextItemId) {
            // Option COPY
            shouldCopy = true;
            const currentSlide = slides[slideIndex];
            // Slide copy procedure
            const newOptions = Object.assign({}, currentSlide.options);
            // There should be an already existing isActive slide,
            // so we turning isActive off for copy
            newOptions.isActive = false;
            // Every filled item is considered to be in viewport,
            // because why else would we call this function
            // otherwise? To fill viewport obviously.
            newOptions.inViewport = true;
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
            newSlides.push(newSlide);
            // Prepare next slide index
            slideIndex--;
            if (slideIndex < 0) {
                slideIndex = slides.length - 1;
            }
            // Splice arguments processing
            // spliceFrom can be assigned once and equals first inViewport
            // slide that we met
            if (spliceFrom === null && currentSlide.options.inViewport) {
                spliceFrom = slides.length - spliceQuantity;
            }
            // We can't increase quantity if we have determined
            // from where we should splice slides
            const slideCopyNotEncountered = spliceFrom === null;
            // We can't have splice quantity higher than slides size.
            // It happens when quantity from argument is higher than
            // slides size.
            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
            if (slideCopyNotEncountered && canIncrementSpliceQuantity) {
                spliceQuantity++;
            }
        }
        else {
            // Option FILL GAP
            // Slide copy procedure
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                inViewport: true,
                item: items[nextItemId],
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                isActive: false,
            });
            newSlides.push(newSlide);
            unmarkedItemIndexes.push(nextItemId);
        }
        // Pick index for next item
        nextItemId--;
        if (nextItemId < 0) {
            nextItemId = items.length - 1;
        }
    }
    if (spliceQuantity > 0) {
        spliceFrom = spliceFrom === null
            ? slides.length - spliceQuantity
            : spliceFrom;
        slides.splice(spliceFrom, spliceQuantity);
    }
    const result = [
        ...newSlides.reverse(),
        ...slides,
    ];
    return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2h1ZmZsZS1zbGlkZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1jYXJvdXNlbC9zcmMvbGliL3ByaXZhdGUvc2VydmljZS9oZWxwZXJzL3NodWZmbGUtc2xpZGVzL3NodWZmbGUtc2xpZGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUMvRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFckU7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQ3pCLE1BQXVCLEVBQ3ZCLE1BQWMsRUFDZCxVQUFrQixFQUNsQixhQUFxQixFQUNyQixLQUFZLEVBQ1osVUFBbUIsRUFDbkIsWUFBb0IsQ0FBQyxFQUNyQixXQUFXLEdBQUcsSUFBSSxXQUFXLEVBQUU7SUFFL0IsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFFM0IsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUM5QztJQUNELElBQUksVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUVoQyxPQUFPLElBQUksbUJBQW1CLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ2xEO0lBRUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUM7SUFFakQsb0RBQW9EO0lBQ3BELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxT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QUFFLEVBQ2xCLFVBQVUsRUFDVjtnQkFDSSxxREFBcUQ7Z0JBQ3JELCtDQUErQztnQkFDL0MseUNBQXlDO2dCQUN6QyxVQUFVLEVBQUUsSUFBSTtnQkFDaEIsSUFBSSxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUM7Z0JBQ3ZCLHNEQUFzRDtnQkFDdEQsc0NBQXNDO2dCQUN0QyxRQUFRLEVBQUUsS0FBSzthQUNsQixDQUNKLENBQUM7WUFDRixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUN4QztRQUVELDJCQUEyQjtRQUMzQixVQUFVLEVBQUUsQ0FBQztRQUNiLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtZQUNoQixVQUFVLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDakM7S0FDSjtJQUVELElBQUksY0FBYyxHQUFHLENBQUMsRUFBRTtRQUNwQixVQUFVLEdBQUcsVUFBVSxLQUFLLElBQUk7WUFDNUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsY0FBYztZQUNoQyxDQUFDLENBQUMsVUFBVSxDQUFDO1FBQ2pCLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsTUFBTSxNQUFNLEdBQUc7UUFDWCxHQUFHLFNBQVMsQ0FBQyxPQUFPLEVBQUU7UUFDdEIsR0FBRyxNQUFNO0tBQ1osQ0FBQztJQUVGLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7QUFDckcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhcm91c2VsU2xpZGUgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvY2Fyb3VzZWwtc2xpZGUnO1xuaW1wb3J0IHsgSWRHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvaWQtZ2VuZXJhdG9yJztcbmltcG9ydCB7IENvcHlTbGlkZXNSZXN1bHQgfSBmcm9tICcuL21vZGVscy9jb3B5LXNsaWRlcy1yZXN1bHQnO1xuaW1wb3J0IHsgU2h1ZmZsZVNsaWRlc1Jlc3VsdCB9IGZyb20gJy4vbW9kZWxzL3NodWZmbGUtc2xpZGVzLXJlc3VsdCc7XG5cbi8qKlxuICogSnVzdGlmaWVzIGV4aXN0aW5nIHNsaWRlcyBpbiB2aWV3cG9ydCBieSBlaXRoZXJcbiAqIC0gTW92ZSBzbGlkZSBmcm9tIG9uZSBzaWRlIHRvIGFub3RoZXJcbiAqIC0gQ29weSBzbGlkZSBmcm9tIG9uZSBzaWRlIHRvIGFub3RoZXJcbiAqIC0gQ3JlYXRlIHNsaWRlIG9uIG9uZSBzaWRlXG4gKlxuICogVGFzayBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGxlYXZlIG5vIGVtcHR5IHNwYWNlcyBpbiB2aWV3cG9ydC5cbiAqXG4gKiAqKkJFIEFEVklDRUQqKiwgdGhhdCBpblZpZXdwb3J0IGZsYWcgc2hvdWxkIGJlIGNhbGN1bGF0ZWQgZm9yIGVhY2ggc2xpZGVcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBtb3ZlZCBiZWZvcmVoYW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZVNsaWRlcyhcbiAgICBzbGlkZXM6IENhcm91c2VsU2xpZGVbXSxcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICBzbGlkZVdpZHRoOiBudW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogbnVtYmVyLFxuICAgIGl0ZW1zOiBhbnlbXSxcbiAgICBzaG91bGRMb29wOiBib29sZWFuLFxuICAgIHRocmVzaG9sZDogbnVtYmVyID0gMCxcbiAgICBpZEdlbmVyYXRvciA9IG5ldyBJZEdlbmVyYXRvcigpLFxuKTogU2h1ZmZsZVNsaWRlc1Jlc3VsdCB7XG4gICAgaWYgKCFzbGlkZXMgfHwgIXNsaWRlcy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFNodWZmbGVTbGlkZXNSZXN1bHQoW10sIG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChzbGlkZVdpZHRoIDw9IDAgfHwgIXNob3VsZExvb3ApIHtcblxuICAgICAgICByZXR1cm4gbmV3IFNodWZmbGVTbGlkZXNSZXN1bHQoc2xpZGVzLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHNsaWRlU3VtV2lkdGggPSBzbGlkZXMubGVuZ3RoICogc2xpZGVXaWR0aDtcblxuICAgIC8vIENhbGN1bGF0ZSBtaXNzaW5nIHNsaWRlcyBmb3IgbGVmdCBhbmQgcmlnaHQgc2lkZXNcbiAgICBjb25zdCBsZWZ0U2lkZU1pc3NpbmdTbGlkZXMgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKG9mZnNldCArIHRocmVzaG9sZCkgLyBzbGlkZVdpZHRoKSk7XG4gICAgY29uc3QgcmlnaHRTaWRlTWlzc2luZ1NsaWRlcyA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodmlld3BvcnRXaWR0aCArIHRocmVzaG9sZCAtIChvZmZzZXQgKyBzbGlkZVN1bVdpZHRoKSkgLyBzbGlkZVdpZHRoKSk7XG5cbiAgICAvLyBMZXQncyBzdGFydCB0byBmaWxsIG1pc3Npbmcgc2xpZGVzXG5cbiAgICAvKipcbiAgICAgKiBJdGVtIGluZGV4ZXMgdGhhdCBzaG91bGQgYmUgbWFya2VkIGFzIGNvcGllcyBhZnRlclxuICAgICAqIGZ1bmN0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIGxldCB1bm1hcmtlZEl0ZW1JbmRleGVzID0gW107XG5cbiAgICAvLyBTaG91bGQgbW92ZSBzbGlkZXMgdG8gcmlnaHQgc2lkZVxuICAgIGlmIChyaWdodFNpZGVNaXNzaW5nU2xpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0U2lkZU1vdmVSZXN1bHQgPSBtb3ZlT3JDb3B5U2xpZGVzVG9FbmQoXG4gICAgICAgICAgICBzbGlkZXMsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICByaWdodFNpZGVNaXNzaW5nU2xpZGVzLFxuICAgICAgICAgICAgc2xpZGVXaWR0aCxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgaWRHZW5lcmF0b3IsXG4gICAgICAgICk7XG4gICAgICAgIHNsaWRlcyA9IHJpZ2h0U2lkZU1vdmVSZXN1bHQuc2xpZGVzO1xuICAgICAgICBvZmZzZXQgPSByaWdodFNpZGVNb3ZlUmVzdWx0Lm1vZGlmaWVkT2Zmc2V0O1xuICAgICAgICB1bm1hcmtlZEl0ZW1JbmRleGVzID0gcmlnaHRTaWRlTW92ZVJlc3VsdC51bm1hcmtlZEl0ZW1JbmRleGVzO1xuICAgIH1cblxuICAgIC8vIFNob3VsZCBtb3ZlIHNsaWRlcyB0byBsZWZ0IHNpZGVcbiAgICBpZiAobGVmdFNpZGVNaXNzaW5nU2xpZGVzKSB7XG4gICAgICAgIGNvbnN0IGxlZnRTaWRlTW92ZVJlc3VsdCA9IG1vdmVPckNvcHlTbGlkZXNUb1N0YXJ0KFxuICAgICAgICAgICAgc2xpZGVzLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgbGVmdFNpZGVNaXNzaW5nU2xpZGVzLFxuICAgICAgICAgICAgc2xpZGVXaWR0aCxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgaWRHZW5lcmF0b3IsXG4gICAgICAgICk7XG4gICAgICAgIHNsaWRlcyA9IGxlZnRTaWRlTW92ZVJlc3VsdC5zbGlkZXM7XG4gICAgICAgIG9mZnNldCA9IGxlZnRTaWRlTW92ZVJlc3VsdC5tb2RpZmllZE9mZnNldDtcbiAgICAgICAgdW5tYXJrZWRJdGVtSW5kZXhlcyA9IHVubWFya2VkSXRlbUluZGV4ZXMuY29uY2F0KGxlZnRTaWRlTW92ZVJlc3VsdC51bm1hcmtlZEl0ZW1JbmRleGVzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2h1ZmZsZVNsaWRlc1Jlc3VsdChzbGlkZXMsIG9mZnNldCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIE1vdmVzLCBjb3BpZXMgb3IgY3JlYXRlcyBzbGlkZXMgdG8gdGhlIHJpZ2h0IHNpZGUgaW4gb3JkZXIgdG8gZmlsbFxuICogZGVzaXJlZCBgcXVhbnRpdHlgLlxuICpcbiAqIFF1YW50aXR5IG1lYW5zIG9mIGhvdyBtdWNoIG5ldyBzbGlkZXMgd2lsbCBiZSBhZGRlZC5cbiAqIFRoZXJlIGFyZSB0d28gb3B0aW9ucyBvZiBob3cgd2UgY291bGQgZmlsbCBtaXNzaW5nIHNsaWRlcy5cbiAqIEltYWdpbmUgbmV4dCBzbGlkZXMgcm93IG1hcHBlZCB0byB0aGVpciBpdGVtIGluZGV4OlxuICogWzMsIDQsIDUsIDAsIDEsIDIsIDMsIDQsIDVdIGFuZCBsZXRzIHRha2UgYHF1YW50aXR5YCA9IDQuXG4gKiBXZSBjYW4ndCBqdXN0IHN0YXJ0IHRvIG1vdmUvY29weSBzbGlkZXMgZnJvbSB0aGUgcmlnaHQgcGFydCxcbiAqIGJlY2F1c2Ugd2UgY2FuJ3QgYnJlYWsgc2VxdWVuY2UgKG1lYW5pbmcgaWYgd2UnbGwgY29weSBzbGlkZSBgNWBcbiAqIG9uIHRoZSByaWdodCB0byBzbGlkZSBgM2Agb24gdGhlIGxlZnQsIHRoZXkgd29uJ3Qgc3RhY2spLlxuICogU2xpZGUgYDNgIG9uIHRoZSBsZWZ0IGF3YWl0cyBzbGlkZSB3aXRoIGl0ZW0gaW5kZXggYDJgIHRvIGJlIHB1dFxuICogbmVhciBoaW0sIHNvIHdlIHNob3VsZCBjcmVhdGUgc29tZSBzbGlkZXMgaW4gYmV0d2Vlbi4gVGhpcyBhY3Rpb25cbiAqIGlzIG5hbWVkIGBPcHRpb24gRklMTCBHQVBgLlxuICpcbiAqIGBPcHRpb24gRklMTCBHQVBgOlxuICogSG93IG11Y2ggc2xpZGVzIGFyZSBpbiBiZXR3ZWVuIGl0ZW0gaW5kZXggYDVgIGFuZCBpdGVtIGluZGV4IGAzYD9cbiAqIEFuc3dlciBpcyAzOiBbKio1KiosIDAsIDEsIDIsICoqMyoqXS4gU28gbGV0J3MgZmlsbCB0aG9zZSAzIHNsaWRlc1xuICogYW5kIHN1YnRyYWN0IHRoZWlyIGxlbmd0aCBmcm9tIGBxdWFudGl0eWAuXG4gKiBOb3cgd2UgaGF2ZSByb3cgWzAsIDEsIDIsIDMsIDQsIDUsIDAsIDEsIDIsIDMsIDQsIDVdIGFuZCBgcXVhbnRpdHlgXG4gKiBlcXVhbHMgMS4gTm93IHdlIGNhbiBzdGFydCBjb3B5L21vdmUgc2xpZGVzIGZyb20gdGhlIHJpZ2h0IHBhcnQuXG4gKiBUaGlzIGFjdGlvbiBpcyBjYWxsZWQgYE9wdGlvbiBDT1BZYFxuICpcbiAqIGBPcHRpb24gQ09QWWA6XG4gKiBXaGVuIG1lZGRsaW5nIHdpdGggc2xpZGVzIGZyb20gdGhlIG90aGVyIHNpZGUsIHdlIGhhdmUgdHdvIG9wdGlvbnNcbiAqIG9mIHdoYXQgdG8gZG8gd2l0aCB0aGVtOiBlaXRoZXIgY29weSBvciBtb3ZlLiBTbGlkZSBjYW4gYmUgbW92ZWRcbiAqIHdoZW4gaXQgaXMgbm90IGBpblZpZXdwb3J0YCwgbWVhbmluZyBpdCBoYXMgY29ycmVzcG9uZGluZyBvcHRpb25cbiAqIGZsYWcuIE90aGVyd2lzZSBpdCBzaG91bGQgYmUgY29waWVkLlxuICogSW4gb3VyIGV4YW1wbGUgd2Ugc2hvdWxkIG1vdmUgb25lIHNsaWRlIGZyb20gdGhlIHJpZ2h0IHBhcnQsIHNpbmNlXG4gKiBgcXVhbnRpdHlgIGFmdGVyIGBPcHRpb24gRklMTGAgZXF1YWxzIDEuIExldHMgaW1hZ2luZSB0aGF0IHNsaWRlXG4gKiB3YXNuJ3QgaW4gdmlld3BvcnQgYW5kIG5vdyBvdXIgc2xpZGUgcm93IGhhc1xuICogWzUsIDAsIDEsIDIsIDMsIDQsIDUsIDAsIDEsIDIsIDMsIDRdLCB2b2lsYSFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVPckNvcHlTbGlkZXNUb0VuZChcbiAgICBzbGlkZXM6IENhcm91c2VsU2xpZGVbXSxcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICBxdWFudGl0eTogbnVtYmVyLFxuICAgIHNsaWRlV2lkdGg6IG51bWJlcixcbiAgICBpdGVtczogYW55W10sXG4gICAgaWRHZW5lcmF0b3IgPSBuZXcgSWRHZW5lcmF0b3IoKSxcbik6IENvcHlTbGlkZXNSZXN1bHQge1xuICAgIGlmIChxdWFudGl0eSA8IDEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IENvcHlTbGlkZXNSZXN1bHQoc2xpZGVzLCBvZmZzZXQsIFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTbGlkZXMgPSBbXTtcbiAgICAvKiogSXRlbSBpbmRleGVzIHRoYXQgc2hvdWxkIGJlIG1hcmtlZCBhcyBjb3BpZXMgbGF0ZXIgKi9cbiAgICBjb25zdCB1bm1hcmtlZEl0ZW1JbmRleGVzID0gW107XG4gICAgLyoqIFVzZWQgYXMgYXJndW1lbnQgZm9yIHNwbGljZSBjYWxsIGxhdGVyICovXG4gICAgbGV0IHNwbGljZVF1YW50aXR5ID0gMDtcbiAgICAvKipcbiAgICAgKiBXZSBjYW4ndCBpbmNyZWFzZSBxdWFudGl0eSBpZiB3ZSBlbmNvdW50ZXJlZCBzbGlkZVxuICAgICAqIHdpdGggaW5WaWV3cG9ydCBmbGFnXG4gICAgICovXG4gICAgbGV0IGNhbkluY3JlYXNlUXVhbnRpdHkgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdG9yIGluZGV4LCB1c2VkIGluIENPUFkgb3B0aW9uLiBEZXRlcm1pbmVzIHdoaWNoXG4gICAgICogc2xpZGUgc2hvdWxkIGJlIHBpY2tlZCBmcm9tIGxlZnQgc2lkZSBmb3IgYW5hbHl6aW5nLlxuICAgICAqL1xuICAgIGxldCBzbGlkZUluZGV4ID0gMDtcbiAgICAvKipcbiAgICAgKiBPbmNlIHdlIGZpbmlzaGVkIHdpdGggb3B0aW9uIEZJTEwgR0FQLCB0aGVuXG4gICAgICogY29weSBvcHRpb24gc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgKi9cbiAgICBsZXQgc2hvdWxkQ29weSA9IGZhbHNlO1xuXG4gICAgLy8gV2UgZ29pbmcgdG8gaXRlcmF0ZSB0aHJvdWdoIGl0ZW0gaW5kZXhlcyBzdGFydGluZyBmcm9tXG4gICAgLy8gbGFzdCBzbGlkZSBpdGVtIGluZGV4LiBMZXQncyBwaWNrIGFuIGl0ZW0gaW5kZXhcbiAgICAvLyB0byBzdGFydCBmcm9tLlxuICAgIGNvbnN0IGxhc3RTbGlkZSA9IHNsaWRlc1tzbGlkZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbGFzdFNsaWRlSGFzTGFzdEl0ZW1JbmRleCA9IGxhc3RTbGlkZS5pdGVtSW5kZXggPj0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRvciBpbmRleCwgdXNlZCBpbiBGSUxMIEdBUCBhbmQgQ09QWSBvcHRpb25zLlxuICAgICAqIFRoaXMgaW5kZXggZGV0ZXJtaW5lcyB3aGljaCBpdGVtIHdpbGwgbmV4dCBzbGlkZSBoYXZlLlxuICAgICAqL1xuICAgIGxldCBuZXh0SXRlbUlkID0gbGFzdFNsaWRlSGFzTGFzdEl0ZW1JbmRleFxuICAgICAgICA/IDBcbiAgICAgICAgOiBsYXN0U2xpZGUuaXRlbUluZGV4ICsgMTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhbnRpdHk7IGkrKykge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGF2aW5nIHRoaXMgZmllbGQgYXMgdHJ1ZSBtZWFucyBzbGlkZXMgZnJvbSBsZWZ0IGFuZCByaWdodFxuICAgICAgICAgKiBzaWRlIChpbmNsdWRpbmcgbmV3IHNsaWRlcykgY2FuIHN0YWNrIGFuZCB3ZSBjYW4gcHJvY2VlZCB0b1xuICAgICAgICAgKiBDT1BZIG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZmlyc3RTbGlkZUhhc05leHRJdGVtSWQgPSBzbGlkZXNbMF0uaXRlbUluZGV4ID09PSBuZXh0SXRlbUlkO1xuXG4gICAgICAgIGlmIChzaG91bGRDb3B5IHx8IGZpcnN0U2xpZGVIYXNOZXh0SXRlbUlkKSB7XG4gICAgICAgICAgICAvLyBPcHRpb24gQ09QWVxuXG4gICAgICAgICAgICBzaG91bGRDb3B5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZSA9IHNsaWRlc1tzbGlkZUluZGV4XTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBzbGlkZSBwcm9jZWR1cmVcbiAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50U2xpZGUub3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgYW4gYWxyZWFkeSBleGlzdGluZyBpc0FjdGl2ZSBzbGlkZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHR1cm5pbmcgaXNBY3RpdmUgb2ZmIGZvciBjb3B5XG4gICAgICAgICAgICBuZXdPcHRpb25zLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBFdmVyeSBmaWxsZWQgaXRlbSBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHZpZXdwb3J0LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3aHkgZWxzZSB3b3VsZCB3ZSBjYWxsIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZT8gVG8gZmlsbCB2aWV3cG9ydCBvYnZpb3VzbHkuXG4gICAgICAgICAgICBuZXdPcHRpb25zLmluVmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbmV3U2xpZGUgPSBuZXcgQ2Fyb3VzZWxTbGlkZShcbiAgICAgICAgICAgICAgICBpZEdlbmVyYXRvci5uZXh0KCksXG4gICAgICAgICAgICAgICAgbmV4dEl0ZW1JZCxcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3U2xpZGVzLnB1c2gobmV3U2xpZGUpO1xuXG4gICAgICAgICAgICAvLyBTcGxpY2UgYXJndW1lbnRzIHByb2Nlc3NpbmdcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTbGlkZS5vcHRpb25zLmluVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICBjYW5JbmNyZWFzZVF1YW50aXR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGluY3JlYXNlIHF1YW50aXR5IGlmIHdlIGhhdmUgcmVhY2hlZCBlbmQgb2Ygc2xpZGVzLlxuICAgICAgICAgICAgLy8gSXQgaGFwcGVucyB3aGVuIHF1YW50aXR5IGZyb20gYXJndW1lbnQgaXMgaGlnaGVyIHRoYW5cbiAgICAgICAgICAgIC8vIHNsaWRlcyBzaXplLlxuICAgICAgICAgICAgY29uc3QgY2FuSW5jcmVtZW50U3BsaWNlUXVhbnRpdHkgPSBzcGxpY2VRdWFudGl0eSArIDEgPD0gc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjYW5JbmNyZWFzZVF1YW50aXR5ICYmIGNhbkluY3JlbWVudFNwbGljZVF1YW50aXR5KSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlUXVhbnRpdHkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJlcGFyZSBzbGlkZSB0byBwcm9jZXNzXG4gICAgICAgICAgICBzbGlkZUluZGV4Kys7XG4gICAgICAgICAgICBpZiAoc2xpZGVJbmRleCA+PSBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPcHRpb24gRklMTCBHQVBcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBzbGlkZSBwcm9jZWR1cmVcbiAgICAgICAgICAgIGNvbnN0IG5ld1NsaWRlID0gbmV3IENhcm91c2VsU2xpZGUoXG4gICAgICAgICAgICAgICAgaWRHZW5lcmF0b3IubmV4dCgpLFxuICAgICAgICAgICAgICAgIG5leHRJdGVtSWQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeSBmaWxsZWQgaXRlbSBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHZpZXdwb3J0LFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdoeSBlbHNlIHdvdWxkIHdlIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2U/IFRvIGZpbGwgdmlld3BvcnQgb2J2aW91c2x5LlxuICAgICAgICAgICAgICAgICAgICBpblZpZXdwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtc1tuZXh0SXRlbUlkXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIGFuIGFscmVhZHkgZXhpc3RpbmcgaXNBY3RpdmUgc2xpZGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHR1cm5pbmcgaXNBY3RpdmUgb2ZmIGZvciBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld1NsaWRlcy5wdXNoKG5ld1NsaWRlKTtcbiAgICAgICAgICAgIHVubWFya2VkSXRlbUluZGV4ZXMucHVzaChuZXh0SXRlbUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBpY2sgaW5kZXggZm9yIG5leHQgaXRlbVxuICAgICAgICBuZXh0SXRlbUlkKys7XG4gICAgICAgIGlmIChuZXh0SXRlbUlkID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dEl0ZW1JZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3BsaWNlUXVhbnRpdHkgPiAwKSB7XG4gICAgICAgIHNsaWRlcy5zcGxpY2UoMCwgc3BsaWNlUXVhbnRpdHkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRTbGlkZXMgPSBbXG4gICAgICAgIC4uLnNsaWRlcyxcbiAgICAgICAgLi4ubmV3U2xpZGVzXG4gICAgXTtcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBvZmZzZXQgKyBzcGxpY2VRdWFudGl0eSAqIHNsaWRlV2lkdGg7XG5cbiAgICByZXR1cm4gbmV3IENvcHlTbGlkZXNSZXN1bHQocmVzdWx0U2xpZGVzLCByZXN1bHRPZmZzZXQsIHVubWFya2VkSXRlbUluZGV4ZXMpO1xufVxuXG4vKipcbiAqIE1vdmVzLCBjb3BpZXMgb3IgY3JlYXRlcyBzbGlkZXMgdG8gdGhlIGxlZnQgc2lkZSBpbiBvcmRlciB0byBmaWxsXG4gKiBkZXNpcmVkIGBxdWFudGl0eWAuXG4gKlxuICogUXVhbnRpdHkgbWVhbnMgb2YgaG93IG11Y2ggbmV3IHNsaWRlcyB3aWxsIGJlIGFkZGVkLlxuICogVGhlcmUgYXJlIHR3byBvcHRpb25zIG9mIGhvdyB3ZSBjb3VsZCBmaWxsIG1pc3Npbmcgc2xpZGVzLlxuICogSW1hZ2luZSBuZXh0IHNsaWRlcyByb3cgbWFwcGVkIHRvIHRoZWlyIGl0ZW0gaW5kZXg6XG4gKiBbMCwgMSwgMiwgMywgNCwgNSwgMCwgMSwgMiwgM10gYW5kIGxldHMgdGFrZSBgcXVhbnRpdHlgID0gNC5cbiAqIFdlIGNhbid0IGp1c3Qgc3RhcnQgdG8gbW92ZS9jb3B5IHNsaWRlcyBmcm9tIHRoZSBsZWZ0IHBhcnQsXG4gKiBiZWNhdXNlIHdlIGNhbid0IGJyZWFrIHNlcXVlbmNlIChtZWFuaW5nIGlmIHdlJ2xsIGNvcHkgc2xpZGUgYDBgXG4gKiBvbiB0aGUgcmlnaHQgdG8gc2xpZGUgYDNgIG9uIHRoZSByaWdodCwgdGhleSB3b24ndCBzdGFjaykuXG4gKiBTbGlkZSBgM2Agb24gdGhlIHJpZ2h0IHNpZGUgYXdhaXRzIHNsaWRlIHdpdGggaXRlbSBpbmRleCBgMmAgdG8gYmVcbiAqIHB1dCBuZWFyIGhpbSwgc28gd2Ugc2hvdWxkIGNyZWF0ZSBzb21lIHNsaWRlcyBpbiBiZXR3ZWVuLiBUaGlzXG4gKiBhY3Rpb24gaXMgbmFtZWQgYE9wdGlvbiBGSUxMIEdBUGAuXG4gKlxuICogYE9wdGlvbiBGSUxMIEdBUGA6XG4gKiBIb3cgbXVjaCBzbGlkZXMgYXJlIGluIGJldHdlZW4gaXRlbSBpbmRleCBgMGAgYW5kIGl0ZW0gaW5kZXggYDNgP1xuICogQW5zd2VyIGlzIDI6IFsqKjMqKiwgNCwgNSwgKiowKipdLiBTbyBsZXQncyBmaWxsIHRoZXNlIDIgc2xpZGVzXG4gKiBhbmQgc3VidHJhY3QgdGhlaXIgbGVuZ3RoIGZyb20gYHF1YW50aXR5YC5cbiAqIE5vdyB3ZSBoYXZlIHJvdyBbMCwgMSwgMiwgMywgNCwgNSwgMCwgMSwgMiwgMywgNCwgNV0gYW5kIGBxdWFudGl0eWBcbiAqIGVxdWFscyAyLiBOb3cgd2UgY2FuIHN0YXJ0IGNvcHkvbW92ZSBzbGlkZXMgZnJvbSB0aGUgbGVmdCBwYXJ0LlxuICogVGhpcyBhY3Rpb24gaXMgY2FsbGVkIGBPcHRpb24gQ09QWWBcbiAqXG4gKiBgT3B0aW9uIENPUFlgOlxuICogV2hlbiBtZWRkbGluZyB3aXRoIHNsaWRlcyBmcm9tIHRoZSBvdGhlciBzaWRlLCB3ZSBoYXZlIHR3byBvcHRpb25zXG4gKiBvZiB3aGF0IHRvIGRvIHdpdGggdGhlbTogZWl0aGVyIGNvcHkgb3IgbW92ZS4gU2xpZGUgY2FuIGJlIG1vdmVkXG4gKiB3aGVuIGl0IGlzIG5vdCBgaW5WaWV3cG9ydGAsIG1lYW5pbmcgaXQgaGFzIGNvcnJlc3BvbmRpbmcgb3B0aW9uXG4gKiBmbGFnLiBPdGhlcndpc2UgaXQgc2hvdWxkIGJlIGNvcGllZC5cbiAqIEluIG91ciBleGFtcGxlIHdlIHNob3VsZCBtb3ZlIHR3byBzbGlkZXMgZnJvbSB0aGUgbGVmdCBwYXJ0LCBzaW5jZVxuICogYHF1YW50aXR5YCBhZnRlciBgT3B0aW9uIEZJTExgIGVxdWFscyAyLiBMZXRzIGltYWdpbmUgdGhhdCBzbGlkZXNcbiAqIHdlcmVuJ3QgaW4gdmlld3BvcnQgYW5kIG5vdyBvdXIgcm93IGhhc1xuICogWzIsIDMsIDQsIDUsIDAsIDEsIDIsIDMsIDQsIDUsIDAsIDFdLCB2b2lsYSFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVPckNvcHlTbGlkZXNUb1N0YXJ0KFxuICAgIHNsaWRlczogQ2Fyb3VzZWxTbGlkZVtdLFxuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIHF1YW50aXR5OiBudW1iZXIsXG4gICAgc2xpZGVXaWR0aDogbnVtYmVyLFxuICAgIGl0ZW1zOiBhbnlbXSxcbiAgICBpZEdlbmVyYXRvciA9IG5ldyBJZEdlbmVyYXRvcigpLFxuKTogQ29weVNsaWRlc1Jlc3VsdCB7XG4gICAgaWYgKHF1YW50aXR5IDwgMSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29weVNsaWRlc1Jlc3VsdChzbGlkZXMsIG9mZnNldCwgW10pO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1NsaWRlcyA9IFtdO1xuICAgIC8qKiBJdGVtIGluZGV4ZXMgdGhhdCBzaG91bGQgYmUgbWFya2VkIGFzIGNvcGllcyBsYXRlciAqL1xuICAgIGNvbnN0IHVubWFya2VkSXRlbUluZGV4ZXMgPSBbXTtcbiAgICAvKiogVXNlZCBhcyBhcmd1bWVudCBmb3Igc3BsaWNlIGNhbGwgbGF0ZXIgKi9cbiAgICBsZXQgc3BsaWNlRnJvbSA9IG51bGw7XG4gICAgLyoqIFVzZWQgYXMgYXJndW1lbnQgZm9yIHNwbGljZSBjYWxsIGxhdGVyICovXG4gICAgbGV0IHNwbGljZVF1YW50aXR5ID0gMDtcbiAgICAvKipcbiAgICAgKiBPbmNlIHdlIGZpbmlzaGVkIHdpdGggb3B0aW9uIEZJTEwgR0FQLCB0aGVuXG4gICAgICogY29weSBvcHRpb24gc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgKi9cbiAgICBsZXQgc2hvdWxkQ29weSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0b3IgaW5kZXgsIHVzZWQgaW4gQ09QWSBvcHRpb24uIERldGVybWluZXMgd2hpY2hcbiAgICAgKiBzbGlkZSBzaG91bGQgYmUgcGlja2VkIGZyb20gcmlnaHQgc2lkZSBmb3IgYW5hbHl6aW5nLlxuICAgICAqL1xuICAgIGxldCBzbGlkZUluZGV4ID0gc2xpZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBXZSBnb2luZyB0byBpdGVyYXRlIHRocm91Z2ggaXRlbSBpbmRleGVzIHN0YXJ0aW5nIGZyb21cbiAgICAvLyBmaXJzdCBzbGlkZSBpdGVtIGluZGV4LiBMZXQncyBwaWNrIGFuIGl0ZW0gaW5kZXhcbiAgICAvLyB0byBzdGFydCBmcm9tLlxuICAgIGNvbnN0IGZpcnN0U2xpZGUgPSBzbGlkZXNbMF07XG4gICAgY29uc3QgZmlyc3RTbGlkZUhhc0ZpcnN0SXRlbUlkID0gZmlyc3RTbGlkZS5pdGVtSW5kZXggPT09IDA7XG4gICAgLyoqXG4gICAgICogSXRlcmF0b3IgaW5kZXgsIHVzZWQgaW4gRklMTCBHQVAgYW5kIENPUFkgb3B0aW9ucy5cbiAgICAgKiBUaGlzIGluZGV4IGRldGVybWluZXMgd2hpY2ggaXRlbSB3aWxsIG5leHQgc2xpZGUgaGF2ZS5cbiAgICAgKi9cbiAgICBsZXQgbmV4dEl0ZW1JZCA9IGZpcnN0U2xpZGVIYXNGaXJzdEl0ZW1JZFxuICAgICAgICA/IGl0ZW1zLmxlbmd0aCAtIDFcbiAgICAgICAgOiBmaXJzdFNsaWRlLml0ZW1JbmRleCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YW50aXR5OyBpKyspIHtcbiAgICAgICAgY29uc3QgbGFzdFNsaWRlSGFzTmV4dEl0ZW1JZCA9IHNsaWRlc1tzbGlkZXMubGVuZ3RoIC0gMV0uaXRlbUluZGV4ID09PSBuZXh0SXRlbUlkO1xuXG4gICAgICAgIGlmIChzaG91bGRDb3B5IHx8IGxhc3RTbGlkZUhhc05leHRJdGVtSWQpIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbiBDT1BZXG5cbiAgICAgICAgICAgIHNob3VsZENvcHkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNsaWRlID0gc2xpZGVzW3NsaWRlSW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBTbGlkZSBjb3B5IHByb2NlZHVyZVxuICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRTbGlkZS5vcHRpb25zKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBhbiBhbHJlYWR5IGV4aXN0aW5nIGlzQWN0aXZlIHNsaWRlLFxuICAgICAgICAgICAgLy8gc28gd2UgdHVybmluZyBpc0FjdGl2ZSBvZmYgZm9yIGNvcHlcbiAgICAgICAgICAgIG5ld09wdGlvbnMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEV2ZXJ5IGZpbGxlZCBpdGVtIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdmlld3BvcnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdoeSBlbHNlIHdvdWxkIHdlIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlPyBUbyBmaWxsIHZpZXdwb3J0IG9idmlvdXNseS5cbiAgICAgICAgICAgIG5ld09wdGlvbnMuaW5WaWV3cG9ydCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBuZXdTbGlkZSA9IG5ldyBDYXJvdXNlbFNsaWRlKFxuICAgICAgICAgICAgICAgIGlkR2VuZXJhdG9yLm5leHQoKSxcbiAgICAgICAgICAgICAgICBuZXh0SXRlbUlkLFxuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3U2xpZGVzLnB1c2gobmV3U2xpZGUpO1xuXG4gICAgICAgICAgICAvLyBQcmVwYXJlIG5leHQgc2xpZGUgaW5kZXhcbiAgICAgICAgICAgIHNsaWRlSW5kZXgtLTtcbiAgICAgICAgICAgIGlmIChzbGlkZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHNsaWRlSW5kZXggPSBzbGlkZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BsaWNlIGFyZ3VtZW50cyBwcm9jZXNzaW5nXG5cbiAgICAgICAgICAgIC8vIHNwbGljZUZyb20gY2FuIGJlIGFzc2lnbmVkIG9uY2UgYW5kIGVxdWFscyBmaXJzdCBpblZpZXdwb3J0XG4gICAgICAgICAgICAvLyBzbGlkZSB0aGF0IHdlIG1ldFxuICAgICAgICAgICAgaWYgKHNwbGljZUZyb20gPT09IG51bGwgJiYgY3VycmVudFNsaWRlLm9wdGlvbnMuaW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHNwbGljZUZyb20gPSBzbGlkZXMubGVuZ3RoIC0gc3BsaWNlUXVhbnRpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGluY3JlYXNlIHF1YW50aXR5IGlmIHdlIGhhdmUgZGV0ZXJtaW5lZFxuICAgICAgICAgICAgLy8gZnJvbSB3aGVyZSB3ZSBzaG91bGQgc3BsaWNlIHNsaWRlc1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVDb3B5Tm90RW5jb3VudGVyZWQgPSBzcGxpY2VGcm9tID09PSBudWxsO1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgaGF2ZSBzcGxpY2UgcXVhbnRpdHkgaGlnaGVyIHRoYW4gc2xpZGVzIHNpemUuXG4gICAgICAgICAgICAvLyBJdCBoYXBwZW5zIHdoZW4gcXVhbnRpdHkgZnJvbSBhcmd1bWVudCBpcyBoaWdoZXIgdGhhblxuICAgICAgICAgICAgLy8gc2xpZGVzIHNpemUuXG4gICAgICAgICAgICBjb25zdCBjYW5JbmNyZW1lbnRTcGxpY2VRdWFudGl0eSA9IHNwbGljZVF1YW50aXR5ICsgMSA8PSBzbGlkZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNsaWRlQ29weU5vdEVuY291bnRlcmVkICYmIGNhbkluY3JlbWVudFNwbGljZVF1YW50aXR5KSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlUXVhbnRpdHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbiBGSUxMIEdBUFxuXG4gICAgICAgICAgICAvLyBTbGlkZSBjb3B5IHByb2NlZHVyZVxuICAgICAgICAgICAgY29uc3QgbmV3U2xpZGUgPSBuZXcgQ2Fyb3VzZWxTbGlkZShcbiAgICAgICAgICAgICAgICBpZEdlbmVyYXRvci5uZXh0KCksXG4gICAgICAgICAgICAgICAgbmV4dEl0ZW1JZCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXJ5IGZpbGxlZCBpdGVtIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdmlld3BvcnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2h5IGVsc2Ugd291bGQgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZT8gVG8gZmlsbCB2aWV3cG9ydCBvYnZpb3VzbHkuXG4gICAgICAgICAgICAgICAgICAgIGluVmlld3BvcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1zW25leHRJdGVtSWRdLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgYW4gYWxyZWFkeSBleGlzdGluZyBpc0FjdGl2ZSBzbGlkZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgdHVybmluZyBpc0FjdGl2ZSBvZmYgZm9yIGNvcHlcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3U2xpZGVzLnB1c2gobmV3U2xpZGUpO1xuICAgICAgICAgICAgdW5tYXJrZWRJdGVtSW5kZXhlcy5wdXNoKG5leHRJdGVtSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGljayBpbmRleCBmb3IgbmV4dCBpdGVtXG4gICAgICAgIG5leHRJdGVtSWQtLTtcbiAgICAgICAgaWYgKG5leHRJdGVtSWQgPCAwKSB7XG4gICAgICAgICAgICBuZXh0SXRlbUlkID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGxpY2VRdWFudGl0eSA+IDApIHtcbiAgICAgICAgc3BsaWNlRnJvbSA9IHNwbGljZUZyb20gPT09IG51bGxcbiAgICAgICAgICAgID8gc2xpZGVzLmxlbmd0aCAtIHNwbGljZVF1YW50aXR5XG4gICAgICAgICAgICA6IHNwbGljZUZyb207XG4gICAgICAgIHNsaWRlcy5zcGxpY2Uoc3BsaWNlRnJvbSwgc3BsaWNlUXVhbnRpdHkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgIC4uLm5ld1NsaWRlcy5yZXZlcnNlKCksXG4gICAgICAgIC4uLnNsaWRlcyxcbiAgICBdO1xuXG4gICAgcmV0dXJuIG5ldyBDb3B5U2xpZGVzUmVzdWx0KHJlc3VsdCwgb2Zmc2V0IC0gbmV3U2xpZGVzLmxlbmd0aCAqIHNsaWRlV2lkdGgsIHVubWFya2VkSXRlbUluZGV4ZXMpO1xufVxuIl19