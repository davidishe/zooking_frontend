import { CarouselAlignMode } from '../../../../carousel-align-mode';
import { CalculateOffsetResult } from './models/calculate-offset-result';
/**
 * Calculates offset by specified arguments as if current slide was centered
 */
export function calculateOffset(currentSlideIndex, alignMode, slideWidth, viewportWidth, slideQuantity, shouldLoop) {
    const activeSlideLeftPosition = alignMode === CarouselAlignMode.CENTER
        ? (viewportWidth - slideWidth) / 2
        : 0;
    const slidesSumWidth = slideWidth * slideQuantity;
    let newOffset = activeSlideLeftPosition - (slideWidth * currentSlideIndex);
    // Edge case amendment for left-aligned non-looped slides:
    // non-looped slides might have their right or left edge visible
    // so we might amend offset for some situations
    if (!shouldLoop && alignMode === CarouselAlignMode.LEFT) {
        // Calculate prequesites
        const rightmostPoint = newOffset + slidesSumWidth;
        const allSlidesVisible = slidesSumWidth <= viewportWidth;
        // Apply offset amendment
        if (!allSlidesVisible && rightmostPoint <= viewportWidth) {
            // Left aligned slides with their right edge visible:
            // righmost slide edge should stick to the right viewport edge
            newOffset = viewportWidth - slidesSumWidth;
        }
        else if (allSlidesVisible) {
            // Left aligned slides which are all visible:
            // just stick them to the left viewport edge
            newOffset = 0;
        }
    }
    const result = new CalculateOffsetResult(Math.round(newOffset));
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY3VsYXRlLW9mZnNldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWNhcm91c2VsL3NyYy9saWIvcHJpdmF0ZS9zZXJ2aWNlL2hlbHBlcnMvY2FsY3VsYXRlLW9mZnNldC9jYWxjdWxhdGUtb2Zmc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRXpFOztHQUVHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FDM0IsaUJBQXlCLEVBQ3pCLFNBQTRCLEVBQzVCLFVBQWtCLEVBQ2xCLGFBQXFCLEVBQ3JCLGFBQXFCLEVBQ3JCLFVBQW1CO0lBRW5CLE1BQU0sdUJBQXVCLEdBQUcsU0FBUyxLQUFLLGlCQUFpQixDQUFDLE1BQU07UUFDbEUsQ0FBQyxDQUFDLENBQUMsYUFBYSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNSLE1BQU0sY0FBYyxHQUFHLFVBQVUsR0FBRyxhQUFhLENBQUM7SUFDbEQsSUFBSSxTQUFTLEdBQUksdUJBQXVCLEdBQUcsQ0FBQyxVQUFVLEdBQUcsaUJBQWlCLENBQUMsQ0FBQztJQUU1RSwwREFBMEQ7SUFDMUQsZ0VBQWdFO0lBQ2hFLCtDQUErQztJQUMvQyxJQUFJLENBQUMsVUFBVSxJQUFJLFNBQVMsS0FBSyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUU7UUFDckQsd0JBQXdCO1FBQ3hCLE1BQU0sY0FBYyxHQUFHLFNBQVMsR0FBRyxjQUFjLENBQUM7UUFDbEQsTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLElBQUksYUFBYSxDQUFDO1FBRXpELHlCQUF5QjtRQUN6QixJQUFJLENBQUMsZ0JBQWdCLElBQUksY0FBYyxJQUFJLGFBQWEsRUFBRTtZQUN0RCxxREFBcUQ7WUFDckQsOERBQThEO1lBQzlELFNBQVMsR0FBRyxhQUFhLEdBQUcsY0FBYyxDQUFDO1NBQzlDO2FBQU0sSUFBSSxnQkFBZ0IsRUFBRTtZQUN6Qiw2Q0FBNkM7WUFDN0MsNENBQTRDO1lBQzVDLFNBQVMsR0FBRyxDQUFDLENBQUM7U0FDakI7S0FDSjtJQUNELE1BQU0sTUFBTSxHQUFHLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBRWhFLE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYXJvdXNlbEFsaWduTW9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL2Nhcm91c2VsLWFsaWduLW1vZGUnO1xuaW1wb3J0IHsgQ2FsY3VsYXRlT2Zmc2V0UmVzdWx0IH0gZnJvbSAnLi9tb2RlbHMvY2FsY3VsYXRlLW9mZnNldC1yZXN1bHQnO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgb2Zmc2V0IGJ5IHNwZWNpZmllZCBhcmd1bWVudHMgYXMgaWYgY3VycmVudCBzbGlkZSB3YXMgY2VudGVyZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChcbiAgICBjdXJyZW50U2xpZGVJbmRleDogbnVtYmVyLFxuICAgIGFsaWduTW9kZTogQ2Fyb3VzZWxBbGlnbk1vZGUsXG4gICAgc2xpZGVXaWR0aDogbnVtYmVyLFxuICAgIHZpZXdwb3J0V2lkdGg6IG51bWJlcixcbiAgICBzbGlkZVF1YW50aXR5OiBudW1iZXIsXG4gICAgc2hvdWxkTG9vcDogYm9vbGVhbixcbik6IENhbGN1bGF0ZU9mZnNldFJlc3VsdCB7XG4gICAgY29uc3QgYWN0aXZlU2xpZGVMZWZ0UG9zaXRpb24gPSBhbGlnbk1vZGUgPT09IENhcm91c2VsQWxpZ25Nb2RlLkNFTlRFUlxuICAgICAgICA/ICh2aWV3cG9ydFdpZHRoIC0gc2xpZGVXaWR0aCkgLyAyXG4gICAgICAgIDogMDtcbiAgICBjb25zdCBzbGlkZXNTdW1XaWR0aCA9IHNsaWRlV2lkdGggKiBzbGlkZVF1YW50aXR5O1xuICAgIGxldCBuZXdPZmZzZXQgPSAgYWN0aXZlU2xpZGVMZWZ0UG9zaXRpb24gLSAoc2xpZGVXaWR0aCAqIGN1cnJlbnRTbGlkZUluZGV4KTtcblxuICAgIC8vIEVkZ2UgY2FzZSBhbWVuZG1lbnQgZm9yIGxlZnQtYWxpZ25lZCBub24tbG9vcGVkIHNsaWRlczpcbiAgICAvLyBub24tbG9vcGVkIHNsaWRlcyBtaWdodCBoYXZlIHRoZWlyIHJpZ2h0IG9yIGxlZnQgZWRnZSB2aXNpYmxlXG4gICAgLy8gc28gd2UgbWlnaHQgYW1lbmQgb2Zmc2V0IGZvciBzb21lIHNpdHVhdGlvbnNcbiAgICBpZiAoIXNob3VsZExvb3AgJiYgYWxpZ25Nb2RlID09PSBDYXJvdXNlbEFsaWduTW9kZS5MRUZUKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVxdWVzaXRlc1xuICAgICAgICBjb25zdCByaWdodG1vc3RQb2ludCA9IG5ld09mZnNldCArIHNsaWRlc1N1bVdpZHRoO1xuICAgICAgICBjb25zdCBhbGxTbGlkZXNWaXNpYmxlID0gc2xpZGVzU3VtV2lkdGggPD0gdmlld3BvcnRXaWR0aDtcblxuICAgICAgICAvLyBBcHBseSBvZmZzZXQgYW1lbmRtZW50XG4gICAgICAgIGlmICghYWxsU2xpZGVzVmlzaWJsZSAmJiByaWdodG1vc3RQb2ludCA8PSB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBMZWZ0IGFsaWduZWQgc2xpZGVzIHdpdGggdGhlaXIgcmlnaHQgZWRnZSB2aXNpYmxlOlxuICAgICAgICAgICAgLy8gcmlnaG1vc3Qgc2xpZGUgZWRnZSBzaG91bGQgc3RpY2sgdG8gdGhlIHJpZ2h0IHZpZXdwb3J0IGVkZ2VcbiAgICAgICAgICAgIG5ld09mZnNldCA9IHZpZXdwb3J0V2lkdGggLSBzbGlkZXNTdW1XaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxTbGlkZXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBMZWZ0IGFsaWduZWQgc2xpZGVzIHdoaWNoIGFyZSBhbGwgdmlzaWJsZTpcbiAgICAgICAgICAgIC8vIGp1c3Qgc3RpY2sgdGhlbSB0byB0aGUgbGVmdCB2aWV3cG9ydCBlZGdlXG4gICAgICAgICAgICBuZXdPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDYWxjdWxhdGVPZmZzZXRSZXN1bHQoTWF0aC5yb3VuZChuZXdPZmZzZXQpKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iXX0=