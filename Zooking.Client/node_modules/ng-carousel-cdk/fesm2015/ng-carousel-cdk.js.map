{"version":3,"file":"ng-carousel-cdk.js","sources":["../../../projects/ng-carousel/src/lib/carousel-width-mode.ts","../../../projects/ng-carousel/src/lib/carousel-align-mode.ts","../../../projects/ng-carousel/src/lib/carousel-config.ts","../../../projects/ng-carousel/src/lib/carousel-slide.directive.ts","../../../projects/ng-carousel/src/lib/private/models/id-generator.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-autoplay.ts","../../../projects/ng-carousel/src/lib/private/models/initialization-state.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-state.ts","../../../projects/ng-carousel/src/lib/private/models/procedure-error.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/procedure-pipe.ts","../../../projects/ng-carousel/src/lib/private/tokens.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/contiue-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width-in-px/get-viewport-width-in-px.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width/get-viewport-width.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/models/calculate-active-slide-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/models/calculate-offset-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/models/mark-visible-and-active-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/models/remove-excessive-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/copy-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/shuffle-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/cleanup-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/normalize-passed-distance/normalize-passed-distance-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-offset-snapshot/set-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-end-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/break-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-drag-enabled/postpone-drag-enabled-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-start-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-item-index/postpone-item-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/go-to-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-initialization/postpone-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-beziers/set-beziers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-first-initalization/set-first-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/remove-postponed-index/remove-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-postponed-index/set-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-config/set-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-containers/set-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/next-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/prev-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/recalculate-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-template/set-template-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/carousel.service.ts","../../../projects/ng-carousel/src/lib/carousel.component.ts","../../../projects/ng-carousel/src/lib/private/service/hammer-provider.service.ts","../../../projects/ng-carousel/src/lib/prevent-ghost-click.directive.ts","../../../projects/ng-carousel/src/lib/private/directives/untabbable.directive.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide-context.ts","../../../projects/ng-carousel/src/lib/private/views/carousel-engine.component.ts","../../../projects/ng-carousel/src/lib/carousel.module.ts","../../../projects/ng-carousel/src/public-api.ts","../../../projects/ng-carousel/src/ng-carousel-cdk.ts"],"sourcesContent":["/**\n * Represents how carousel calculates slide width. Be adviced\n * that actual enum value is used in code, so change with caution.\n */\nexport enum CarouselWidthMode {\n    /**\n     * When pixel management is provided, carousel calculates\n     * slide width with pixels. Preferred to use in limited space\n     * where carousel width is more or less is predefined.\n     */\n    PX = 'px',\n    /**\n     * When percent management is provided, carousel calculates\n     * slide width with relative instrument (via percents). Preferred\n     * to use in full-width carousel, where carousel width is unknown.\n     */\n    PERCENT = '%',\n}\n","export enum CarouselAlignMode {\n    /**\n     * Active slide is always centered in carousel viewport\n     */\n    CENTER = 'center',\n    /**\n     * Active slide left border sticks to left border of\n     * carousel\n     */\n    LEFT = 'left',\n}\n","import { CarouselWidthMode } from './carousel-width-mode';\nimport { CarouselAlignMode } from './carousel-align-mode';\n\nexport class CarouselConfig {\n    /**\n     * Array of data to display\n     */\n    items?: any[] = [];\n    /**\n     * Describes how carousel calculates its content width.\n     * Consult with corresponding enum to see what options\n     * are available.\n     */\n    widthMode?: CarouselWidthMode = CarouselWidthMode.PERCENT;\n    /**\n     * Slide width. It could be pixels or percents, based on mode\n     * configuration.\n     */\n    slideWidth ? = 100;\n    /**\n     * Describes how slides should be positioned relative to\n     * carousel viewport\n     */\n    alignMode?: CarouselAlignMode = CarouselAlignMode.CENTER;\n    /**\n     * Whether autoplay is enabled\n     */\n    autoplayEnabled ? = true;\n    /**\n     * Time in ms of how long carousel would wait until automatic\n     * slide increment. Respects `autoplayEnabled` value.\n     */\n    autoplayDelay ? = 6000;\n    /**\n     * Whether mouse drag or gesture panning enabled\n     */\n    dragEnabled ? = true;\n    /**\n     * Whether carousel should start from beginning after last\n     * slide\n     */\n    shouldLoop ? = true;\n    /**\n     * Time in ms of how long transition between slides would last\n     */\n    transitionDuration ? = 280;\n    /**\n     * Whether carousel should automatically recalculate on window resize.\n     * This option is recommended when using pixel width mode or left\n     * alignment.\n     */\n    shouldRecalculateOnResize ? = true;\n    /**\n     * Value in current width mode units which are virtally added to both sides\n     * of viewport. Slides within this virtual zone should always be presented\n     * whether loop mode is on.\n     */\n    threshold ? = 5;\n\n    constructor(config?: CarouselConfig) {\n        // @TODO nullish coalescing here\n        this.items = config && config.items || [];\n        this.widthMode = config && config.widthMode || CarouselWidthMode.PERCENT;\n        this.alignMode = config && config.alignMode || CarouselAlignMode.CENTER;\n        this.slideWidth = config && typeof config.slideWidth === 'number'\n            ? config.slideWidth\n            : 100;\n        this.autoplayEnabled = config && typeof config.autoplayEnabled === 'boolean'\n            ? config.autoplayEnabled\n            : true;\n        this.autoplayDelay = config && typeof config.autoplayDelay === 'number'\n            ? config.autoplayDelay\n            : 6000;\n        this.dragEnabled = config && typeof config.dragEnabled === 'boolean'\n            ? config.dragEnabled\n            : true;\n        this.shouldLoop = config && typeof config.shouldLoop === 'boolean'\n            ? config.shouldLoop\n            : true;\n        this.transitionDuration = config && typeof config.transitionDuration === 'number'\n            ? config.transitionDuration\n            : 600;\n        this.shouldRecalculateOnResize = config && typeof config.shouldRecalculateOnResize === 'boolean'\n            ? config.shouldRecalculateOnResize\n            : true;\n    }\n}\n","import { Directive, TemplateRef } from '@angular/core';\n\n@Directive({\n    selector: '[ngCarouselSlide]',\n})\nexport class CarouselSlideDirective {\n\n    constructor(\n        public templateRef: TemplateRef<any>,\n    ) {\n    }\n\n}\n","/**\n * Generator for `CarouselSlide` id, should be\n * singleton throughout single carousel.\n */\nexport class IdGenerator {\n    private index = 0;\n\n    next(): number {\n        return this.index++;\n    }\n}\n","import { Subscription } from 'rxjs';\n\nimport { AutoplaySuspender } from './autoplay-suspender';\n\n/**\n * Autoplay state of current autoplay timer\n */\nexport class CarouselAutoplay {\n    autoplaySuspenders = new Set<AutoplaySuspender>();\n    autoplaySubscription: Subscription = null;\n    interval: number = null;\n}\n","/**\n * Since we don't want excessive slide recalculation\n * while main inputs are still on their way, we should\n * collect them and then initialize carousel when\n * everything is ready.\n */\nexport class InitializationState {\n    configInitialized = false;\n    viewportWidthInitialized = false;\n    /** Whether slides were created for the first time */\n    firstInitalization = false;\n}\n","import { TemplateRef } from '@angular/core';\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { CarouselAnimation } from './carousel-animation';\nimport { CarouselAutoplay } from './carousel-autoplay';\nimport { CarouselSlide } from './carousel-slide';\nimport { InitializationState } from './initialization-state';\n\n/**\n * Carousel state snapshot. Config is stored here\n * as well as other vital values like offset or\n * active slide index.\n */\nexport class CarouselState {\n    /**\n     * Container to measure gallery width. Type is HTMLElement but\n     * reduced for the ease of testing.\n     */\n    widthContainer: {offsetWidth: number} | null = null;\n    /** Container that should be animated during index change */\n    animatableContainer: HTMLElement | null = null;\n    /** Client-side config which regulates carousel behavior */\n    config: CarouselConfig = new CarouselConfig();\n    activeSlideIndex = 0;\n    /** Item index of config's items array */\n    activeItemIndex = 0;\n    template: TemplateRef<any> | null = null;\n    /** X position of leftmost carousel slide */\n    offset = 0;\n    slides: CarouselSlide[] = [];\n    /** State of multiphase initialization */\n    initializationState = new InitializationState();\n    /** Currently played animation */\n    animation: CarouselAnimation | null = null;\n    autoplay: CarouselAutoplay = new CarouselAutoplay();\n    dragBezierFn: EasingFunction;\n    /** Used to extract values to applied beziers */\n    invertedDragBezierFn: EasingFunction;\n    animationBezierFn: EasingFunction;\n    /**\n     * When no slides available and user intents to set index,\n     * this field would be initialized with desired index, which\n     * should be to activeSlideIndex when slides become available\n     */\n    postponedItemIndex: number;\n    /** Whether drag is in process right now */\n    isDragged: boolean;\n\n    constructor(state?: CarouselState) {\n        if (state) {\n            Object.assign(this, state);\n        }\n    }\n}\n","export class ProcedureError extends Error {\n    constructor(\n        error: Error,\n    ) {\n        super();\n        this.message = error.message;\n        this.stack = error.stack;\n    }\n}\n","import { ProcedureError } from '../procedure-error';\nimport { ComposedProcedure } from './composed-procedure.type';\nimport { ProcedureHandler } from './handler/procedure-handler.interface';\nimport { ProcedureResult } from './procedure-result.type';\nimport { ProcedureStateFacade } from './procedure-state-facade.interface';\nimport { Procedure } from './procedure.type';\n\n/** Organizes array of procedures into single procedure, flattens inner procedures */\nexport function procedurePipe(procedureName: string, ...args: (ComposedProcedure | null)[]): ProcedureResult {\n    return (state: ProcedureStateFacade, parentProcedureName?: string): ProcedureHandler => {\n        let handler: ProcedureHandler;\n        let procedureIndex = 0;\n        for (const procedure of args) {\n            if (typeof procedure !== 'function') {\n                continue;\n            }\n            const procedureState = Object.entries(handler?.procedureState ?? {}).length\n                ? handler.procedureState\n                : state.procedureState;\n            const nextState: ProcedureStateFacade = {\n                state: handler?.state ?? state.state,\n                procedureState: procedureState || {},\n                environment: state.environment,\n            };\n            const procedureSlot = `${procedureName}[${procedureIndex}]`;\n            const procedureChainString = parentProcedureName\n                ? `${parentProcedureName}->${procedureSlot}`\n                : procedureSlot;\n            let localHandler: ProcedureHandler | Procedure;\n            while (typeof localHandler === 'function' || !localHandler) {\n                try {\n                    localHandler = !localHandler\n                        ? procedure(nextState, procedureChainString)\n                        : (localHandler as Procedure)(nextState, procedureChainString);\n                } catch (e) {\n                    if (!(e instanceof ProcedureError)) {\n                        console.error(`Procedure interrupted at ${procedureChainString}`);\n                    }\n                    throw new ProcedureError(e);\n                }\n            }\n            handler = localHandler;\n            procedureIndex++;\n            if (handler.shouldBreakProcedure) {\n                break;\n            }\n        }\n\n        return handler;\n    };\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { IdGenerator } from './models/id-generator';\n\nexport const SLIDE_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\nexport const ANIMATION_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class ContinueWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = false;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: Partial<ProcedureCarouselState> = {},\n    ) {\n    }\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Stops autoplay timer, provides side effect for provided autoplay */\nexport function disableAutoplay(\n    suspender: AutoplaySuspender,\n    autoplay: CarouselAutoplay = new CarouselAutoplay(),\n): CarouselAutoplay {\n    autoplay?.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    autoplay.autoplaySuspenders.add(suspender);\n\n    return autoplay;\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { disableAutoplay } from './disable-autoplay';\n\n/**\n * Turns current autoplay timer off with a specified reason\n */\nexport function disableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = disableAutoplay(\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { interval } from 'rxjs';\n\nimport { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Starts carousel autoplay whether one is enabled */\nexport function enableAutoplay(\n    autoplayEnabled: boolean,\n    transitionDuration: number,\n    autoplayDelay: number,\n    isBrowser: boolean,\n    autoplayAction: () => void,\n    suspender?: AutoplaySuspender,\n    autoplay?: CarouselAutoplay,\n): CarouselAutoplay {\n    if (!autoplay) {\n        autoplay = new CarouselAutoplay();\n    }\n    autoplay.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    if (suspender) {\n        autoplay.autoplaySuspenders.delete(suspender);\n    }\n    if (autoplayEnabled && !autoplay.autoplaySuspenders.size && isBrowser) {\n        // Delay can't be smaller than transition itself in order to avoid endless animation\n        autoplay.interval = Math.max(transitionDuration, autoplayDelay);\n        autoplay.autoplaySubscription = interval(autoplay.interval).subscribe(autoplayAction);\n    }\n\n    return autoplay;\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { enableAutoplay } from './enable-autoplay';\n\n/**\n * Enables autoplay when such option is available in config\n */\nexport function enableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = enableAutoplay(\n            state.config.autoplayEnabled,\n            state.config.transitionDuration,\n            state.config.autoplayDelay,\n            environment?.isBrowser ?? false,\n            environment?.autoplayAction ?? (() => {}),\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselState } from '../../../models/carousel-state';\n\n/**\n * Width of carousel element in pixels. Try to call this as little as\n * possible, since getting this value triggers layout thrashing.\n */\nexport function getViewportWidthInPx(state: CarouselState): number {\n    return state?.widthContainer?.offsetWidth ?? 100;\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselState } from '../../../models/carousel-state';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\n\n/**\n * Width of carousel element in current width mode.\n * Try to call this as little as possible, since getting this value\n * triggers layout thrashing.\n */\nexport function getViewportWidth(state: CarouselState): number {\n    return state?.config?.widthMode === CarouselWidthMode.PX\n        ? getViewportWidthInPx(state)\n        : 100;\n}\n","/**\n * Result for helper function `calculateActiveSlide`\n */\nexport class CalculateActiveSlideResult {\n\n    constructor(\n        public modifiedOffset: number = 0,\n        public slideIndex: number = 0,\n    ) {\n    }\n\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CalculateActiveSlideResult } from './models/calculate-active-slide-result';\n\n/**\n * Based on current whereabouts, returns most possible\n * active slide candidate and proposed offset for it\n */\nexport function calculateActiveSlide(\n    slides: CarouselSlide[],\n    offset: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    swipeThresholdPercent: number | null,\n    /** Distance (whether in px or %) that is aligned to carousel width mode */\n    swipeDistance: number | null = null,\n): CalculateActiveSlideResult {\n    const result = new CalculateActiveSlideResult(offset, 0);\n\n    // Noop run if nothing to calculate\n    if (!slides.length || slideWidth <= 0) {\n\n        return result;\n    }\n    const slidesSumWidth = slideWidth * slides.length;\n\n    // By given align mode, width mode and viewport width, calculate\n    // carousel center position\n    const carouselCenter = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : viewportWidth / 2;\n\n    // Slide center is not always its left side. On such occasion we should\n    // correct its offset using specified align mode.\n    const slideRightAmendment = alignMode === CarouselAlignMode.LEFT\n        ? slideWidth\n        : slideWidth / 2;\n    const slideLeftAmendment = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : slideRightAmendment;\n\n    // Preset if slides far behind carousel center\n    if (offset + slidesSumWidth < carouselCenter) {\n        result.slideIndex = slides.length - 1;\n        result.modifiedOffset = carouselCenter - slidesSumWidth + slideRightAmendment;\n\n    // Preset if slides far away from carousel center\n    } else if (offset - slideLeftAmendment > carouselCenter) {\n        result.slideIndex = 0;\n        result.modifiedOffset = carouselCenter - slideLeftAmendment;\n\n    // Any other cases (when slides intersect carousel center)\n    } else {\n        result.slideIndex = Math.floor(Math.abs(carouselCenter - offset) / slideWidth);\n        result.modifiedOffset = carouselCenter - result.slideIndex * slideWidth - slideLeftAmendment;\n    }\n\n    // Swipe correction: animation must align with swipe direction meaning\n    // when user swipes right, final animation should also lead to the right\n    const swipeDirection = Math.sign(swipeDistance);\n    const offsetDirection = offset > result.modifiedOffset\n        ? -1\n        : 1;\n    const shouldApplySwipeAlignment =\n        swipeDistance !== null\n        && swipeThresholdPercent !== null\n        && Math.abs(swipeDistance) > Math.abs(swipeThresholdPercent)\n        && swipeDirection !== offsetDirection;\n    if (shouldApplySwipeAlignment) {\n        const appliedSwipeAlignment = result.slideIndex - swipeDirection;\n        const newSlideIndex = Math.min(Math.max(0, appliedSwipeAlignment), slides.length - 1);\n        if (newSlideIndex !== result.slideIndex) {\n            result.slideIndex = newSlideIndex;\n            result.modifiedOffset += swipeDirection * slideWidth;\n        }\n    }\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateActiveSlide } from './calculate-active-slide';\n\n/**\n * Given current slide state, assigns active slide\n */\nexport function calculateActiveSlideProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = calculateActiveSlide(\n            state.slides,\n            state.offset,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            Math.min(state.config.slideWidth / 2, environment.swipeThreshold),\n            procedureState.passedDistance || null,\n        );\n        state.activeSlideIndex = result.slideIndex;\n        state.activeItemIndex = state.slides[result.slideIndex]?.itemIndex ?? 0;\n\n        return new ContinueWith(state);\n    };\n}\n","export class CalculateOffsetResult {\n    constructor(\n        public offset: number,\n    ) {\n    }\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CalculateOffsetResult } from './models/calculate-offset-result';\n\n/**\n * Calculates offset by specified arguments as if current slide was centered\n */\nexport function calculateOffset(\n    currentSlideIndex: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    slideQuantity: number,\n    shouldLoop: boolean,\n): CalculateOffsetResult {\n    const activeSlideLeftPosition = alignMode === CarouselAlignMode.CENTER\n        ? (viewportWidth - slideWidth) / 2\n        : 0;\n    const slidesSumWidth = slideWidth * slideQuantity;\n    let newOffset =  activeSlideLeftPosition - (slideWidth * currentSlideIndex);\n\n    // Edge case amendment for left-aligned non-looped slides:\n    // non-looped slides might have their right or left edge visible\n    // so we might amend offset for some situations\n    if (!shouldLoop && alignMode === CarouselAlignMode.LEFT) {\n        // Calculate prequesites\n        const rightmostPoint = newOffset + slidesSumWidth;\n        const allSlidesVisible = slidesSumWidth <= viewportWidth;\n\n        // Apply offset amendment\n        if (!allSlidesVisible && rightmostPoint <= viewportWidth) {\n            // Left aligned slides with their right edge visible:\n            // righmost slide edge should stick to the right viewport edge\n            newOffset = viewportWidth - slidesSumWidth;\n        } else if (allSlidesVisible) {\n            // Left aligned slides which are all visible:\n            // just stick them to the left viewport edge\n            newOffset = 0;\n        }\n    }\n    const result = new CalculateOffsetResult(Math.round(newOffset));\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateOffset } from './calculate-offset';\n\n/**\n * Given current slide state, assigns carousel offset\n */\nexport function calculateOffsetProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        state = Object.assign({}, state);\n        const result = calculateOffset(\n            state.activeSlideIndex,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.slides.length,\n            state.config.shouldLoop,\n        );\n        state.offset = result.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselAnimation } from '../../../models/carousel-animation';\n\n/**\n * Destroys animation player without callback\n */\nexport function destroyAnimation(\n    animation?: CarouselAnimation,\n): void {\n    try {\n        animation?.player?.finish();\n        animation?.player?.destroy();\n    // Ignore exception since player might be already destroyed\n    // at this moment\n    } catch (e) {}\n    animation?.onDoneSubscription$?.unsubscribe();\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { destroyAnimation } from './destroy-animation';\n\n/**\n * Destroys and removes any ongoing animation state\n */\nexport function destroyAnimationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        destroyAnimation(state.animation);\n        state.animation = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlideParams } from './carousel-slide-params';\n\n/**\n * Slide model representation\n */\nexport class CarouselSlide {\n\n    constructor(\n        /**\n         * Id is used in trackBy and should be generated\n         * with `IdGenerator`\n         */\n        public id: number,\n        /**\n         * Represents index from `items` array of carousel\n         * config\n         */\n        public itemIndex: number,\n        /**\n         * Parameters that might be changed over time\n         */\n        public options: Partial<CarouselSlideParams> = {},\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class MarkVisibleAndActiveResult {\n\n    // Viewport range is subarray of slides which are\n    // currently in viewport\n    constructor(\n        public slides: CarouselSlide[],\n        public inViewportRangeStart: number,\n        public inViewportRangeEnd: number,\n    ) {\n    }\n\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CarouselSlideParams } from '../../../models/carousel-slide-params';\nimport { MarkVisibleAndActiveResult } from './models/mark-visible-and-active-result';\n\n/**\n * Returns cloned slides with modified `inViewport` and `isActive` fields\n */\nexport function markVisibleAndActive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    activeSlideIndex: number,\n    threshold: number,\n    alignMode: CarouselAlignMode,\n): MarkVisibleAndActiveResult {\n    if (!slides || !slides.length) {\n\n        return new MarkVisibleAndActiveResult([], 0, 0);\n    }\n\n    const newSlides: CarouselSlide[] = [];\n    /** Slide index representing first slide inside viewport */\n    let inViewportStart: number = null;\n    /** Slide index representing last slide inside viewport */\n    let inViewportEnd: number = null;\n    for (let i = 0, currentOffset = offset; i < slides.length; i++, currentOffset += slideWidth) {\n        // Calculate slide options\n        const slideBeforeViewportEnd = currentOffset < viewportWidth + threshold;\n        const slideAfterViewportStart = currentOffset + slideWidth + threshold > 0;\n        const inViewport = slideBeforeViewportEnd && slideAfterViewportStart;\n        const options: Partial<CarouselSlideParams> = {\n            inViewport,\n            isActive: i === activeSlideIndex,\n        };\n\n        // Construct new slide\n        const newSlide = new CarouselSlide(\n            slides[i].id,\n            slides[i].itemIndex,\n            Object.assign({}, slides[i].options, options),\n        );\n        newSlides.push(newSlide);\n\n        // Detect viewport range\n        if (inViewport && inViewportStart === null) {\n            inViewportStart = i;\n        } else if (!inViewport && inViewportStart !== null && inViewportEnd === null) {\n            inViewportEnd = Math.max(0, i - 1);\n        }\n    }\n\n    // Edge case when last slide was in viewport:\n    // in such case viewport end index won't be assigned\n    // inside slide cycle due to loop algorithm specifics\n    if (inViewportStart !== null && inViewportEnd === null) {\n        inViewportEnd = slides.length - 1;\n    }\n\n    if (activeSlideIndex >= 0 && activeSlideIndex <= slides.length - 1) { // Active slide might be outside slide range\n        if (activeSlideIndex <= inViewportStart || inViewportStart === null) {\n            const distanceToActiveSlideViewportStart = alignMode === CarouselAlignMode.LEFT\n                ? threshold\n                : viewportWidth / 2 - slideWidth / 2 + threshold;\n            const slidesToViewportStart = Math.ceil(distanceToActiveSlideViewportStart / slideWidth);\n            inViewportStart = Math.max(0, activeSlideIndex - slidesToViewportStart);\n        }\n        if (activeSlideIndex >= inViewportEnd || inViewportEnd === null) {\n            const distanceToActiveSlideViewportEnd = alignMode === CarouselAlignMode.LEFT\n                ? viewportWidth + threshold\n                : viewportWidth / 2 + slideWidth / 2 + threshold;\n            const slidesToViewportEnd = Math.ceil(distanceToActiveSlideViewportEnd / slideWidth);\n            inViewportEnd = Math.min(slides.length - 1, activeSlideIndex + slidesToViewportEnd);\n        }\n    }\n\n    const result = new MarkVisibleAndActiveResult(newSlides, inViewportStart || 0, inViewportEnd || 0);\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { markVisibleAndActive } from './mark-visible-and-active';\n\n/**\n * Assigns inViewport and isActive option to each slide\n */\nexport function markVisibleAndActiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        const result = markVisibleAndActive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.activeSlideIndex,\n            state.config.threshold,\n            state.config.alignMode,\n        );\n        state.slides = result.slides;\n        state.activeItemIndex = result.slides[state.activeSlideIndex]?.itemIndex ?? 0; // Undefined when no slides available\n        procedureState.inViewportRange = [result.inViewportRangeStart, result.inViewportRangeEnd];\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class RemoveExcessiveResult {\n    constructor(\n        public slides: CarouselSlide[],\n        public offset: number,\n    ) {\n    }\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { RemoveExcessiveResult } from './models/remove-excessive-result';\n\n/**\n * Removes slides that should not exist in carousel\n * (e.g. copies which are outside viewport)\n */\nexport function removeExcessive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    /** First slide index that is inside viewport */\n    viewportStart: number,\n    /** Last slide index that is inside viewport */\n    viewportEnd: number,\n): RemoveExcessiveResult {\n    if (!slides || !slides.length) {\n\n        return new RemoveExcessiveResult([], offset);\n    }\n    // Validate inputs\n    viewportStart = Math.max(0, Math.min(viewportStart, viewportEnd));\n    viewportEnd = Math.min(viewportStart, slides.length - 1);\n\n    const rightSlides: CarouselSlide[] = [];\n    const leftSlides: CarouselSlide[] = [];\n    const itemIndexes = new Set<number>();\n    let newOffset = offset;\n    // Next fancy loop traverses through slides array, but in specified order:\n    // first we travel through slides in viewport, so we can collect item ids,\n    // next we go through right and left side outside viewport, cleaning all\n    // found copies. Thus we can cleanse all copies in O(n)\n    for (let i = viewportStart; i <= viewportEnd; i++) {\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = viewportEnd + 1; i < slides.length; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = 0; i < viewportStart; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            newOffset += slideWidth;\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        leftSlides.push(slides[i]);\n    }\n\n    const newSlides = [\n        ...leftSlides,\n        ...rightSlides,\n    ];\n\n    return new RemoveExcessiveResult(newSlides, newOffset);\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { removeExcessive } from './remove-excessive';\n\n/**\n * Removes slide copies\n */\nexport function removeExcessiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        const result = removeExcessive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            procedureState.inViewportRange[0],\n            procedureState.inViewportRange[1],\n        );\n        state.slides = result.slides;\n        state.offset = result.offset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `moveOrCopySlidesTo`\n */\nexport class CopySlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n        /** Item indexes that should be marked as copy */\n        public unmarkedItemIndexes = [],\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `shuffleSlides`\n */\nexport class ShuffleSlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { CopySlidesResult } from './models/copy-slides-result';\nimport { ShuffleSlidesResult } from './models/shuffle-slides-result';\n\n/**\n * Justifies existing slides in viewport by either\n * - Move slide from one side to another\n * - Copy slide from one side to another\n * - Create slide on one side\n *\n * Task of this function is to leave no empty spaces in viewport.\n *\n * **BE ADVICED**, that inViewport flag should be calculated for each slide\n * that should not be moved beforehand.\n */\nexport function shuffleSlides(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    items: any[],\n    shouldLoop: boolean,\n    threshold: number = 0,\n    idGenerator = new IdGenerator(),\n): ShuffleSlidesResult {\n    if (!slides || !slides.length) {\n\n        return new ShuffleSlidesResult([], offset);\n    }\n    if (slideWidth <= 0 || !shouldLoop) {\n\n        return new ShuffleSlidesResult(slides, offset);\n    }\n\n    const slideSumWidth = slides.length * slideWidth;\n\n    // Calculate missing slides for left and right sides\n    const leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));\n    const rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));\n\n    // Let's start to fill missing slides\n\n    /**\n     * Item indexes that should be marked as copies after\n     * function completes\n     */\n    let unmarkedItemIndexes = [];\n\n    // Should move slides to right side\n    if (rightSideMissingSlides) {\n        const rightSideMoveResult = moveOrCopySlidesToEnd(\n            slides,\n            offset,\n            rightSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = rightSideMoveResult.slides;\n        offset = rightSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;\n    }\n\n    // Should move slides to left side\n    if (leftSideMissingSlides) {\n        const leftSideMoveResult = moveOrCopySlidesToStart(\n            slides,\n            offset,\n            leftSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = leftSideMoveResult.slides;\n        offset = leftSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);\n    }\n\n    const result = new ShuffleSlidesResult(slides, offset);\n\n    return result;\n}\n\n/**\n * Moves, copies or creates slides to the right side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the right part,\n * because we can't break sequence (meaning if we'll copy slide `5`\n * on the right to slide `3` on the left, they won't stack).\n * Slide `3` on the left awaits slide with item index `2` to be put\n * near him, so we should create some slides in between. This action\n * is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `5` and item index `3`?\n * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 1. Now we can start copy/move slides from the right part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move one slide from the right part, since\n * `quantity` after `Option FILL` equals 1. Lets imagine that slide\n * wasn't in viewport and now our slide row has\n * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!\n */\nexport function moveOrCopySlidesToEnd(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * We can't increase quantity if we encountered slide\n     * with inViewport flag\n     */\n    let canIncreaseQuantity = true;\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from left side for analyzing.\n     */\n    let slideIndex = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    // We going to iterate through item indexes starting from\n    // last slide item index. Let's pick an item index\n    // to start from.\n    const lastSlide = slides[slides.length - 1];\n    const lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = lastSlideHasLastItemIndex\n        ? 0\n        : lastSlide.itemIndex + 1;\n\n    for (let i = 0; i < quantity; i++) {\n        /**\n         * Having this field as true means slides from left and right\n         * side (including new slides) can stack and we can proceed to\n         * COPY option\n         */\n        const firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;\n\n        if (shouldCopy || firstSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Create new slide procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions\n            );\n            newSlides.push(newSlide);\n\n            // Splice arguments processing\n\n            if (currentSlide.options.inViewport) {\n                canIncreaseQuantity = false;\n            }\n\n            // We can't increase quantity if we have reached end of slides.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (canIncreaseQuantity && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n\n            // Prepare slide to process\n            slideIndex++;\n            if (slideIndex >= slides.length) {\n                slideIndex = 0;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Create new slide procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId++;\n        if (nextItemId >= items.length) {\n            nextItemId = 0;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        slides.splice(0, spliceQuantity);\n    }\n    const resultSlides = [\n        ...slides,\n        ...newSlides\n    ];\n    const resultOffset = offset + spliceQuantity * slideWidth;\n\n    return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);\n}\n\n/**\n * Moves, copies or creates slides to the left side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the left part,\n * because we can't break sequence (meaning if we'll copy slide `0`\n * on the right to slide `3` on the right, they won't stack).\n * Slide `3` on the right side awaits slide with item index `2` to be\n * put near him, so we should create some slides in between. This\n * action is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `0` and item index `3`?\n * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 2. Now we can start copy/move slides from the left part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move two slides from the left part, since\n * `quantity` after `Option FILL` equals 2. Lets imagine that slides\n * weren't in viewport and now our row has\n * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!\n */\nexport function moveOrCopySlidesToStart(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceFrom = null;\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from right side for analyzing.\n     */\n    let slideIndex = slides.length - 1;\n\n    // We going to iterate through item indexes starting from\n    // first slide item index. Let's pick an item index\n    // to start from.\n    const firstSlide = slides[0];\n    const firstSlideHasFirstItemId = firstSlide.itemIndex === 0;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = firstSlideHasFirstItemId\n        ? items.length - 1\n        : firstSlide.itemIndex - 1;\n\n    for (let i = 0; i < quantity; i++) {\n        const lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;\n\n        if (shouldCopy || lastSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Slide copy procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions,\n            );\n            newSlides.push(newSlide);\n\n            // Prepare next slide index\n            slideIndex--;\n            if (slideIndex < 0) {\n                slideIndex = slides.length - 1;\n            }\n\n            // Splice arguments processing\n\n            // spliceFrom can be assigned once and equals first inViewport\n            // slide that we met\n            if (spliceFrom === null && currentSlide.options.inViewport) {\n                spliceFrom = slides.length - spliceQuantity;\n            }\n\n            // We can't increase quantity if we have determined\n            // from where we should splice slides\n            const slideCopyNotEncountered = spliceFrom === null;\n            // We can't have splice quantity higher than slides size.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (slideCopyNotEncountered && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Slide copy procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId--;\n        if (nextItemId < 0) {\n            nextItemId = items.length - 1;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        spliceFrom = spliceFrom === null\n            ? slides.length - spliceQuantity\n            : spliceFrom;\n        slides.splice(spliceFrom, spliceQuantity);\n    }\n    const result = [\n        ...newSlides.reverse(),\n        ...slides,\n    ];\n\n    return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { shuffleSlides } from './shuffle-slides';\n\n/**\n * Moves slide from left side to right or vise versa\n * in order to balance weight or predict offset changes\n */\nexport function shuffleSlidesProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = shuffleSlides(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.config.items,\n            state.config.shouldLoop,\n            state.config.threshold,\n            environment?.slideIdGenerator ?? new IdGenerator(),\n        );\n        state.slides = result.slides;\n        state.activeSlideIndex = result.slides.findIndex((item: CarouselSlide) => item.options.isActive) || 0;\n        if (typeof procedureState.offsetSnapshot !== 'undefined') {\n            procedureState.offsetSnapshot = result.modifiedOffset - state.offset + procedureState.offsetSnapshot;\n        }\n        state.offset = result.modifiedOffset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { removeExcessiveProcedure } from '../helpers/remove-excessive/remove-excessive-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Cleans state from excessive slides and completes\n * corresponding duties after completed transition\n */\nexport function cleanupProcedure(): Procedure {\n    return procedurePipe('cleanup',\n        destroyAnimationProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        calculateActiveSlideProcedure(),\n        removeExcessiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n    );\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../../helpers/get-viewport-width-in-px/get-viewport-width-in-px';\n\n/** Converts passed distance to carousel width units */\nexport function normalizePassedDistanceProcedure(passedDistance: number): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.passedDistance = state.config.widthMode === CarouselWidthMode.PERCENT\n            ? 100 * passedDistance / getViewportWidthInPx(state)\n            : passedDistance;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { EasingFunction } from 'bezier-easing';\n\n/**\n * Calculates offset for animation specific tick\n */\nexport function animationOffsetSnapshot(\n    currentPosition: number,\n    totalDuration: number,\n    from: number,\n    to: number,\n    offsetFallback: number,\n    bezierFn: EasingFunction,\n): number {\n    if (typeof from === 'undefined' || typeof to === 'undefined') {\n\n        return offsetFallback;\n    }\n    if (totalDuration <= 0 || currentPosition < 0 || to === from) {\n\n        return to;\n    }\n    const animationDistance = Math.abs(to - from);\n    const completedDistancePercent = currentPosition / totalDuration;\n    const completedDistance = animationDistance * bezierFn(completedDistancePercent);\n    const offsetSnapshot = to > from\n        ? from + completedDistance\n        : from - completedDistance;\n\n    return offsetSnapshot;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { animationOffsetSnapshot } from './animation-offset-snapshot';\n\n/**\n * Assigns offset to state like if animation was paused.\n * If animation is not available, current offset will be assigned.\n */\nexport function animationOffsetSnapshotProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const time = new Date().getTime();\n        const currentPosition = time - (state.animation?.startTime ?? time);\n        const result = animationOffsetSnapshot(\n            currentPosition,\n            state.config.transitionDuration,\n            state.animation?.from,\n            state.animation?.to,\n            state.offset,\n            state.animationBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { AnimationPlayer } from '@angular/animations';\nimport { Subscription } from 'rxjs';\n\n/**\n * Animation state that is currently in process\n */\nexport class CarouselAnimation {\n\n    constructor(\n        public from: number,\n        public to: number,\n        public player?: AnimationPlayer,\n        public onDoneSubscription$?: Subscription,\n        public startTime = new Date().getTime(),\n    ) {\n    }\n\n}\n","import { animate, AnimationBuilder, style } from '@angular/animations';\nimport { bindCallback } from 'rxjs';\n\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselAnimation } from '../../../models/carousel-animation';\n\nexport function startAnimation(\n    container: HTMLElement,\n    from: number,\n    to: number,\n    widthMode: CarouselWidthMode,\n    transitionDuration: number,\n    bezierArgs: number[],\n    isBrowser: boolean,\n    afterAnimationAction: () => void,\n    animationBuilder: AnimationBuilder,\n): CarouselAnimation {\n    if (!isBrowser) {\n\n        return null;\n    }\n\n    const cubicBezier = `cubic-bezier(${bezierArgs[0]},${bezierArgs[1]},${bezierArgs[2]},${bezierArgs[3]})`;\n    const animationFactory = animationBuilder.build([\n        style({\n            transform: `translateX(${from}${widthMode})`,\n        }),\n        animate(`${transitionDuration}ms ${cubicBezier}`, style({\n            transform: `translateX(${to}${widthMode})`,\n        })),\n    ]);\n    const animationPlayer = animationFactory.create(container);\n    // Wrap onDone into observable\n    const boundFunction = bindCallback(animationPlayer.onDone); // Wrap function into function that returns observable\n    const onDone$ = boundFunction.call(animationPlayer); // Receive observable with context of animation player\n    const subscription$ = onDone$\n        .subscribe(() => {\n            animationPlayer.destroy();\n            afterAnimationAction();\n        });\n    const animation = new CarouselAnimation(\n        from,\n        to,\n        animationPlayer,\n        subscription$,\n    );\n    animationPlayer.play();\n\n    return animation;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { startAnimation } from './start-animation';\n\n/**\n * Creates new transition from one slide to another\n */\nexport function startAnimationProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const animation = startAnimation(\n            state.animatableContainer,\n            procedureState.offsetSnapshot,\n            state.offset,\n            state.config.widthMode,\n            state.config.transitionDuration,\n            environment?.animationBezierArgs ?? [],\n            environment?.isBrowser ?? false,\n            environment?.afterAnimationAction ?? (() => {}),\n            environment?.animationBuilder,\n        );\n        state.animation = animation;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Save offset to procedure state until later use\n */\nexport function setOffsetSnapshotProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.offsetSnapshot = state.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { startAnimationProcedure } from '../helpers/start-animation/start-animation-procedure';\nimport { setOffsetSnapshotProcedure } from './set-offset-snapshot/set-offset-snapshot-procedure';\n\n/**\n * Calculates corresponding parts for current active slide\n */\nexport function setSlideIndexProcedure(): Procedure {\n    return procedurePipe('setSlideIndex',\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        setOffsetSnapshotProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        shuffleSlidesProcedure(),\n        startAnimationProcedure(),\n    );\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { normalizePassedDistanceProcedure } from './normalize-passed-distance/normalize-passed-distance-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Calculates state after user finish drag event\n */\nexport function dragEndProcedure(passedDistance: number): Procedure {\n    return procedurePipe('dragEnd',\n        enableAutoplayProcedure(AutoplaySuspender.DRAG),\n        normalizePassedDistanceProcedure(passedDistance),\n        calculateActiveSlideProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\n\n/**\n * Return new offset modified by last drag operations.\n * Applies overscroll behavior when necessary.\n *\n * @returns modified offset\n */\nexport function dragOffsetSnapshot(\n    /** X position in pixels from where drag event began */\n    fromX: number,\n    /** destination X in pixels of last fired drag event */\n    toX: number,\n    currentOffset: number,\n    widthMode: CarouselWidthMode,\n    alignMode: CarouselAlignMode,\n    shouldLoop: boolean,\n    viewportWidth: number,\n    viewportWidthInPx: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    /** How much in percents user can overscroll unlooped carousel */\n    maxOverscrollPercent: number,\n    bezierFn: EasingFunction,\n    invertedBezierFn: EasingFunction,\n): number {\n    if (fromX === toX) {\n\n        return currentOffset;\n    }\n\n    // Normalize all pixel values to current width mode\n    if (widthMode === CarouselWidthMode.PERCENT) {\n        fromX = fromX * 100 / viewportWidthInPx;\n        toX = toX * 100 / viewportWidthInPx;\n    }\n\n    let offsetDelta = toX - fromX;\n\n    // 1st case: no bezier amendments, just return offset with applied delta\n    if (shouldLoop) {\n\n        return currentOffset + offsetDelta;\n    }\n\n    const overscrollStartPoint = detectOverscrollStartPoint(\n        fromX,\n        currentOffset,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        alignMode,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n\n    // 2nd case where bezier correction haven't started yet,\n    // meaning we're in safe zone at both side\n    if (overscrollStartPoint === null) {\n        const offsetFromSafeZone = applyDeltaFromSafeZone(\n            currentOffset,\n            offsetDelta,\n            alignMode,\n            viewportWidth,\n            slideWidth,\n            slideSumWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n\n        return offsetFromSafeZone;\n    }\n\n    // Seems like we already at overscroll zone, so let's see\n    // the ways we could manage that\n\n    /** Whether drag was performed from overscroll zone to same overscroll zone */\n    const dragStaysInSameOverscrollZone = fromX > overscrollStartPoint\n        ? toX > overscrollStartPoint\n        : toX < overscrollStartPoint;\n\n    // 3rd case: we should not amend when drag pointer is still in overscroll zone\n    // after applying delta\n    if (dragStaysInSameOverscrollZone) {\n        const distanceBefore = fromX - overscrollStartPoint;\n        const distanceAfter = toX - overscrollStartPoint;\n        const distance = distanceBetween(\n            distanceBefore,\n            distanceAfter,\n            viewportWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n        currentOffset = currentOffset - distance;\n\n        return currentOffset;\n    }\n\n    // 4th case where drag pointer has returned to safe zone.\n    // We should do the same calculation like we did in 2nd case.\n    const overscrollDistance = applyDeltaFromOverscrollZone(\n        overscrollStartPoint - fromX,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distancetoSafeZone = overscrollStartPoint - fromX;\n    currentOffset += overscrollDistance;\n    fromX = overscrollStartPoint;\n    offsetDelta -= distancetoSafeZone;\n\n    const result = applyDeltaFromSafeZone(\n        currentOffset,\n        offsetDelta,\n        alignMode,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n\n    return result;\n}\n\n/**\n * Applies bezier on distance and limit with max overscroll distance\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromOverscrollZone(\n    distance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    /** Viewport % from 0 to 1 of delta distance */\n    const deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));\n    /** Maximal distance of overscroll in pixels */\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    /**\n     * How much delta is actually long when applying bezier\n     * and aligning overscroll max distance\n     */\n    const deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);\n\n    return deltaDistance;\n}\n\n/**\n * Applies delta to current offset which is currently in safe zone at this moment.\n * Applies bezier whether delta intersects overscroll zone.\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromSafeZone(\n    currentOffset: number,\n    offsetDelta: number,\n    alignMode: CarouselAlignMode,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(viewportWidth, slideSumWidth);\n    /** Whether left side of carousel is in viewport after applying delta */\n    const leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;\n    /** Whether right side of carousel is in viewport after applying delta */\n    const rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;\n\n    const canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)\n        || (!rightSideExposedAfter && offsetDelta < 0);\n\n    if (canSafelyTransit) {\n        // We're still safe on both sides, just apply delta\n\n        return currentOffset + offsetDelta;\n    }\n\n    /**\n     * Distance between current offset and point\n     * where overscroll begins\n     */\n    let distanceToSafeZone = 0;\n    // Move offset to the point where overscroll begins\n    if (leftSideExposedAfter) {\n        distanceToSafeZone = currentOffset - leftmostPoint;\n    } else if (rightSideExposedAfter) {\n        distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;\n    }\n\n    /**\n     * Distance between current offset and\n     * overscroll zone starting point\n     */\n    const distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;\n    currentOffset -= distanceToSafeZone;\n\n    const overscrollDelta = applyDeltaFromOverscrollZone(\n        distanceWithoutSafeZone,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    currentOffset += overscrollDelta;\n\n    return currentOffset;\n}\n\n/**\n * Returns point where overscroll should potentially start\n * or null if carousel is currently in safe zone.\n */\nfunction detectOverscrollStartPoint(\n    fromX: number,\n    currentOffset: number,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    alignMode: CarouselAlignMode,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number | null {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(leftmostPoint + slideSumWidth, viewportWidth);\n\n    /** Distance from current offset to safe zone */\n    let overscrollConvertedDistance: number | null = null;\n    // Special case when left-aligned carousel is lesser than viewport width\n    if (alignMode === CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {\n        overscrollConvertedDistance = currentOffset;\n    } else if (currentOffset > leftmostPoint) {\n        overscrollConvertedDistance = currentOffset - leftmostPoint;\n    } else if (currentOffset < rightmostPoint - slideSumWidth) {\n        overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;\n    }\n    if (overscrollConvertedDistance === null) {\n\n        return null;\n    }\n    const overscrollRealDistance = extractDeltaFromOverscrollZone(\n        overscrollConvertedDistance,\n        viewportWidth,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n    const overscrollStartPoint = fromX - overscrollRealDistance;\n\n    return overscrollStartPoint;\n}\n\n/**\n * Converts distance with bezier applied to distance\n * without bezier\n */\nfunction extractDeltaFromOverscrollZone(\n    convertedDistance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number {\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    const bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);\n    const deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);\n\n    return deltaPercentage;\n}\n\n/**\n * Calculates overscroll distance between two points\n */\nfunction distanceBetween(\n    firstPoint: number,\n    secondPoint: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const overscrollBefore = applyDeltaFromOverscrollZone(\n        firstPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const overscrollAfter = applyDeltaFromOverscrollZone(\n        secondPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distance = overscrollBefore - overscrollAfter;\n\n    return distance;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { dragOffsetSnapshot } from './drag-offset-snapshot';\n\n/**\n * Assigns offset to state by given distance coordinates\n */\nexport function dragOffsetSnapshotProcedure(fromX: number, toX: number): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = dragOffsetSnapshot(\n            fromX,\n            toX,\n            state.offset,\n            state.config.widthMode,\n            state.config.alignMode,\n            state.config.shouldLoop,\n            getViewportWidth(state),\n            getViewportWidthInPx(state),\n            state.config.slideWidth,\n            state.slides.length * state.config.slideWidth,\n            environment.maxOverscroll,\n            state.dragBezierFn,\n            state.invertedDragBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class BreakWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = true;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: ProcedureCarouselState = null,\n    ) {\n    }\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure whether drag is disabled\n */\nexport function postponeDragEnabledProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (state?.config?.dragEnabled) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { dragOffsetSnapshotProcedure } from '../helpers/drag-offset/drag-offset-snapshot-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state after single tick of drag event\n */\nexport function dragProcedure(fromX: number, toX: number): Procedure {\n    return procedurePipe('drag',\n        postponeDragEnabledProcedure(),\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        dragOffsetSnapshotProcedure(fromX, toX),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n        markVisibleAndActiveProcedure(),\n    );\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { disableAutoplayProcedure } from '../helpers/disable-autoplay/disable-autoplay-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state when drag event starts\n */\nexport function dragStartProcedure(): Procedure {\n    return procedurePipe('dragStart',\n        postponeDragEnabledProcedure(),\n        disableAutoplayProcedure(AutoplaySuspender.DRAG),\n    );\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IterateSideResult } from './models/iterate-side-result';\n\n/**\n * Finds slide that is marked as `isActive` and returns its index\n */\nexport function findSlideIndex(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): number {\n    if (!slides) {\n\n        return 0;\n    }\n    const currentActiveSlide = slides[currentSlideIndex];\n    if (!currentActiveSlide) {\n\n        return 0;\n    }\n    const currentItemIndex = currentActiveSlide.itemIndex;\n    let targetSlideIndex: IterateSideResult | null = null;\n    if (newItemIndex === currentItemIndex || slides.length <= 1) {\n\n        return currentSlideIndex;\n    } else if (newItemIndex > currentItemIndex) {\n        targetSlideIndex =\n            iterateRightSide(slides, newItemIndex, currentSlideIndex)\n            || iterateLeftSide(slides, newItemIndex, currentSlideIndex);\n    } else {\n        targetSlideIndex =\n            iterateLeftSide(slides, newItemIndex, currentSlideIndex)\n            || iterateRightSide(slides, newItemIndex, currentSlideIndex);\n    }\n\n    return targetSlideIndex?.foundIndex ?? null;\n}\n\nfunction iterateRightSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex + 1; i < slides.length; i++) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n\nfunction iterateLeftSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex - 1; i >= 0; i--) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { findSlideIndex } from './find-slide-index';\n\n/**\n * Assigns slide index by given item index\n */\nexport function findSlideIndexProcedure(itemIndex?: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = findSlideIndex(\n            state.slides,\n            itemIndex ?? state.activeItemIndex,\n            state.activeSlideIndex,\n        );\n        state.activeSlideIndex = result;\n        state.activeItemIndex = itemIndex;\n\n        return new ContinueWith(state);\n    };\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Guard for assigning item index when no slides are available.\n * Would break procedure on such occasion.\n */\nexport function postponeItemIndexProcedure(newItemIndex: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.slides || !state.slides.length) {\n            state.postponedItemIndex = newItemIndex;\n\n            return new BreakWith(state);\n        }\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { findSlideIndexProcedure } from '../helpers/find-slide-index/find-slide-index-procedure';\nimport { postponeItemIndexProcedure } from './postpone-item-index/postpone-item-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/** Assigns item index and shuffles slides accordingly */\nexport function goToProcedure(newItemIndex: number): Procedure {\n    return procedurePipe('goTo',\n        postponeItemIndexProcedure(newItemIndex),\n        enableAutoplayProcedure(),\n        findSlideIndexProcedure(newItemIndex),\n        setSlideIndexProcedure(),\n    );\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\n\n/**\n * Fills empty carousel with slides without any\n * alignments\n */\nexport function initializeCarousel(\n    items: any[],\n    idGenerator: IdGenerator,\n): CarouselSlide[] {\n    if (!items || !items.length || !idGenerator) {\n\n        return [];\n    }\n\n    const newSlides = new Array(items.length);\n\n    for (let i = 0; i < items.length; i++) {\n        newSlides[i] = new CarouselSlide(idGenerator.next(), i, {item: items[i], isActive: i === 0});\n    }\n\n    return newSlides;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { initializeCarousel } from './initialize-carousel';\n\n/**\n * Creates new slide set from scratch\n */\nexport function initializeCarouselProcedure(): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = initializeCarousel(\n            state.config.items,\n            environment.slideIdGenerator,\n        );\n        state.slides = result;\n        state.offset = 0;\n        state.activeSlideIndex = 0;\n\n        return new ContinueWith(state);\n    };\n}\n","import { InitializationState } from '../../../models/initialization-state';\nimport { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure when carousel is not ready\n * for first initialization\n */\nexport function postponeInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const phase = state?.initializationState ?? new InitializationState();\n        if (phase.configInitialized && phase.viewportWidthInitialized) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import bezier from 'bezier-easing';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n// Reference: https://easings.net/ru\n// Standard ease\nexport const ANIMATION_BEZIER_ARGS = [0.25, 0.1, 0.25, 1];\n// Ease out quad\nconst DRAG_BEZIER_ARGS = [0.25, 0.46, 0.45, 0.94];\n\n/**\n * Creates bezier functions for different purposes\n */\nexport function setBeziersProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.dragBezierFn) {\n            state.dragBezierFn = bezier(\n                DRAG_BEZIER_ARGS[0],\n                DRAG_BEZIER_ARGS[1],\n                DRAG_BEZIER_ARGS[2],\n                DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.invertedDragBezierFn) {\n            state.invertedDragBezierFn = bezier(\n                1 - DRAG_BEZIER_ARGS[0],\n                1 - DRAG_BEZIER_ARGS[1],\n                1 - DRAG_BEZIER_ARGS[2],\n                1 - DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.animationBezierFn) {\n            state.animationBezierFn = bezier(\n                ANIMATION_BEZIER_ARGS[0],\n                ANIMATION_BEZIER_ARGS[1],\n                ANIMATION_BEZIER_ARGS[2],\n                ANIMATION_BEZIER_ARGS[3],\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Set state as initialized\n */\nexport function setFirstInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.initializationState.firstInitalization = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\nexport function removePostponedIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade) => {\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ComposedProcedure } from '../../../models/procedure/composed-procedure.type';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { procedurePipe } from '../../../models/procedure/procedure-pipe';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { goToProcedure } from '../go-to-procedure';\nimport { removePostponedIndexProcedure } from '../remove-postponed-index/remove-postponed-index-procedure';\n\n/**\n * Saves freshly selected item index till later\n * until carousel is initialized\n */\nexport function setPostponedIndexProcedure(): ComposedProcedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler | Procedure => {\n        if (state.slides.length && state.postponedItemIndex) {\n            const itemIndex = state.postponedItemIndex;\n\n            return procedurePipe('setPostponedIndex',\n                goToProcedure(itemIndex),\n                removePostponedIndexProcedure(),\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { initializeCarouselProcedure } from '../helpers/initialize-carousel/initialize-carousel-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeInitializationProcedure } from './postpone-initialization/postpone-initialization-procedure';\nimport { setBeziersProcedure } from './set-beziers/set-beziers-procedure';\nimport { setFirstInitializationProcedure } from './set-first-initalization/set-first-initialization-procedure';\nimport { setPostponedIndexProcedure } from './set-postponed-index/set-postponed-index-procedure';\n\n/**\n * Creates slides from scratch\n */\nexport function initializeProcedure(): Procedure {\n    return procedurePipe('initialize',\n        postponeInitializationProcedure(),\n\n        setFirstInitializationProcedure(),\n        initializeCarouselProcedure(),\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        destroyAnimationProcedure(),\n        enableAutoplayProcedure(),\n        calculateActiveSlideProcedure(),\n        setBeziersProcedure(),\n\n        setPostponedIndexProcedure(),\n    );\n}\n","import { CarouselConfig } from '../../../../carousel-config';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns carousel config, works as part of multiphase carousel initialization\n */\nexport function setConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.config = newConfig;\n        state.initializationState.configInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselConfig } from '../../../carousel-config';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setConfigProcedure } from './set-config/set-config-procedure';\n\n/**\n * Assigns config and executes initialization effects\n */\nexport function initializeConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return procedurePipe('initializeConfig',\n        setConfigProcedure(newConfig),\n        initializeProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Saves DOM element containers for carousel as part of initialization phase\n */\nexport function setContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.widthContainer = widthContainer;\n        state.animatableContainer = animatableContainer;\n        state.initializationState.viewportWidthInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setContainersProcedure } from './set-containers/set-containers-procedure';\n\n/**\n * Assigns specified DOM containers to carousel state\n */\nexport function initializeContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return procedurePipe('initializeContainers',\n        setContainersProcedure(widthContainer, animatableContainer),\n        initializeProcedure(),\n    );\n}\n","/**\n * Returns next slide index as if user\n * clicked \"next\" button\n */\nexport function getNextIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex + 1;\n    if (newIndex >= slidesLength) {\n        newIndex = shouldLoop\n            ? 0\n            : slidesLength - 1;\n    }\n\n    return newIndex;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getNextIndex } from './get-next-index';\n\n/**\n * Increments current item index\n */\nexport function getNextIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getNextIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getNextIndexProcedure } from '../helpers/get-next-index/get-next-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Increments current slide\n */\nexport function nextProcedure(omitAutoplayReset = false): Procedure {\n    return procedurePipe('next',\n        omitAutoplayReset ? enableAutoplayProcedure() : null,\n        getNextIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","/**\n * Returns previous slide index as if user\n * clicked \"prev\" button\n */\nexport function getPrevIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex - 1;\n    if (newIndex < 0) {\n        newIndex = shouldLoop\n            ? slidesLength - 1\n            : 0;\n    }\n\n    return newIndex;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getPrevIndex } from './get-prev-index';\n\n/**\n * Decrements current item index\n */\nexport function getPrevIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getPrevIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getPrevIndexProcedure } from '../helpers/get-prev-index/get-prev-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Decrements current slide\n */\nexport function prevProcedure(): Procedure {\n    return procedurePipe('prev',\n        enableAutoplayProcedure(),\n        getPrevIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Programmaticaly recalculates current state\n */\nexport function recalculateProcedure(): Procedure {\n    return procedurePipe('recalculate',\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n    );\n}\n","import { TemplateRef } from '@angular/core';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns TemplateRef where slides would be rendered\n */\nexport function setTemplateProcedure(template: TemplateRef<any> | null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.template = template;\n\n        return new ContinueWith(state);\n    };\n}\n","import { AnimationBuilder } from '@angular/animations';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, OnDestroy, PLATFORM_ID, TemplateRef } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselState } from '../models/carousel-state';\nimport { IdGenerator } from '../models/id-generator';\nimport { ProcedureEnvironment } from '../models/procedure/procedure-environment.interface';\nimport { procedurePipe } from '../models/procedure/procedure-pipe';\nimport { Procedure } from '../models/procedure/procedure.type';\nimport { SLIDE_ID_GENERATOR } from '../tokens';\nimport { disableAutoplayProcedure } from './helpers/disable-autoplay/disable-autoplay-procedure';\nimport { enableAutoplayProcedure } from './helpers/enable-autoplay/enable-autoplay-procedure';\nimport { cleanupProcedure } from './procedures/cleanup-procedure';\nimport { dragEndProcedure } from './procedures/drag-end-procedure';\nimport { dragProcedure } from './procedures/drag-procedure';\nimport { dragStartProcedure } from './procedures/drag-start-procedure';\nimport { goToProcedure } from './procedures/go-to-procedure';\nimport { initializeConfigProcedure } from './procedures/initialize-config-procedure';\nimport { initializeContainersProcedure } from './procedures/initialize-containers-procedure';\nimport { nextProcedure } from './procedures/next-procedure';\nimport { prevProcedure } from './procedures/prev-procedure';\nimport { recalculateProcedure } from './procedures/recalculate-procedure';\nimport { ANIMATION_BEZIER_ARGS } from './procedures/set-beziers/set-beziers-procedure';\nimport { setTemplateProcedure } from './procedures/set-template/set-template-procedure';\n\n/**\n * Short swipe might not change slide to next/prev.\n * This const specifies how much (% of viewport) swipe\n * should overcome to trigger next/prev slide change.\n */\nconst MAX_SWIPE_THRESHOLD = 15;\n/**\n * How much % user can stretch carousel, when there's no more\n * drag available\n */\nconst MAX_OVERSCROLL = 10;\n\n@Injectable()\nexport class CarouselService implements OnDestroy {\n\n    private readonly carouselState$ = new BehaviorSubject<CarouselState>(new CarouselState());\n    /** Describes constant entities for procedures */\n    private readonly procedureEnvironment: ProcedureEnvironment = {\n        slideIdGenerator: this.slideIdGenerator,\n        isBrowser: isPlatformBrowser(this.platformId),\n        autoplayAction: this.next.bind(this),\n        afterAnimationAction: this.cleanup.bind(this),\n        animationBuilder: this.animationBuilder,\n        animationBezierArgs: ANIMATION_BEZIER_ARGS,\n        swipeThreshold: MAX_SWIPE_THRESHOLD,\n        maxOverscroll: MAX_OVERSCROLL,\n    };\n\n    constructor(\n        private animationBuilder: AnimationBuilder,\n        @Inject(SLIDE_ID_GENERATOR) private slideIdGenerator: IdGenerator,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnDestroy(): void {\n        this.carouselState$.getValue()?.autoplay?.autoplaySubscription?.unsubscribe();\n    }\n\n    carouselStateChanges(): Observable<CarouselState> {\n        return this.carouselState$.asObservable();\n    }\n\n    setItemIndex(newItemIndex: number): void {\n        this.apply(goToProcedure(newItemIndex));\n    }\n\n    prev(): void {\n        this.apply(prevProcedure());\n    }\n\n    /**\n     * @param omitAutoplayReset whether autoplay timer should not be resetted\n     */\n    next(omitAutoplayReset = false): void {\n        this.apply(nextProcedure(omitAutoplayReset));\n    }\n\n    recalculate(): void {\n        this.apply(recalculateProcedure());\n    }\n\n    /** Update state to announce that drag sequence just started */\n    dragStart(): void {\n        this.apply(dragStartProcedure());\n    }\n\n    /**\n     * Update state to announce that drag sequence just ended\n     * and perform necessary cleanups\n     */\n    dragEnd(passedDistance: number): void {\n        this.apply(dragEndProcedure(passedDistance));\n    }\n\n    /** Process single drag tick with given from and to coordinates */\n    drag(fromX: number, toX: number): void {\n        this.apply(dragProcedure(fromX, toX));\n    }\n\n    setSlideTemplate(newTemplateRef: TemplateRef<any> | null): void {\n        this.apply(setTemplateProcedure(newTemplateRef));\n    }\n\n    disableAutoplay(suspender: AutoplaySuspender): void {\n        this.apply(disableAutoplayProcedure(suspender));\n    }\n\n    /**\n     * Starts new autoplay timer\n     */\n    enableAutoplay(suspender: AutoplaySuspender = null): void {\n        this.apply(enableAutoplayProcedure(suspender));\n    }\n\n    setContainers(widthContainer: HTMLElement, animatableContainer: HTMLElement): void {\n        this.apply(initializeContainersProcedure(widthContainer, animatableContainer));\n    }\n\n    setConfig(newConfig: CarouselConfig): void {\n        this.apply(initializeConfigProcedure(newConfig));\n    }\n\n    private cleanup(): void {\n        this.apply(cleanupProcedure());\n    }\n\n    /**\n     * Applies specified procedure to carousel state\n     */\n    private apply(procedure: Procedure): void {\n        const state: CarouselState = Object.assign({}, this.carouselState$.getValue());\n        const result = procedurePipe('applier', procedure)({state, procedureState: {}, environment: this.procedureEnvironment});\n        this.carouselState$.next(result.state);\n    }\n}\n","import { ChangeDetectionStrategy, Component, ContentChild, Input, Output, ViewEncapsulation } from '@angular/core';\nimport { map } from 'rxjs/operators';\n\nimport { CarouselConfig } from './carousel-config';\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselState } from './private/models/carousel-state';\nimport { IdGenerator } from './private/models/id-generator';\nimport { CarouselService } from './private/service/carousel.service';\nimport { ANIMATION_ID_GENERATOR, SLIDE_ID_GENERATOR } from './private/tokens';\n\nexport function idGeneratorFactory(): IdGenerator {\n    return new IdGenerator();\n}\n\n@Component({\n    selector: 'ng-carousel',\n    templateUrl: 'carousel.component.html',\n    styleUrls: ['carousel.component.scss'],\n    providers: [\n        CarouselService,\n        {\n            provide: SLIDE_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n        {\n            provide: ANIMATION_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n    ],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    exportAs: 'ngCarousel',\n})\n/**\n * Defines carousel API to work with\n */\nexport class CarouselComponent {\n\n    @ContentChild(CarouselSlideDirective) set slideRef(newSlideRef: CarouselSlideDirective) {\n        this.carousel.setSlideTemplate(newSlideRef\n            ? newSlideRef.templateRef\n            : null\n        );\n    }\n\n    @Input() set config(newConfig: CarouselConfig) {\n        newConfig = new CarouselConfig(newConfig);\n        this.carousel.setConfig(newConfig);\n    }\n\n    @Output() itemIndexChange = this.carousel.carouselStateChanges()\n        .pipe(\n            map((state: CarouselState) => state.activeItemIndex),\n        );\n\n    constructor(\n        private carousel: CarouselService,\n    ) {\n    }\n\n    next(): void {\n        this.carousel.next();\n    }\n\n    prev(): void {\n        this.carousel.prev();\n    }\n\n    setIndex(newIndex: number): void {\n        this.carousel.setItemIndex(newIndex);\n    }\n\n    /**\n     * Programmaticaly recalculates carousel position in case of\n     * container size changes or other size interactions\n     */\n    recalculate(): void {\n        this.carousel.recalculate();\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, isDevMode, PLATFORM_ID } from '@angular/core';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class HammerProviderService {\n\n    private hammerAbsenceDeclared = false;\n\n    constructor(\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    public managerFor(element: HTMLElement): HammerManager | null {\n        const hasGestures = isPlatformBrowser(this.platformId) && (window as any).Hammer;\n        if (!hasGestures) {\n            if (isDevMode() && !this.hammerAbsenceDeclared) {\n                console.warn(\n                    'Ng-carousel could not listen to drag, because HammerJS was not found. Either disable drag or import HammerJS.'\n                );\n                this.hammerAbsenceDeclared = true;\n            }\n\n            return null;\n        }\n        const hammerManager = new Hammer(element);\n\n        return hammerManager;\n    }\n}\n","import { Directive, ElementRef, HostListener, OnDestroy, OnInit } from '@angular/core';\nimport { asyncScheduler } from 'rxjs';\n\nimport { HammerProviderService } from './private/service/hammer-provider.service';\n\n@Directive({\n    selector: '[ngCarouselPreventGhostClick]',\n})\nexport class PreventGhostClickDirective implements OnInit, OnDestroy {\n\n    private hammerManager: HammerManager;\n    private shouldPreventClick = false;\n\n    @HostListener('click', ['$event'])\n    private processClickEvent(event: Event): void {\n        if (this.shouldPreventClick) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n        }\n    }\n\n    constructor(\n        private elementRef: ElementRef,\n        private hammer: HammerProviderService,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenPanEndEvents();\n    }\n\n    ngOnDestroy() {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private listenPanEndEvents(): void {\n        this.hammerManager = this.hammer.managerFor(this.elementRef.nativeElement);\n        if (!this.hammerManager) {\n\n            return;\n        }\n        this.hammerManager.on('panend pancancel', () => {\n            this.shouldPreventClick = true;\n            asyncScheduler.schedule(() => {\n                this.shouldPreventClick = false;\n            });\n        });\n    }\n\n}\n","import { CdkTrapFocus, InteractivityChecker } from '@angular/cdk/a11y';\nimport { AfterViewInit, Directive, ElementRef, Input, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\n\n@Directive({\n    selector: '[untabbable]',\n})\n/**\n * Applies tabindex=-1 for interactive elements inside container\n */\nexport class FocusBlockDirective implements OnChanges, AfterViewInit, OnDestroy {\n\n    @Input() untabbable = false;\n    @Input() untabbableFocusTrapRef: CdkTrapFocus;\n    /** Whether focus inside carousel */\n    @Input() untabbableFocused = false;\n\n    private readonly lastTabindexValueMap = new Map<HTMLElement, string | null>();\n    private viewInitiated: boolean;\n    private mutationObserver: MutationObserver;\n\n    constructor(\n        private elementRef: ElementRef,\n        private interactivityChecker: InteractivityChecker,\n    ) {\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (changes.untabbable && this.viewInitiated) {\n            const change = changes.untabbable;\n            if (change.currentValue === change.previousValue) {\n\n                return;\n            }\n            change.currentValue\n                ? this.blockTabindex()\n                : this.unblockTabindex();\n            if (this.untabbableFocused && this.untabbableFocusTrapRef) {\n                this.untabbableFocusTrapRef.focusTrap.focusFirstTabbableElement();\n            }\n        }\n    }\n\n    ngAfterViewInit() {\n        this.viewInitiated = true;\n        this.untabbable\n            ? this.blockTabindex()\n            : this.unblockTabindex();\n    }\n\n    ngOnDestroy() {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n    }\n\n    private blockTabindex(): void {\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.blockElement(element);\n        }\n        if (typeof window !== 'undefined' && 'MutationObserver' in window) {\n            this.mutationObserver = new MutationObserver(\n                (mutationList: MutationRecord[]) => {\n                    const changesArray = Array.from(mutationList);\n                    for (const change of changesArray) {\n                        if (change.type === 'attributes') {\n                            this.blockElement(change.target as HTMLElement);\n                        } else if (change.type === 'childList') {\n                            change.addedNodes.forEach((element: Node) => {\n                                this.blockElement(element as HTMLElement);\n                            });\n                        }\n                    }\n                }\n            );\n            this.mutationObserver.observe(this.elementRef.nativeElement, {\n                attributeFilter: ['tabindex'],\n                attributes: true,\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n\n    private unblockTabindex(): void {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.unblockElement(element);\n        }\n    }\n\n    private blockElement(element: HTMLElement): void {\n        // nodeType is text node, should not be blocked\n        if (element.nodeType !== 3 && this.interactivityChecker.isFocusable(element) && this.interactivityChecker.isTabbable(element)) {\n            const currentTabindexValue = element.getAttribute('tabindex');\n            this.lastTabindexValueMap.set(element, currentTabindexValue);\n            if (currentTabindexValue !== '-1') {\n                element.setAttribute('tabindex', '-1');\n            }\n        }\n    }\n\n    private unblockElement(element: HTMLElement): void {\n        if (this.lastTabindexValueMap.has(element) && typeof this.lastTabindexValueMap.get(element) === 'number') {\n            element.setAttribute('tabindex', this.lastTabindexValueMap.get(element));\n        } else {\n            element.removeAttribute('tabindex');\n        }\n    }\n}\n","/**\n * Template context for carousel slide\n */\nexport class CarouselSlideContext {\n\n    constructor(\n        public $implicit: any,\n        public itemIndex: number,\n        public isActive: boolean,\n        public inViewport: boolean,\n    ) {\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, ElementRef, Inject, OnDestroy, OnInit, PLATFORM_ID, Renderer2, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { fromEvent, Observable, Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMapTo, takeUntil } from 'rxjs/operators';\n\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselSlide } from '../models/carousel-slide';\nimport { CarouselSlideContext } from '../models/carousel-slide-context';\nimport { CarouselState } from '../models/carousel-state';\nimport { CarouselService } from '../service/carousel.service';\nimport { HammerProviderService } from '../service/hammer-provider.service';\n\n@Component({\n  selector: 'carousel-engine',\n  templateUrl: './carousel-engine.component.html',\n  styleUrls: ['./carousel-engine.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\n/**\n * Contains listeners and other DOM controllers\n */\nexport class CarouselEngineComponent implements OnInit, OnDestroy {\n\n    @ViewChild('galleryRef', {static: true}) galleryRef: ElementRef;\n    public readonly transformValue$ = this.transformValueChanges();\n    public readonly slideWidth$ = this.slideWidthChanges();\n    public readonly template$ = this.templateChanges();\n    public readonly slides$ = this.slidesChanges();\n    public focused = false;\n    private readonly destroyed$ = new Subject<void>();\n    private mouseEnterDestructor: () => void;\n    private mouseLeaveDestructor: () => void;\n    private keyboardListener: () => void;\n    private containerScrollListener: () => void;\n    private hammerManager: HammerManager;\n\n    private get htmlElement(): HTMLElement {\n        return this.elementRef.nativeElement;\n    }\n\n    constructor(\n        private carousel: CarouselService,\n        private elementRef: ElementRef,\n        private renderer: Renderer2,\n        private hammer: HammerProviderService,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenToAutoplay();\n        this.listenToDragEvents();\n        this.listenToResizeEvents();\n        this.listenToKeyEvents();\n        this.listenToScrollEvents();\n        this.carousel.setContainers(this.htmlElement, this.galleryRef.nativeElement);\n    }\n\n    ngOnDestroy() {\n        this.destroyMouseListeners();\n        this.destroyHammer();\n        this.destroyKeyboardListeners();\n        this.destroyElementScrollListener();\n        this.destroyed$.next();\n        this.destroyed$.complete();\n    }\n\n    trackByFn(index: number, item: CarouselSlide): number {\n        return item.id;\n    }\n\n    contextOf(slide: CarouselSlide): CarouselSlideContext {\n        return new CarouselSlideContext(\n            slide.options.item,\n            slide.itemIndex,\n            slide.options.isActive,\n            slide.options.inViewport,\n        );\n    }\n\n    focusIn(): void {\n        this.focused = true;\n        this.carousel.disableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    focusOut(): void {\n        this.focused = false;\n        this.carousel.enableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    private destroyMouseListeners(): void {\n        if (this.mouseEnterDestructor) {\n            this.mouseEnterDestructor();\n        }\n        if (this.mouseLeaveDestructor) {\n            this.mouseLeaveDestructor();\n        }\n    }\n\n    private destroyHammer(): void {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private destroyKeyboardListeners(): void {\n        if (this.keyboardListener) {\n            this.keyboardListener();\n        }\n    }\n\n    private destroyElementScrollListener(): void {\n        if (this.containerScrollListener) {\n            this.containerScrollListener();\n        }\n    }\n\n    private transformValueChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `translateX(${state.offset}${state.config.widthMode})`),\n            );\n    }\n\n    private slideWidthChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `${state.config.slideWidth}${state.config.widthMode}`),\n            );\n    }\n\n    private slidesChanges(): Observable<CarouselSlide[]> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.slides),\n            );\n    }\n\n    private templateChanges(): Observable<TemplateRef<any>> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.template),\n            );\n    }\n\n    private listenToAutoplay(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.autoplayEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((autoplayEnabled: boolean) => {\n                if (this.mouseEnterDestructor) {\n                    this.mouseEnterDestructor();\n                }\n                if (this.mouseLeaveDestructor) {\n                    this.mouseLeaveDestructor();\n                }\n                if (!autoplayEnabled) {\n\n                    return;\n                }\n                this.mouseEnterDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseenter',\n                    () => this.carousel.disableAutoplay(AutoplaySuspender.MOUSE),\n                );\n                this.mouseLeaveDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseleave',\n                    () => this.carousel.enableAutoplay(AutoplaySuspender.MOUSE),\n                );\n            });\n    }\n\n    private listenToDragEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.dragEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((dragEnabled: boolean) => {\n                if (this.hammerManager) {\n                    this.hammerManager.destroy();\n                }\n                if (!dragEnabled) {\n\n                    return;\n                }\n                this.hammerManager = this.hammer.managerFor(this.htmlElement);\n                if (!this.hammerManager) {\n\n                    return;\n                }\n                let lastDelta = 0;\n                let lastTouchAction: string;\n\n                this.hammerManager.on('panstart', (event: HammerInput) => {\n                    // Checking whether pan started with horizontal gesture,\n                    // we should block all scroll attempts during current pan session then\n                    // tslint:disable-next-line: no-bitwise\n                    if (event.offsetDirection & Hammer.DIRECTION_HORIZONTAL) {\n                        lastDelta = Math.round(event.deltaX);\n                        this.carousel.dragStart();\n                        lastTouchAction = this.htmlElement.style.touchAction;\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', 'none');\n                    }\n                });\n\n                this.hammerManager.on('panright panleft', (event: HammerInput) => {\n                    // We should not treat vertical pans as horizontal.\n                    // Be adviced that pan right/left events still counts\n                    // vertical pans as legitimate horizontal pan.\n\n                    // Next check clarifies that initial gesture was horizontal,\n                    // otherwise this variable would be falsy\n                    if (lastTouchAction) {\n                        const x = Math.round(event.center.x);\n                        const deltaX = Math.round(event.deltaX);\n                        this.carousel.drag(x, x + (deltaX - lastDelta));\n                        lastDelta = deltaX;\n                    }\n                });\n\n                this.hammerManager.on('panend pancancel', (event: HammerInput) => {\n                    if (lastTouchAction) {\n                        this.carousel.dragEnd(event.deltaX);\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', lastTouchAction);\n                        lastTouchAction = null;\n                    }\n                });\n            });\n    }\n\n    private listenToResizeEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                filter((state: CarouselState) => state.config.shouldRecalculateOnResize),\n                switchMapTo(fromEvent(window, 'resize')),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe(() => {\n                this.carousel.recalculate();\n            });\n    }\n\n    private listenToKeyEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.keyboardListener = this.renderer.listen(\n            this.htmlElement,\n            'keydown',\n            (event: KeyboardEvent) => {\n                const key = event.key.toLowerCase();\n                if (['arrowright', 'right'].includes(key)) {\n                    this.carousel.next();\n                } else if (['arrowleft', 'left'].includes(key)) {\n                    this.carousel.prev();\n                }\n            }\n        );\n    }\n\n    /**\n     * Horizontal scroll might accidentaly happen on parent container\n     * when pressing arrow buttons too fast. We should return\n     * container to initial position when that happens.\n     */\n    private listenToScrollEvents(): void {\n        this.containerScrollListener = this.renderer.listen(this.htmlElement, 'scroll', () => {\n            this.htmlElement.scrollTo(0, 0);\n        });\n    }\n}\n","import { A11yModule } from '@angular/cdk/a11y';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselComponent } from './carousel.component';\nimport { PreventGhostClickDirective } from './prevent-ghost-click.directive';\nimport { FocusBlockDirective } from './private/directives/untabbable.directive';\nimport { CarouselEngineComponent } from './private/views/carousel-engine.component';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        A11yModule,\n    ],\n    declarations: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        CarouselEngineComponent,\n        FocusBlockDirective,\n        PreventGhostClickDirective,\n    ],\n    exports: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        PreventGhostClickDirective,\n    ],\n})\nexport class CarouselModule { }\n","/*\n * Public API Surface of ng-carousel\n */\n\nexport * from './lib/carousel.component';\nexport * from './lib/carousel.module';\nexport * from './lib/carousel-config';\nexport * from './lib/carousel-width-mode';\nexport * from './lib/carousel-align-mode';\nexport * from './lib/carousel-slide.directive';\nexport * from './lib/prevent-ghost-click.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {FocusBlockDirective as ɵg} from './lib/private/directives/untabbable.directive';\nexport {IdGenerator as ɵa} from './lib/private/models/id-generator';\nexport {CarouselService as ɵb} from './lib/private/service/carousel.service';\nexport {HammerProviderService as ɵf} from './lib/private/service/hammer-provider.service';\nexport {ANIMATION_ID_GENERATOR as ɵd,SLIDE_ID_GENERATOR as ɵc} from './lib/private/tokens';\nexport {CarouselEngineComponent as ɵe} from './lib/private/views/carousel-engine.component';"],"names":[],"mappings":"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"}