import { Directive, TemplateRef, InjectionToken, Injectable, Inject, PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, ContentChild, Input, Output, isDevMode, ɵɵdefineInjectable, ɵɵinject, ElementRef, HostListener, Renderer2, ViewChild, NgModule } from '@angular/core';
import { map, distinctUntilChanged, takeUntil, filter, switchMapTo } from 'rxjs/operators';
import { style, animate, AnimationBuilder } from '@angular/animations';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { interval, bindCallback, BehaviorSubject, asyncScheduler, Subject, fromEvent } from 'rxjs';
import bezier from 'bezier-easing';
import { InteractivityChecker, A11yModule } from '@angular/cdk/a11y';

/**
 * Represents how carousel calculates slide width. Be adviced
 * that actual enum value is used in code, so change with caution.
 */
var CarouselWidthMode;
(function (CarouselWidthMode) {
    /**
     * When pixel management is provided, carousel calculates
     * slide width with pixels. Preferred to use in limited space
     * where carousel width is more or less is predefined.
     */
    CarouselWidthMode["PX"] = "px";
    /**
     * When percent management is provided, carousel calculates
     * slide width with relative instrument (via percents). Preferred
     * to use in full-width carousel, where carousel width is unknown.
     */
    CarouselWidthMode["PERCENT"] = "%";
})(CarouselWidthMode || (CarouselWidthMode = {}));

var CarouselAlignMode;
(function (CarouselAlignMode) {
    /**
     * Active slide is always centered in carousel viewport
     */
    CarouselAlignMode["CENTER"] = "center";
    /**
     * Active slide left border sticks to left border of
     * carousel
     */
    CarouselAlignMode["LEFT"] = "left";
})(CarouselAlignMode || (CarouselAlignMode = {}));

class CarouselConfig {
    constructor(config) {
        /**
         * Array of data to display
         */
        this.items = [];
        /**
         * Describes how carousel calculates its content width.
         * Consult with corresponding enum to see what options
         * are available.
         */
        this.widthMode = CarouselWidthMode.PERCENT;
        /**
         * Slide width. It could be pixels or percents, based on mode
         * configuration.
         */
        this.slideWidth = 100;
        /**
         * Describes how slides should be positioned relative to
         * carousel viewport
         */
        this.alignMode = CarouselAlignMode.CENTER;
        /**
         * Whether autoplay is enabled
         */
        this.autoplayEnabled = true;
        /**
         * Time in ms of how long carousel would wait until automatic
         * slide increment. Respects `autoplayEnabled` value.
         */
        this.autoplayDelay = 6000;
        /**
         * Whether mouse drag or gesture panning enabled
         */
        this.dragEnabled = true;
        /**
         * Whether carousel should start from beginning after last
         * slide
         */
        this.shouldLoop = true;
        /**
         * Time in ms of how long transition between slides would last
         */
        this.transitionDuration = 280;
        /**
         * Whether carousel should automatically recalculate on window resize.
         * This option is recommended when using pixel width mode or left
         * alignment.
         */
        this.shouldRecalculateOnResize = true;
        /**
         * Value in current width mode units which are virtally added to both sides
         * of viewport. Slides within this virtual zone should always be presented
         * whether loop mode is on.
         */
        this.threshold = 5;
        // @TODO nullish coalescing here
        this.items = config && config.items || [];
        this.widthMode = config && config.widthMode || CarouselWidthMode.PERCENT;
        this.alignMode = config && config.alignMode || CarouselAlignMode.CENTER;
        this.slideWidth = config && typeof config.slideWidth === 'number'
            ? config.slideWidth
            : 100;
        this.autoplayEnabled = config && typeof config.autoplayEnabled === 'boolean'
            ? config.autoplayEnabled
            : true;
        this.autoplayDelay = config && typeof config.autoplayDelay === 'number'
            ? config.autoplayDelay
            : 6000;
        this.dragEnabled = config && typeof config.dragEnabled === 'boolean'
            ? config.dragEnabled
            : true;
        this.shouldLoop = config && typeof config.shouldLoop === 'boolean'
            ? config.shouldLoop
            : true;
        this.transitionDuration = config && typeof config.transitionDuration === 'number'
            ? config.transitionDuration
            : 600;
        this.shouldRecalculateOnResize = config && typeof config.shouldRecalculateOnResize === 'boolean'
            ? config.shouldRecalculateOnResize
            : true;
    }
}

class CarouselSlideDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
CarouselSlideDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngCarouselSlide]',
            },] }
];
CarouselSlideDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Generator for `CarouselSlide` id, should be
 * singleton throughout single carousel.
 */
class IdGenerator {
    constructor() {
        this.index = 0;
    }
    next() {
        return this.index++;
    }
}

/**
 * Autoplay state of current autoplay timer
 */
class CarouselAutoplay {
    constructor() {
        this.autoplaySuspenders = new Set();
        this.autoplaySubscription = null;
        this.interval = null;
    }
}

/**
 * Since we don't want excessive slide recalculation
 * while main inputs are still on their way, we should
 * collect them and then initialize carousel when
 * everything is ready.
 */
class InitializationState {
    constructor() {
        this.configInitialized = false;
        this.viewportWidthInitialized = false;
        /** Whether slides were created for the first time */
        this.firstInitalization = false;
    }
}

/**
 * Carousel state snapshot. Config is stored here
 * as well as other vital values like offset or
 * active slide index.
 */
class CarouselState {
    constructor(state) {
        /**
         * Container to measure gallery width. Type is HTMLElement but
         * reduced for the ease of testing.
         */
        this.widthContainer = null;
        /** Container that should be animated during index change */
        this.animatableContainer = null;
        /** Client-side config which regulates carousel behavior */
        this.config = new CarouselConfig();
        this.activeSlideIndex = 0;
        /** Item index of config's items array */
        this.activeItemIndex = 0;
        this.template = null;
        /** X position of leftmost carousel slide */
        this.offset = 0;
        this.slides = [];
        /** State of multiphase initialization */
        this.initializationState = new InitializationState();
        /** Currently played animation */
        this.animation = null;
        this.autoplay = new CarouselAutoplay();
        if (state) {
            Object.assign(this, state);
        }
    }
}

class ProcedureError extends Error {
    constructor(error) {
        super();
        this.message = error.message;
        this.stack = error.stack;
    }
}

/** Organizes array of procedures into single procedure, flattens inner procedures */
function procedurePipe(procedureName, ...args) {
    return (state, parentProcedureName) => {
        var _a, _b;
        let handler;
        let procedureIndex = 0;
        for (const procedure of args) {
            if (typeof procedure !== 'function') {
                continue;
            }
            const procedureState = Object.entries((_a = handler === null || handler === void 0 ? void 0 : handler.procedureState) !== null && _a !== void 0 ? _a : {}).length
                ? handler.procedureState
                : state.procedureState;
            const nextState = {
                state: (_b = handler === null || handler === void 0 ? void 0 : handler.state) !== null && _b !== void 0 ? _b : state.state,
                procedureState: procedureState || {},
                environment: state.environment,
            };
            const procedureSlot = `${procedureName}[${procedureIndex}]`;
            const procedureChainString = parentProcedureName
                ? `${parentProcedureName}->${procedureSlot}`
                : procedureSlot;
            let localHandler;
            while (typeof localHandler === 'function' || !localHandler) {
                try {
                    localHandler = !localHandler
                        ? procedure(nextState, procedureChainString)
                        : localHandler(nextState, procedureChainString);
                }
                catch (e) {
                    if (!(e instanceof ProcedureError)) {
                        console.error(`Procedure interrupted at ${procedureChainString}`);
                    }
                    throw new ProcedureError(e);
                }
            }
            handler = localHandler;
            procedureIndex++;
            if (handler.shouldBreakProcedure) {
                break;
            }
        }
        return handler;
    };
}

const SLIDE_ID_GENERATOR = new InjectionToken('slideIdGenerator');
const ANIMATION_ID_GENERATOR = new InjectionToken('slideIdGenerator');

class ContinueWith {
    constructor(state, procedureState = {}) {
        this.state = state;
        this.procedureState = procedureState;
        this.shouldBreakProcedure = false;
    }
}

/** Stops autoplay timer, provides side effect for provided autoplay */
function disableAutoplay(suspender, autoplay = new CarouselAutoplay()) {
    var _a;
    (_a = autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplaySubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    if (!autoplay.autoplaySuspenders) {
        autoplay.autoplaySuspenders = new Set();
    }
    autoplay.autoplaySuspenders.add(suspender);
    return autoplay;
}

/**
 * Turns current autoplay timer off with a specified reason
 */
function disableAutoplayProcedure(suspender = null) {
    return ({ state }) => {
        state = Object.assign({}, state);
        const autoplay = disableAutoplay(suspender, state.autoplay);
        state.autoplay = autoplay;
        return new ContinueWith(state);
    };
}

/** Starts carousel autoplay whether one is enabled */
function enableAutoplay(autoplayEnabled, transitionDuration, autoplayDelay, isBrowser, autoplayAction, suspender, autoplay) {
    var _a;
    if (!autoplay) {
        autoplay = new CarouselAutoplay();
    }
    (_a = autoplay.autoplaySubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    if (!autoplay.autoplaySuspenders) {
        autoplay.autoplaySuspenders = new Set();
    }
    if (suspender) {
        autoplay.autoplaySuspenders.delete(suspender);
    }
    if (autoplayEnabled && !autoplay.autoplaySuspenders.size && isBrowser) {
        // Delay can't be smaller than transition itself in order to avoid endless animation
        autoplay.interval = Math.max(transitionDuration, autoplayDelay);
        autoplay.autoplaySubscription = interval(autoplay.interval).subscribe(autoplayAction);
    }
    return autoplay;
}

/**
 * Enables autoplay when such option is available in config
 */
function enableAutoplayProcedure(suspender = null) {
    return ({ state, environment }) => {
        var _a, _b;
        state = Object.assign({}, state);
        const autoplay = enableAutoplay(state.config.autoplayEnabled, state.config.transitionDuration, state.config.autoplayDelay, (_a = environment === null || environment === void 0 ? void 0 : environment.isBrowser) !== null && _a !== void 0 ? _a : false, (_b = environment === null || environment === void 0 ? void 0 : environment.autoplayAction) !== null && _b !== void 0 ? _b : (() => { }), suspender, state.autoplay);
        state.autoplay = autoplay;
        return new ContinueWith(state);
    };
}

/**
 * Width of carousel element in pixels. Try to call this as little as
 * possible, since getting this value triggers layout thrashing.
 */
function getViewportWidthInPx(state) {
    var _a, _b;
    return (_b = (_a = state === null || state === void 0 ? void 0 : state.widthContainer) === null || _a === void 0 ? void 0 : _a.offsetWidth) !== null && _b !== void 0 ? _b : 100;
}

/**
 * Width of carousel element in current width mode.
 * Try to call this as little as possible, since getting this value
 * triggers layout thrashing.
 */
function getViewportWidth(state) {
    var _a;
    return ((_a = state === null || state === void 0 ? void 0 : state.config) === null || _a === void 0 ? void 0 : _a.widthMode) === CarouselWidthMode.PX
        ? getViewportWidthInPx(state)
        : 100;
}

/**
 * Result for helper function `calculateActiveSlide`
 */
class CalculateActiveSlideResult {
    constructor(modifiedOffset = 0, slideIndex = 0) {
        this.modifiedOffset = modifiedOffset;
        this.slideIndex = slideIndex;
    }
}

/**
 * Based on current whereabouts, returns most possible
 * active slide candidate and proposed offset for it
 */
function calculateActiveSlide(slides, offset, alignMode, slideWidth, viewportWidth, swipeThresholdPercent, 
/** Distance (whether in px or %) that is aligned to carousel width mode */
swipeDistance = null) {
    const result = new CalculateActiveSlideResult(offset, 0);
    // Noop run if nothing to calculate
    if (!slides.length || slideWidth <= 0) {
        return result;
    }
    const slidesSumWidth = slideWidth * slides.length;
    // By given align mode, width mode and viewport width, calculate
    // carousel center position
    const carouselCenter = alignMode === CarouselAlignMode.LEFT
        ? 0
        : viewportWidth / 2;
    // Slide center is not always its left side. On such occasion we should
    // correct its offset using specified align mode.
    const slideRightAmendment = alignMode === CarouselAlignMode.LEFT
        ? slideWidth
        : slideWidth / 2;
    const slideLeftAmendment = alignMode === CarouselAlignMode.LEFT
        ? 0
        : slideRightAmendment;
    // Preset if slides far behind carousel center
    if (offset + slidesSumWidth < carouselCenter) {
        result.slideIndex = slides.length - 1;
        result.modifiedOffset = carouselCenter - slidesSumWidth + slideRightAmendment;
        // Preset if slides far away from carousel center
    }
    else if (offset - slideLeftAmendment > carouselCenter) {
        result.slideIndex = 0;
        result.modifiedOffset = carouselCenter - slideLeftAmendment;
        // Any other cases (when slides intersect carousel center)
    }
    else {
        result.slideIndex = Math.floor(Math.abs(carouselCenter - offset) / slideWidth);
        result.modifiedOffset = carouselCenter - result.slideIndex * slideWidth - slideLeftAmendment;
    }
    // Swipe correction: animation must align with swipe direction meaning
    // when user swipes right, final animation should also lead to the right
    const swipeDirection = Math.sign(swipeDistance);
    const offsetDirection = offset > result.modifiedOffset
        ? -1
        : 1;
    const shouldApplySwipeAlignment = swipeDistance !== null
        && swipeThresholdPercent !== null
        && Math.abs(swipeDistance) > Math.abs(swipeThresholdPercent)
        && swipeDirection !== offsetDirection;
    if (shouldApplySwipeAlignment) {
        const appliedSwipeAlignment = result.slideIndex - swipeDirection;
        const newSlideIndex = Math.min(Math.max(0, appliedSwipeAlignment), slides.length - 1);
        if (newSlideIndex !== result.slideIndex) {
            result.slideIndex = newSlideIndex;
            result.modifiedOffset += swipeDirection * slideWidth;
        }
    }
    return result;
}

/**
 * Given current slide state, assigns active slide
 */
function calculateActiveSlideProcedure() {
    return ({ state, procedureState, environment }) => {
        var _a, _b;
        const result = calculateActiveSlide(state.slides, state.offset, state.config.alignMode, state.config.slideWidth, getViewportWidth(state), Math.min(state.config.slideWidth / 2, environment.swipeThreshold), procedureState.passedDistance || null);
        state.activeSlideIndex = result.slideIndex;
        state.activeItemIndex = (_b = (_a = state.slides[result.slideIndex]) === null || _a === void 0 ? void 0 : _a.itemIndex) !== null && _b !== void 0 ? _b : 0;
        return new ContinueWith(state);
    };
}

class CalculateOffsetResult {
    constructor(offset) {
        this.offset = offset;
    }
}

/**
 * Calculates offset by specified arguments as if current slide was centered
 */
function calculateOffset(currentSlideIndex, alignMode, slideWidth, viewportWidth, slideQuantity, shouldLoop) {
    const activeSlideLeftPosition = alignMode === CarouselAlignMode.CENTER
        ? (viewportWidth - slideWidth) / 2
        : 0;
    const slidesSumWidth = slideWidth * slideQuantity;
    let newOffset = activeSlideLeftPosition - (slideWidth * currentSlideIndex);
    // Edge case amendment for left-aligned non-looped slides:
    // non-looped slides might have their right or left edge visible
    // so we might amend offset for some situations
    if (!shouldLoop && alignMode === CarouselAlignMode.LEFT) {
        // Calculate prequesites
        const rightmostPoint = newOffset + slidesSumWidth;
        const allSlidesVisible = slidesSumWidth <= viewportWidth;
        // Apply offset amendment
        if (!allSlidesVisible && rightmostPoint <= viewportWidth) {
            // Left aligned slides with their right edge visible:
            // righmost slide edge should stick to the right viewport edge
            newOffset = viewportWidth - slidesSumWidth;
        }
        else if (allSlidesVisible) {
            // Left aligned slides which are all visible:
            // just stick them to the left viewport edge
            newOffset = 0;
        }
    }
    const result = new CalculateOffsetResult(Math.round(newOffset));
    return result;
}

/**
 * Given current slide state, assigns carousel offset
 */
function calculateOffsetProcedure() {
    return ({ state, procedureState }) => {
        state = Object.assign({}, state);
        const result = calculateOffset(state.activeSlideIndex, state.config.alignMode, state.config.slideWidth, getViewportWidth(state), state.slides.length, state.config.shouldLoop);
        state.offset = result.offset;
        return new ContinueWith(state, procedureState);
    };
}

/**
 * Destroys animation player without callback
 */
function destroyAnimation(animation) {
    var _a, _b, _c;
    try {
        (_a = animation === null || animation === void 0 ? void 0 : animation.player) === null || _a === void 0 ? void 0 : _a.finish();
        (_b = animation === null || animation === void 0 ? void 0 : animation.player) === null || _b === void 0 ? void 0 : _b.destroy();
        // Ignore exception since player might be already destroyed
        // at this moment
    }
    catch (e) { }
    (_c = animation === null || animation === void 0 ? void 0 : animation.onDoneSubscription$) === null || _c === void 0 ? void 0 : _c.unsubscribe();
}

/**
 * Destroys and removes any ongoing animation state
 */
function destroyAnimationProcedure() {
    return ({ state }) => {
        destroyAnimation(state.animation);
        state.animation = null;
        return new ContinueWith(state);
    };
}

/**
 * Slide model representation
 */
class CarouselSlide {
    constructor(
    /**
     * Id is used in trackBy and should be generated
     * with `IdGenerator`
     */
    id, 
    /**
     * Represents index from `items` array of carousel
     * config
     */
    itemIndex, 
    /**
     * Parameters that might be changed over time
     */
    options = {}) {
        this.id = id;
        this.itemIndex = itemIndex;
        this.options = options;
    }
}

class MarkVisibleAndActiveResult {
    // Viewport range is subarray of slides which are
    // currently in viewport
    constructor(slides, inViewportRangeStart, inViewportRangeEnd) {
        this.slides = slides;
        this.inViewportRangeStart = inViewportRangeStart;
        this.inViewportRangeEnd = inViewportRangeEnd;
    }
}

/**
 * Returns cloned slides with modified `inViewport` and `isActive` fields
 */
function markVisibleAndActive(slides, offset, slideWidth, viewportWidth, activeSlideIndex, threshold, alignMode) {
    if (!slides || !slides.length) {
        return new MarkVisibleAndActiveResult([], 0, 0);
    }
    const newSlides = [];
    /** Slide index representing first slide inside viewport */
    let inViewportStart = null;
    /** Slide index representing last slide inside viewport */
    let inViewportEnd = null;
    for (let i = 0, currentOffset = offset; i < slides.length; i++, currentOffset += slideWidth) {
        // Calculate slide options
        const slideBeforeViewportEnd = currentOffset < viewportWidth + threshold;
        const slideAfterViewportStart = currentOffset + slideWidth + threshold > 0;
        const inViewport = slideBeforeViewportEnd && slideAfterViewportStart;
        const options = {
            inViewport,
            isActive: i === activeSlideIndex,
        };
        // Construct new slide
        const newSlide = new CarouselSlide(slides[i].id, slides[i].itemIndex, Object.assign({}, slides[i].options, options));
        newSlides.push(newSlide);
        // Detect viewport range
        if (inViewport && inViewportStart === null) {
            inViewportStart = i;
        }
        else if (!inViewport && inViewportStart !== null && inViewportEnd === null) {
            inViewportEnd = Math.max(0, i - 1);
        }
    }
    // Edge case when last slide was in viewport:
    // in such case viewport end index won't be assigned
    // inside slide cycle due to loop algorithm specifics
    if (inViewportStart !== null && inViewportEnd === null) {
        inViewportEnd = slides.length - 1;
    }
    if (activeSlideIndex >= 0 && activeSlideIndex <= slides.length - 1) { // Active slide might be outside slide range
        if (activeSlideIndex <= inViewportStart || inViewportStart === null) {
            const distanceToActiveSlideViewportStart = alignMode === CarouselAlignMode.LEFT
                ? threshold
                : viewportWidth / 2 - slideWidth / 2 + threshold;
            const slidesToViewportStart = Math.ceil(distanceToActiveSlideViewportStart / slideWidth);
            inViewportStart = Math.max(0, activeSlideIndex - slidesToViewportStart);
        }
        if (activeSlideIndex >= inViewportEnd || inViewportEnd === null) {
            const distanceToActiveSlideViewportEnd = alignMode === CarouselAlignMode.LEFT
                ? viewportWidth + threshold
                : viewportWidth / 2 + slideWidth / 2 + threshold;
            const slidesToViewportEnd = Math.ceil(distanceToActiveSlideViewportEnd / slideWidth);
            inViewportEnd = Math.min(slides.length - 1, activeSlideIndex + slidesToViewportEnd);
        }
    }
    const result = new MarkVisibleAndActiveResult(newSlides, inViewportStart || 0, inViewportEnd || 0);
    return result;
}

/**
 * Assigns inViewport and isActive option to each slide
 */
function markVisibleAndActiveProcedure() {
    return ({ state, procedureState }) => {
        var _a, _b;
        const result = markVisibleAndActive(state.slides, state.offset, state.config.slideWidth, getViewportWidth(state), state.activeSlideIndex, state.config.threshold, state.config.alignMode);
        state.slides = result.slides;
        state.activeItemIndex = (_b = (_a = result.slides[state.activeSlideIndex]) === null || _a === void 0 ? void 0 : _a.itemIndex) !== null && _b !== void 0 ? _b : 0; // Undefined when no slides available
        procedureState.inViewportRange = [result.inViewportRangeStart, result.inViewportRangeEnd];
        return new ContinueWith(state, procedureState);
    };
}

class RemoveExcessiveResult {
    constructor(slides, offset) {
        this.slides = slides;
        this.offset = offset;
    }
}

/**
 * Removes slides that should not exist in carousel
 * (e.g. copies which are outside viewport)
 */
function removeExcessive(slides, offset, slideWidth, 
/** First slide index that is inside viewport */
viewportStart, 
/** Last slide index that is inside viewport */
viewportEnd) {
    if (!slides || !slides.length) {
        return new RemoveExcessiveResult([], offset);
    }
    // Validate inputs
    viewportStart = Math.max(0, Math.min(viewportStart, viewportEnd));
    viewportEnd = Math.min(viewportStart, slides.length - 1);
    const rightSlides = [];
    const leftSlides = [];
    const itemIndexes = new Set();
    let newOffset = offset;
    // Next fancy loop traverses through slides array, but in specified order:
    // first we travel through slides in viewport, so we can collect item ids,
    // next we go through right and left side outside viewport, cleaning all
    // found copies. Thus we can cleanse all copies in O(n)
    for (let i = viewportStart; i <= viewportEnd; i++) {
        itemIndexes.add(slides[i].itemIndex);
        rightSlides.push(slides[i]);
    }
    for (let i = viewportEnd + 1; i < slides.length; i++) {
        if (itemIndexes.has(slides[i].itemIndex)) {
            continue;
        }
        itemIndexes.add(slides[i].itemIndex);
        rightSlides.push(slides[i]);
    }
    for (let i = 0; i < viewportStart; i++) {
        if (itemIndexes.has(slides[i].itemIndex)) {
            newOffset += slideWidth;
            continue;
        }
        itemIndexes.add(slides[i].itemIndex);
        leftSlides.push(slides[i]);
    }
    const newSlides = [
        ...leftSlides,
        ...rightSlides,
    ];
    return new RemoveExcessiveResult(newSlides, newOffset);
}

/**
 * Removes slide copies
 */
function removeExcessiveProcedure() {
    return ({ state, procedureState }) => {
        const result = removeExcessive(state.slides, state.offset, state.config.slideWidth, procedureState.inViewportRange[0], procedureState.inViewportRange[1]);
        state.slides = result.slides;
        state.offset = result.offset;
        return new ContinueWith(state);
    };
}

/**
 * Result for helper function `moveOrCopySlidesTo`
 */
class CopySlidesResult {
    constructor(slides = [], modifiedOffset = 0, 
    /** Item indexes that should be marked as copy */
    unmarkedItemIndexes = []) {
        this.slides = slides;
        this.modifiedOffset = modifiedOffset;
        this.unmarkedItemIndexes = unmarkedItemIndexes;
    }
}

/**
 * Result for helper function `shuffleSlides`
 */
class ShuffleSlidesResult {
    constructor(slides = [], modifiedOffset = 0) {
        this.slides = slides;
        this.modifiedOffset = modifiedOffset;
    }
}

/**
 * Justifies existing slides in viewport by either
 * - Move slide from one side to another
 * - Copy slide from one side to another
 * - Create slide on one side
 *
 * Task of this function is to leave no empty spaces in viewport.
 *
 * **BE ADVICED**, that inViewport flag should be calculated for each slide
 * that should not be moved beforehand.
 */
function shuffleSlides(slides, offset, slideWidth, viewportWidth, items, shouldLoop, threshold = 0, idGenerator = new IdGenerator()) {
    if (!slides || !slides.length) {
        return new ShuffleSlidesResult([], offset);
    }
    if (slideWidth <= 0 || !shouldLoop) {
        return new ShuffleSlidesResult(slides, offset);
    }
    const slideSumWidth = slides.length * slideWidth;
    // Calculate missing slides for left and right sides
    const leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));
    const rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));
    // Let's start to fill missing slides
    /**
     * Item indexes that should be marked as copies after
     * function completes
     */
    let unmarkedItemIndexes = [];
    // Should move slides to right side
    if (rightSideMissingSlides) {
        const rightSideMoveResult = moveOrCopySlidesToEnd(slides, offset, rightSideMissingSlides, slideWidth, items, idGenerator);
        slides = rightSideMoveResult.slides;
        offset = rightSideMoveResult.modifiedOffset;
        unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;
    }
    // Should move slides to left side
    if (leftSideMissingSlides) {
        const leftSideMoveResult = moveOrCopySlidesToStart(slides, offset, leftSideMissingSlides, slideWidth, items, idGenerator);
        slides = leftSideMoveResult.slides;
        offset = leftSideMoveResult.modifiedOffset;
        unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);
    }
    const result = new ShuffleSlidesResult(slides, offset);
    return result;
}
/**
 * Moves, copies or creates slides to the right side in order to fill
 * desired `quantity`.
 *
 * Quantity means of how much new slides will be added.
 * There are two options of how we could fill missing slides.
 * Imagine next slides row mapped to their item index:
 * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.
 * We can't just start to move/copy slides from the right part,
 * because we can't break sequence (meaning if we'll copy slide `5`
 * on the right to slide `3` on the left, they won't stack).
 * Slide `3` on the left awaits slide with item index `2` to be put
 * near him, so we should create some slides in between. This action
 * is named `Option FILL GAP`.
 *
 * `Option FILL GAP`:
 * How much slides are in between item index `5` and item index `3`?
 * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides
 * and subtract their length from `quantity`.
 * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
 * equals 1. Now we can start copy/move slides from the right part.
 * This action is called `Option COPY`
 *
 * `Option COPY`:
 * When meddling with slides from the other side, we have two options
 * of what to do with them: either copy or move. Slide can be moved
 * when it is not `inViewport`, meaning it has corresponding option
 * flag. Otherwise it should be copied.
 * In our example we should move one slide from the right part, since
 * `quantity` after `Option FILL` equals 1. Lets imagine that slide
 * wasn't in viewport and now our slide row has
 * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!
 */
function moveOrCopySlidesToEnd(slides, offset, quantity, slideWidth, items, idGenerator = new IdGenerator()) {
    if (quantity < 1) {
        return new CopySlidesResult(slides, offset, []);
    }
    const newSlides = [];
    /** Item indexes that should be marked as copies later */
    const unmarkedItemIndexes = [];
    /** Used as argument for splice call later */
    let spliceQuantity = 0;
    /**
     * We can't increase quantity if we encountered slide
     * with inViewport flag
     */
    let canIncreaseQuantity = true;
    /**
     * Iterator index, used in COPY option. Determines which
     * slide should be picked from left side for analyzing.
     */
    let slideIndex = 0;
    /**
     * Once we finished with option FILL GAP, then
     * copy option should take place
     */
    let shouldCopy = false;
    // We going to iterate through item indexes starting from
    // last slide item index. Let's pick an item index
    // to start from.
    const lastSlide = slides[slides.length - 1];
    const lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;
    /**
     * Iterator index, used in FILL GAP and COPY options.
     * This index determines which item will next slide have.
     */
    let nextItemId = lastSlideHasLastItemIndex
        ? 0
        : lastSlide.itemIndex + 1;
    for (let i = 0; i < quantity; i++) {
        /**
         * Having this field as true means slides from left and right
         * side (including new slides) can stack and we can proceed to
         * COPY option
         */
        const firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;
        if (shouldCopy || firstSlideHasNextItemId) {
            // Option COPY
            shouldCopy = true;
            const currentSlide = slides[slideIndex];
            // Create new slide procedure
            const newOptions = Object.assign({}, currentSlide.options);
            // There should be an already existing isActive slide,
            // so we turning isActive off for copy
            newOptions.isActive = false;
            // Every filled item is considered to be in viewport,
            // because why else would we call this function
            // otherwise? To fill viewport obviously.
            newOptions.inViewport = true;
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
            newSlides.push(newSlide);
            // Splice arguments processing
            if (currentSlide.options.inViewport) {
                canIncreaseQuantity = false;
            }
            // We can't increase quantity if we have reached end of slides.
            // It happens when quantity from argument is higher than
            // slides size.
            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
            if (canIncreaseQuantity && canIncrementSpliceQuantity) {
                spliceQuantity++;
            }
            // Prepare slide to process
            slideIndex++;
            if (slideIndex >= slides.length) {
                slideIndex = 0;
            }
        }
        else {
            // Option FILL GAP
            // Create new slide procedure
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                inViewport: true,
                item: items[nextItemId],
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                isActive: false,
            });
            newSlides.push(newSlide);
            unmarkedItemIndexes.push(nextItemId);
        }
        // Pick index for next item
        nextItemId++;
        if (nextItemId >= items.length) {
            nextItemId = 0;
        }
    }
    if (spliceQuantity > 0) {
        slides.splice(0, spliceQuantity);
    }
    const resultSlides = [
        ...slides,
        ...newSlides
    ];
    const resultOffset = offset + spliceQuantity * slideWidth;
    return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);
}
/**
 * Moves, copies or creates slides to the left side in order to fill
 * desired `quantity`.
 *
 * Quantity means of how much new slides will be added.
 * There are two options of how we could fill missing slides.
 * Imagine next slides row mapped to their item index:
 * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.
 * We can't just start to move/copy slides from the left part,
 * because we can't break sequence (meaning if we'll copy slide `0`
 * on the right to slide `3` on the right, they won't stack).
 * Slide `3` on the right side awaits slide with item index `2` to be
 * put near him, so we should create some slides in between. This
 * action is named `Option FILL GAP`.
 *
 * `Option FILL GAP`:
 * How much slides are in between item index `0` and item index `3`?
 * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides
 * and subtract their length from `quantity`.
 * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`
 * equals 2. Now we can start copy/move slides from the left part.
 * This action is called `Option COPY`
 *
 * `Option COPY`:
 * When meddling with slides from the other side, we have two options
 * of what to do with them: either copy or move. Slide can be moved
 * when it is not `inViewport`, meaning it has corresponding option
 * flag. Otherwise it should be copied.
 * In our example we should move two slides from the left part, since
 * `quantity` after `Option FILL` equals 2. Lets imagine that slides
 * weren't in viewport and now our row has
 * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!
 */
function moveOrCopySlidesToStart(slides, offset, quantity, slideWidth, items, idGenerator = new IdGenerator()) {
    if (quantity < 1) {
        return new CopySlidesResult(slides, offset, []);
    }
    const newSlides = [];
    /** Item indexes that should be marked as copies later */
    const unmarkedItemIndexes = [];
    /** Used as argument for splice call later */
    let spliceFrom = null;
    /** Used as argument for splice call later */
    let spliceQuantity = 0;
    /**
     * Once we finished with option FILL GAP, then
     * copy option should take place
     */
    let shouldCopy = false;
    /**
     * Iterator index, used in COPY option. Determines which
     * slide should be picked from right side for analyzing.
     */
    let slideIndex = slides.length - 1;
    // We going to iterate through item indexes starting from
    // first slide item index. Let's pick an item index
    // to start from.
    const firstSlide = slides[0];
    const firstSlideHasFirstItemId = firstSlide.itemIndex === 0;
    /**
     * Iterator index, used in FILL GAP and COPY options.
     * This index determines which item will next slide have.
     */
    let nextItemId = firstSlideHasFirstItemId
        ? items.length - 1
        : firstSlide.itemIndex - 1;
    for (let i = 0; i < quantity; i++) {
        const lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;
        if (shouldCopy || lastSlideHasNextItemId) {
            // Option COPY
            shouldCopy = true;
            const currentSlide = slides[slideIndex];
            // Slide copy procedure
            const newOptions = Object.assign({}, currentSlide.options);
            // There should be an already existing isActive slide,
            // so we turning isActive off for copy
            newOptions.isActive = false;
            // Every filled item is considered to be in viewport,
            // because why else would we call this function
            // otherwise? To fill viewport obviously.
            newOptions.inViewport = true;
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, newOptions);
            newSlides.push(newSlide);
            // Prepare next slide index
            slideIndex--;
            if (slideIndex < 0) {
                slideIndex = slides.length - 1;
            }
            // Splice arguments processing
            // spliceFrom can be assigned once and equals first inViewport
            // slide that we met
            if (spliceFrom === null && currentSlide.options.inViewport) {
                spliceFrom = slides.length - spliceQuantity;
            }
            // We can't increase quantity if we have determined
            // from where we should splice slides
            const slideCopyNotEncountered = spliceFrom === null;
            // We can't have splice quantity higher than slides size.
            // It happens when quantity from argument is higher than
            // slides size.
            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;
            if (slideCopyNotEncountered && canIncrementSpliceQuantity) {
                spliceQuantity++;
            }
        }
        else {
            // Option FILL GAP
            // Slide copy procedure
            const newSlide = new CarouselSlide(idGenerator.next(), nextItemId, {
                // Every filled item is considered to be in viewport,
                // because why else would we call this function
                // otherwise? To fill viewport obviously.
                inViewport: true,
                item: items[nextItemId],
                // There should be an already existing isActive slide,
                // so we turning isActive off for copy
                isActive: false,
            });
            newSlides.push(newSlide);
            unmarkedItemIndexes.push(nextItemId);
        }
        // Pick index for next item
        nextItemId--;
        if (nextItemId < 0) {
            nextItemId = items.length - 1;
        }
    }
    if (spliceQuantity > 0) {
        spliceFrom = spliceFrom === null
            ? slides.length - spliceQuantity
            : spliceFrom;
        slides.splice(spliceFrom, spliceQuantity);
    }
    const result = [
        ...newSlides.reverse(),
        ...slides,
    ];
    return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);
}

/**
 * Moves slide from left side to right or vise versa
 * in order to balance weight or predict offset changes
 */
function shuffleSlidesProcedure() {
    return ({ state, procedureState, environment }) => {
        var _a;
        const result = shuffleSlides(state.slides, state.offset, state.config.slideWidth, getViewportWidth(state), state.config.items, state.config.shouldLoop, state.config.threshold, (_a = environment === null || environment === void 0 ? void 0 : environment.slideIdGenerator) !== null && _a !== void 0 ? _a : new IdGenerator());
        state.slides = result.slides;
        state.activeSlideIndex = result.slides.findIndex((item) => item.options.isActive) || 0;
        if (typeof procedureState.offsetSnapshot !== 'undefined') {
            procedureState.offsetSnapshot = result.modifiedOffset - state.offset + procedureState.offsetSnapshot;
        }
        state.offset = result.modifiedOffset;
        return new ContinueWith(state);
    };
}

/**
 * Cleans state from excessive slides and completes
 * corresponding duties after completed transition
 */
function cleanupProcedure() {
    return procedurePipe('cleanup', destroyAnimationProcedure(), markVisibleAndActiveProcedure(), calculateOffsetProcedure(), calculateActiveSlideProcedure(), removeExcessiveProcedure(), shuffleSlidesProcedure(), calculateActiveSlideProcedure());
}

/** Converts passed distance to carousel width units */
function normalizePassedDistanceProcedure(passedDistance) {
    return ({ state, procedureState }) => {
        procedureState.passedDistance = state.config.widthMode === CarouselWidthMode.PERCENT
            ? 100 * passedDistance / getViewportWidthInPx(state)
            : passedDistance;
        return new ContinueWith(state, procedureState);
    };
}

/**
 * Calculates offset for animation specific tick
 */
function animationOffsetSnapshot(currentPosition, totalDuration, from, to, offsetFallback, bezierFn) {
    if (typeof from === 'undefined' || typeof to === 'undefined') {
        return offsetFallback;
    }
    if (totalDuration <= 0 || currentPosition < 0 || to === from) {
        return to;
    }
    const animationDistance = Math.abs(to - from);
    const completedDistancePercent = currentPosition / totalDuration;
    const completedDistance = animationDistance * bezierFn(completedDistancePercent);
    const offsetSnapshot = to > from
        ? from + completedDistance
        : from - completedDistance;
    return offsetSnapshot;
}

/**
 * Assigns offset to state like if animation was paused.
 * If animation is not available, current offset will be assigned.
 */
function animationOffsetSnapshotProcedure() {
    return ({ state }) => {
        var _a, _b, _c, _d;
        const time = new Date().getTime();
        const currentPosition = time - ((_b = (_a = state.animation) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : time);
        const result = animationOffsetSnapshot(currentPosition, state.config.transitionDuration, (_c = state.animation) === null || _c === void 0 ? void 0 : _c.from, (_d = state.animation) === null || _d === void 0 ? void 0 : _d.to, state.offset, state.animationBezierFn);
        state.offset = result;
        return new ContinueWith(state);
    };
}

/**
 * Animation state that is currently in process
 */
class CarouselAnimation {
    constructor(from, to, player, onDoneSubscription$, startTime = new Date().getTime()) {
        this.from = from;
        this.to = to;
        this.player = player;
        this.onDoneSubscription$ = onDoneSubscription$;
        this.startTime = startTime;
    }
}

function startAnimation(container, from, to, widthMode, transitionDuration, bezierArgs, isBrowser, afterAnimationAction, animationBuilder) {
    if (!isBrowser) {
        return null;
    }
    const cubicBezier = `cubic-bezier(${bezierArgs[0]},${bezierArgs[1]},${bezierArgs[2]},${bezierArgs[3]})`;
    const animationFactory = animationBuilder.build([
        style({
            transform: `translateX(${from}${widthMode})`,
        }),
        animate(`${transitionDuration}ms ${cubicBezier}`, style({
            transform: `translateX(${to}${widthMode})`,
        })),
    ]);
    const animationPlayer = animationFactory.create(container);
    // Wrap onDone into observable
    const boundFunction = bindCallback(animationPlayer.onDone); // Wrap function into function that returns observable
    const onDone$ = boundFunction.call(animationPlayer); // Receive observable with context of animation player
    const subscription$ = onDone$
        .subscribe(() => {
        animationPlayer.destroy();
        afterAnimationAction();
    });
    const animation = new CarouselAnimation(from, to, animationPlayer, subscription$);
    animationPlayer.play();
    return animation;
}

/**
 * Creates new transition from one slide to another
 */
function startAnimationProcedure() {
    return ({ state, procedureState, environment }) => {
        var _a, _b, _c;
        const animation = startAnimation(state.animatableContainer, procedureState.offsetSnapshot, state.offset, state.config.widthMode, state.config.transitionDuration, (_a = environment === null || environment === void 0 ? void 0 : environment.animationBezierArgs) !== null && _a !== void 0 ? _a : [], (_b = environment === null || environment === void 0 ? void 0 : environment.isBrowser) !== null && _b !== void 0 ? _b : false, (_c = environment === null || environment === void 0 ? void 0 : environment.afterAnimationAction) !== null && _c !== void 0 ? _c : (() => { }), environment === null || environment === void 0 ? void 0 : environment.animationBuilder);
        state.animation = animation;
        return new ContinueWith(state);
    };
}

/**
 * Save offset to procedure state until later use
 */
function setOffsetSnapshotProcedure() {
    return ({ state, procedureState }) => {
        procedureState.offsetSnapshot = state.offset;
        return new ContinueWith(state, procedureState);
    };
}

/**
 * Calculates corresponding parts for current active slide
 */
function setSlideIndexProcedure() {
    return procedurePipe('setSlideIndex', animationOffsetSnapshotProcedure(), destroyAnimationProcedure(), setOffsetSnapshotProcedure(), markVisibleAndActiveProcedure(), calculateOffsetProcedure(), shuffleSlidesProcedure(), startAnimationProcedure());
}

/**
 * Calculates state after user finish drag event
 */
function dragEndProcedure(passedDistance) {
    return procedurePipe('dragEnd', enableAutoplayProcedure("drag" /* DRAG */), normalizePassedDistanceProcedure(passedDistance), calculateActiveSlideProcedure(), setSlideIndexProcedure());
}

/**
 * Return new offset modified by last drag operations.
 * Applies overscroll behavior when necessary.
 *
 * @returns modified offset
 */
function dragOffsetSnapshot(
/** X position in pixels from where drag event began */
fromX, 
/** destination X in pixels of last fired drag event */
toX, currentOffset, widthMode, alignMode, shouldLoop, viewportWidth, viewportWidthInPx, slideWidth, slideSumWidth, 
/** How much in percents user can overscroll unlooped carousel */
maxOverscrollPercent, bezierFn, invertedBezierFn) {
    if (fromX === toX) {
        return currentOffset;
    }
    // Normalize all pixel values to current width mode
    if (widthMode === CarouselWidthMode.PERCENT) {
        fromX = fromX * 100 / viewportWidthInPx;
        toX = toX * 100 / viewportWidthInPx;
    }
    let offsetDelta = toX - fromX;
    // 1st case: no bezier amendments, just return offset with applied delta
    if (shouldLoop) {
        return currentOffset + offsetDelta;
    }
    const overscrollStartPoint = detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn);
    // 2nd case where bezier correction haven't started yet,
    // meaning we're in safe zone at both side
    if (overscrollStartPoint === null) {
        const offsetFromSafeZone = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
        return offsetFromSafeZone;
    }
    // Seems like we already at overscroll zone, so let's see
    // the ways we could manage that
    /** Whether drag was performed from overscroll zone to same overscroll zone */
    const dragStaysInSameOverscrollZone = fromX > overscrollStartPoint
        ? toX > overscrollStartPoint
        : toX < overscrollStartPoint;
    // 3rd case: we should not amend when drag pointer is still in overscroll zone
    // after applying delta
    if (dragStaysInSameOverscrollZone) {
        const distanceBefore = fromX - overscrollStartPoint;
        const distanceAfter = toX - overscrollStartPoint;
        const distance = distanceBetween(distanceBefore, distanceAfter, viewportWidth, maxOverscrollPercent, bezierFn);
        currentOffset = currentOffset - distance;
        return currentOffset;
    }
    // 4th case where drag pointer has returned to safe zone.
    // We should do the same calculation like we did in 2nd case.
    const overscrollDistance = applyDeltaFromOverscrollZone(overscrollStartPoint - fromX, viewportWidth, maxOverscrollPercent, bezierFn);
    const distancetoSafeZone = overscrollStartPoint - fromX;
    currentOffset += overscrollDistance;
    fromX = overscrollStartPoint;
    offsetDelta -= distancetoSafeZone;
    const result = applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn);
    return result;
}
/**
 * Applies bezier on distance and limit with max overscroll distance
 *
 * BE ADVICED, that all argument values should be converted to current width mode
 * beforehand.
 */
function applyDeltaFromOverscrollZone(distance, viewportWidth, maxOverscrollPercent, bezierFn) {
    /** Viewport % from 0 to 1 of delta distance */
    const deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));
    /** Maximal distance of overscroll in pixels */
    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
    /**
     * How much delta is actually long when applying bezier
     * and aligning overscroll max distance
     */
    const deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);
    return deltaDistance;
}
/**
 * Applies delta to current offset which is currently in safe zone at this moment.
 * Applies bezier whether delta intersects overscroll zone.
 *
 * BE ADVICED, that all argument values should be converted to current width mode
 * beforehand.
 */
function applyDeltaFromSafeZone(currentOffset, offsetDelta, alignMode, viewportWidth, slideWidth, slideSumWidth, maxOverscrollPercent, bezierFn) {
    const leftmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 - slideWidth / 2
        : 0;
    const rightmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 + slideWidth / 2
        : Math.min(viewportWidth, slideSumWidth);
    /** Whether left side of carousel is in viewport after applying delta */
    const leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;
    /** Whether right side of carousel is in viewport after applying delta */
    const rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;
    const canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)
        || (!rightSideExposedAfter && offsetDelta < 0);
    if (canSafelyTransit) {
        // We're still safe on both sides, just apply delta
        return currentOffset + offsetDelta;
    }
    /**
     * Distance between current offset and point
     * where overscroll begins
     */
    let distanceToSafeZone = 0;
    // Move offset to the point where overscroll begins
    if (leftSideExposedAfter) {
        distanceToSafeZone = currentOffset - leftmostPoint;
    }
    else if (rightSideExposedAfter) {
        distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;
    }
    /**
     * Distance between current offset and
     * overscroll zone starting point
     */
    const distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;
    currentOffset -= distanceToSafeZone;
    const overscrollDelta = applyDeltaFromOverscrollZone(distanceWithoutSafeZone, viewportWidth, maxOverscrollPercent, bezierFn);
    currentOffset += overscrollDelta;
    return currentOffset;
}
/**
 * Returns point where overscroll should potentially start
 * or null if carousel is currently in safe zone.
 */
function detectOverscrollStartPoint(fromX, currentOffset, viewportWidth, slideWidth, slideSumWidth, alignMode, maxOverscrollPercent, invertedBezierFn) {
    const leftmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 - slideWidth / 2
        : 0;
    const rightmostPoint = alignMode === CarouselAlignMode.CENTER
        ? viewportWidth / 2 + slideWidth / 2
        : Math.min(leftmostPoint + slideSumWidth, viewportWidth);
    /** Distance from current offset to safe zone */
    let overscrollConvertedDistance = null;
    // Special case when left-aligned carousel is lesser than viewport width
    if (alignMode === CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {
        overscrollConvertedDistance = currentOffset;
    }
    else if (currentOffset > leftmostPoint) {
        overscrollConvertedDistance = currentOffset - leftmostPoint;
    }
    else if (currentOffset < rightmostPoint - slideSumWidth) {
        overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;
    }
    if (overscrollConvertedDistance === null) {
        return null;
    }
    const overscrollRealDistance = extractDeltaFromOverscrollZone(overscrollConvertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn);
    const overscrollStartPoint = fromX - overscrollRealDistance;
    return overscrollStartPoint;
}
/**
 * Converts distance with bezier applied to distance
 * without bezier
 */
function extractDeltaFromOverscrollZone(convertedDistance, viewportWidth, maxOverscrollPercent, invertedBezierFn) {
    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;
    const bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);
    const deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);
    return deltaPercentage;
}
/**
 * Calculates overscroll distance between two points
 */
function distanceBetween(firstPoint, secondPoint, viewportWidth, maxOverscrollPercent, bezierFn) {
    const overscrollBefore = applyDeltaFromOverscrollZone(firstPoint, viewportWidth, maxOverscrollPercent, bezierFn);
    const overscrollAfter = applyDeltaFromOverscrollZone(secondPoint, viewportWidth, maxOverscrollPercent, bezierFn);
    const distance = overscrollBefore - overscrollAfter;
    return distance;
}

/**
 * Assigns offset to state by given distance coordinates
 */
function dragOffsetSnapshotProcedure(fromX, toX) {
    return ({ state, environment }) => {
        const result = dragOffsetSnapshot(fromX, toX, state.offset, state.config.widthMode, state.config.alignMode, state.config.shouldLoop, getViewportWidth(state), getViewportWidthInPx(state), state.config.slideWidth, state.slides.length * state.config.slideWidth, environment.maxOverscroll, state.dragBezierFn, state.invertedDragBezierFn);
        state.offset = result;
        return new ContinueWith(state);
    };
}

class BreakWith {
    constructor(state, procedureState = null) {
        this.state = state;
        this.procedureState = procedureState;
        this.shouldBreakProcedure = true;
    }
}

/**
 * Would break procedure whether drag is disabled
 */
function postponeDragEnabledProcedure() {
    return ({ state }) => {
        var _a;
        if ((_a = state === null || state === void 0 ? void 0 : state.config) === null || _a === void 0 ? void 0 : _a.dragEnabled) {
            return new ContinueWith(state);
        }
        return new BreakWith(state);
    };
}

/**
 * Processes state after single tick of drag event
 */
function dragProcedure(fromX, toX) {
    return procedurePipe('drag', postponeDragEnabledProcedure(), animationOffsetSnapshotProcedure(), destroyAnimationProcedure(), dragOffsetSnapshotProcedure(fromX, toX), markVisibleAndActiveProcedure(), shuffleSlidesProcedure(), calculateActiveSlideProcedure(), markVisibleAndActiveProcedure());
}

/**
 * Processes state when drag event starts
 */
function dragStartProcedure() {
    return procedurePipe('dragStart', postponeDragEnabledProcedure(), disableAutoplayProcedure("drag" /* DRAG */));
}

/**
 * Finds slide that is marked as `isActive` and returns its index
 */
function findSlideIndex(slides, newItemIndex, currentSlideIndex) {
    var _a;
    if (!slides) {
        return 0;
    }
    const currentActiveSlide = slides[currentSlideIndex];
    if (!currentActiveSlide) {
        return 0;
    }
    const currentItemIndex = currentActiveSlide.itemIndex;
    let targetSlideIndex = null;
    if (newItemIndex === currentItemIndex || slides.length <= 1) {
        return currentSlideIndex;
    }
    else if (newItemIndex > currentItemIndex) {
        targetSlideIndex =
            iterateRightSide(slides, newItemIndex, currentSlideIndex)
                || iterateLeftSide(slides, newItemIndex, currentSlideIndex);
    }
    else {
        targetSlideIndex =
            iterateLeftSide(slides, newItemIndex, currentSlideIndex)
                || iterateRightSide(slides, newItemIndex, currentSlideIndex);
    }
    return (_a = targetSlideIndex === null || targetSlideIndex === void 0 ? void 0 : targetSlideIndex.foundIndex) !== null && _a !== void 0 ? _a : null;
}
function iterateRightSide(slides, newItemIndex, currentSlideIndex) {
    for (let i = currentSlideIndex + 1; i < slides.length; i++) {
        if (slides[i].itemIndex === newItemIndex) {
            return { foundIndex: i };
        }
    }
    return null;
}
function iterateLeftSide(slides, newItemIndex, currentSlideIndex) {
    for (let i = currentSlideIndex - 1; i >= 0; i--) {
        if (slides[i].itemIndex === newItemIndex) {
            return { foundIndex: i };
        }
    }
    return null;
}

/**
 * Assigns slide index by given item index
 */
function findSlideIndexProcedure(itemIndex) {
    return ({ state }) => {
        const result = findSlideIndex(state.slides, itemIndex !== null && itemIndex !== void 0 ? itemIndex : state.activeItemIndex, state.activeSlideIndex);
        state.activeSlideIndex = result;
        state.activeItemIndex = itemIndex;
        return new ContinueWith(state);
    };
}

/**
 * Guard for assigning item index when no slides are available.
 * Would break procedure on such occasion.
 */
function postponeItemIndexProcedure(newItemIndex) {
    return ({ state }) => {
        if (!state.slides || !state.slides.length) {
            state.postponedItemIndex = newItemIndex;
            return new BreakWith(state);
        }
        state.postponedItemIndex = null;
        return new ContinueWith(state);
    };
}

/** Assigns item index and shuffles slides accordingly */
function goToProcedure(newItemIndex) {
    return procedurePipe('goTo', postponeItemIndexProcedure(newItemIndex), enableAutoplayProcedure(), findSlideIndexProcedure(newItemIndex), setSlideIndexProcedure());
}

/**
 * Fills empty carousel with slides without any
 * alignments
 */
function initializeCarousel(items, idGenerator) {
    if (!items || !items.length || !idGenerator) {
        return [];
    }
    const newSlides = new Array(items.length);
    for (let i = 0; i < items.length; i++) {
        newSlides[i] = new CarouselSlide(idGenerator.next(), i, { item: items[i], isActive: i === 0 });
    }
    return newSlides;
}

/**
 * Creates new slide set from scratch
 */
function initializeCarouselProcedure() {
    return ({ state, environment }) => {
        const result = initializeCarousel(state.config.items, environment.slideIdGenerator);
        state.slides = result;
        state.offset = 0;
        state.activeSlideIndex = 0;
        return new ContinueWith(state);
    };
}

/**
 * Would break procedure when carousel is not ready
 * for first initialization
 */
function postponeInitializationProcedure() {
    return ({ state }) => {
        var _a;
        const phase = (_a = state === null || state === void 0 ? void 0 : state.initializationState) !== null && _a !== void 0 ? _a : new InitializationState();
        if (phase.configInitialized && phase.viewportWidthInitialized) {
            return new ContinueWith(state);
        }
        return new BreakWith(state);
    };
}

// Reference: https://easings.net/ru
// Standard ease
const ANIMATION_BEZIER_ARGS = [0.25, 0.1, 0.25, 1];
// Ease out quad
const DRAG_BEZIER_ARGS = [0.25, 0.46, 0.45, 0.94];
/**
 * Creates bezier functions for different purposes
 */
function setBeziersProcedure() {
    return ({ state }) => {
        if (!state.dragBezierFn) {
            state.dragBezierFn = bezier(DRAG_BEZIER_ARGS[0], DRAG_BEZIER_ARGS[1], DRAG_BEZIER_ARGS[2], DRAG_BEZIER_ARGS[3]);
        }
        if (!state.invertedDragBezierFn) {
            state.invertedDragBezierFn = bezier(1 - DRAG_BEZIER_ARGS[0], 1 - DRAG_BEZIER_ARGS[1], 1 - DRAG_BEZIER_ARGS[2], 1 - DRAG_BEZIER_ARGS[3]);
        }
        if (!state.animationBezierFn) {
            state.animationBezierFn = bezier(ANIMATION_BEZIER_ARGS[0], ANIMATION_BEZIER_ARGS[1], ANIMATION_BEZIER_ARGS[2], ANIMATION_BEZIER_ARGS[3]);
        }
        return new ContinueWith(state);
    };
}

/**
 * Set state as initialized
 */
function setFirstInitializationProcedure() {
    return ({ state }) => {
        state.initializationState.firstInitalization = true;
        return new ContinueWith(state);
    };
}

function removePostponedIndexProcedure() {
    return ({ state }) => {
        state.postponedItemIndex = null;
        return new ContinueWith(state);
    };
}

/**
 * Saves freshly selected item index till later
 * until carousel is initialized
 */
function setPostponedIndexProcedure() {
    return ({ state }) => {
        if (state.slides.length && state.postponedItemIndex) {
            const itemIndex = state.postponedItemIndex;
            return procedurePipe('setPostponedIndex', goToProcedure(itemIndex), removePostponedIndexProcedure());
        }
        return new ContinueWith(state);
    };
}

/**
 * Creates slides from scratch
 */
function initializeProcedure() {
    return procedurePipe('initialize', postponeInitializationProcedure(), setFirstInitializationProcedure(), initializeCarouselProcedure(), calculateOffsetProcedure(), markVisibleAndActiveProcedure(), shuffleSlidesProcedure(), destroyAnimationProcedure(), enableAutoplayProcedure(), calculateActiveSlideProcedure(), setBeziersProcedure(), setPostponedIndexProcedure());
}

/**
 * Assigns carousel config, works as part of multiphase carousel initialization
 */
function setConfigProcedure(newConfig) {
    return ({ state }) => {
        state.config = newConfig;
        state.initializationState.configInitialized = true;
        return new ContinueWith(state);
    };
}

/**
 * Assigns config and executes initialization effects
 */
function initializeConfigProcedure(newConfig) {
    return procedurePipe('initializeConfig', setConfigProcedure(newConfig), initializeProcedure());
}

/**
 * Saves DOM element containers for carousel as part of initialization phase
 */
function setContainersProcedure(widthContainer, animatableContainer) {
    return ({ state }) => {
        state.widthContainer = widthContainer;
        state.animatableContainer = animatableContainer;
        state.initializationState.viewportWidthInitialized = true;
        return new ContinueWith(state);
    };
}

/**
 * Assigns specified DOM containers to carousel state
 */
function initializeContainersProcedure(widthContainer, animatableContainer) {
    return procedurePipe('initializeContainers', setContainersProcedure(widthContainer, animatableContainer), initializeProcedure());
}

/**
 * Returns next slide index as if user
 * clicked "next" button
 */
function getNextIndex(slidesLength, activeSlideIndex, shouldLoop) {
    let newIndex = activeSlideIndex + 1;
    if (newIndex >= slidesLength) {
        newIndex = shouldLoop
            ? 0
            : slidesLength - 1;
    }
    return newIndex;
}

/**
 * Increments current item index
 */
function getNextIndexProcedure() {
    return ({ state }) => {
        const result = getNextIndex(state.slides.length, state.activeSlideIndex, state.config.shouldLoop);
        state.activeSlideIndex = result;
        return new ContinueWith(state);
    };
}

/**
 * Increments current slide
 */
function nextProcedure(omitAutoplayReset = false) {
    return procedurePipe('next', omitAutoplayReset ? enableAutoplayProcedure() : null, getNextIndexProcedure(), setSlideIndexProcedure());
}

/**
 * Returns previous slide index as if user
 * clicked "prev" button
 */
function getPrevIndex(slidesLength, activeSlideIndex, shouldLoop) {
    let newIndex = activeSlideIndex - 1;
    if (newIndex < 0) {
        newIndex = shouldLoop
            ? slidesLength - 1
            : 0;
    }
    return newIndex;
}

/**
 * Decrements current item index
 */
function getPrevIndexProcedure() {
    return ({ state }) => {
        const result = getPrevIndex(state.slides.length, state.activeSlideIndex, state.config.shouldLoop);
        state.activeSlideIndex = result;
        return new ContinueWith(state);
    };
}

/**
 * Decrements current slide
 */
function prevProcedure() {
    return procedurePipe('prev', enableAutoplayProcedure(), getPrevIndexProcedure(), setSlideIndexProcedure());
}

/**
 * Programmaticaly recalculates current state
 */
function recalculateProcedure() {
    return procedurePipe('recalculate', calculateOffsetProcedure(), markVisibleAndActiveProcedure(), shuffleSlidesProcedure());
}

/**
 * Assigns TemplateRef where slides would be rendered
 */
function setTemplateProcedure(template) {
    return ({ state }) => {
        state.template = template;
        return new ContinueWith(state);
    };
}

/**
 * Short swipe might not change slide to next/prev.
 * This const specifies how much (% of viewport) swipe
 * should overcome to trigger next/prev slide change.
 */
const MAX_SWIPE_THRESHOLD = 15;
/**
 * How much % user can stretch carousel, when there's no more
 * drag available
 */
const MAX_OVERSCROLL = 10;
class CarouselService {
    constructor(animationBuilder, slideIdGenerator, 
    // tslint:disable-next-line: ban-types
    platformId) {
        this.animationBuilder = animationBuilder;
        this.slideIdGenerator = slideIdGenerator;
        this.platformId = platformId;
        this.carouselState$ = new BehaviorSubject(new CarouselState());
        /** Describes constant entities for procedures */
        this.procedureEnvironment = {
            slideIdGenerator: this.slideIdGenerator,
            isBrowser: isPlatformBrowser(this.platformId),
            autoplayAction: this.next.bind(this),
            afterAnimationAction: this.cleanup.bind(this),
            animationBuilder: this.animationBuilder,
            animationBezierArgs: ANIMATION_BEZIER_ARGS,
            swipeThreshold: MAX_SWIPE_THRESHOLD,
            maxOverscroll: MAX_OVERSCROLL,
        };
    }
    ngOnDestroy() {
        var _a, _b, _c;
        (_c = (_b = (_a = this.carouselState$.getValue()) === null || _a === void 0 ? void 0 : _a.autoplay) === null || _b === void 0 ? void 0 : _b.autoplaySubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
    }
    carouselStateChanges() {
        return this.carouselState$.asObservable();
    }
    setItemIndex(newItemIndex) {
        this.apply(goToProcedure(newItemIndex));
    }
    prev() {
        this.apply(prevProcedure());
    }
    /**
     * @param omitAutoplayReset whether autoplay timer should not be resetted
     */
    next(omitAutoplayReset = false) {
        this.apply(nextProcedure(omitAutoplayReset));
    }
    recalculate() {
        this.apply(recalculateProcedure());
    }
    /** Update state to announce that drag sequence just started */
    dragStart() {
        this.apply(dragStartProcedure());
    }
    /**
     * Update state to announce that drag sequence just ended
     * and perform necessary cleanups
     */
    dragEnd(passedDistance) {
        this.apply(dragEndProcedure(passedDistance));
    }
    /** Process single drag tick with given from and to coordinates */
    drag(fromX, toX) {
        this.apply(dragProcedure(fromX, toX));
    }
    setSlideTemplate(newTemplateRef) {
        this.apply(setTemplateProcedure(newTemplateRef));
    }
    disableAutoplay(suspender) {
        this.apply(disableAutoplayProcedure(suspender));
    }
    /**
     * Starts new autoplay timer
     */
    enableAutoplay(suspender = null) {
        this.apply(enableAutoplayProcedure(suspender));
    }
    setContainers(widthContainer, animatableContainer) {
        this.apply(initializeContainersProcedure(widthContainer, animatableContainer));
    }
    setConfig(newConfig) {
        this.apply(initializeConfigProcedure(newConfig));
    }
    cleanup() {
        this.apply(cleanupProcedure());
    }
    /**
     * Applies specified procedure to carousel state
     */
    apply(procedure) {
        const state = Object.assign({}, this.carouselState$.getValue());
        const result = procedurePipe('applier', procedure)({ state, procedureState: {}, environment: this.procedureEnvironment });
        this.carouselState$.next(result.state);
    }
}
CarouselService.decorators = [
    { type: Injectable }
];
CarouselService.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: IdGenerator, decorators: [{ type: Inject, args: [SLIDE_ID_GENERATOR,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

function idGeneratorFactory() {
    return new IdGenerator();
}
/**
 * Defines carousel API to work with
 */
class CarouselComponent {
    constructor(carousel) {
        this.carousel = carousel;
        this.itemIndexChange = this.carousel.carouselStateChanges()
            .pipe(map((state) => state.activeItemIndex));
    }
    set slideRef(newSlideRef) {
        this.carousel.setSlideTemplate(newSlideRef
            ? newSlideRef.templateRef
            : null);
    }
    set config(newConfig) {
        newConfig = new CarouselConfig(newConfig);
        this.carousel.setConfig(newConfig);
    }
    next() {
        this.carousel.next();
    }
    prev() {
        this.carousel.prev();
    }
    setIndex(newIndex) {
        this.carousel.setItemIndex(newIndex);
    }
    /**
     * Programmaticaly recalculates carousel position in case of
     * container size changes or other size interactions
     */
    recalculate() {
        this.carousel.recalculate();
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-carousel',
                template: "<carousel-engine class=\"carousel-engine\"></carousel-engine>\n",
                providers: [
                    CarouselService,
                    {
                        provide: SLIDE_ID_GENERATOR,
                        useFactory: idGeneratorFactory,
                    },
                    {
                        provide: ANIMATION_ID_GENERATOR,
                        useFactory: idGeneratorFactory,
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                exportAs: 'ngCarousel',
                styles: [".carousel-engine{display:block;overflow:hidden;width:100%}"]
            },] }
];
CarouselComponent.ctorParameters = () => [
    { type: CarouselService }
];
CarouselComponent.propDecorators = {
    slideRef: [{ type: ContentChild, args: [CarouselSlideDirective,] }],
    config: [{ type: Input }],
    itemIndexChange: [{ type: Output }]
};

class HammerProviderService {
    constructor(
    // tslint:disable-next-line: ban-types
    platformId) {
        this.platformId = platformId;
        this.hammerAbsenceDeclared = false;
    }
    managerFor(element) {
        const hasGestures = isPlatformBrowser(this.platformId) && window.Hammer;
        if (!hasGestures) {
            if (isDevMode() && !this.hammerAbsenceDeclared) {
                console.warn('Ng-carousel could not listen to drag, because HammerJS was not found. Either disable drag or import HammerJS.');
                this.hammerAbsenceDeclared = true;
            }
            return null;
        }
        const hammerManager = new Hammer(element);
        return hammerManager;
    }
}
HammerProviderService.ɵprov = ɵɵdefineInjectable({ factory: function HammerProviderService_Factory() { return new HammerProviderService(ɵɵinject(PLATFORM_ID)); }, token: HammerProviderService, providedIn: "root" });
HammerProviderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
HammerProviderService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

class PreventGhostClickDirective {
    constructor(elementRef, hammer) {
        this.elementRef = elementRef;
        this.hammer = hammer;
        this.shouldPreventClick = false;
    }
    processClickEvent(event) {
        if (this.shouldPreventClick) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
    ngOnInit() {
        this.listenPanEndEvents();
    }
    ngOnDestroy() {
        if (this.hammerManager) {
            this.hammerManager.destroy();
        }
    }
    listenPanEndEvents() {
        this.hammerManager = this.hammer.managerFor(this.elementRef.nativeElement);
        if (!this.hammerManager) {
            return;
        }
        this.hammerManager.on('panend pancancel', () => {
            this.shouldPreventClick = true;
            asyncScheduler.schedule(() => {
                this.shouldPreventClick = false;
            });
        });
    }
}
PreventGhostClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngCarouselPreventGhostClick]',
            },] }
];
PreventGhostClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: HammerProviderService }
];
PreventGhostClickDirective.propDecorators = {
    processClickEvent: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * Applies tabindex=-1 for interactive elements inside container
 */
class FocusBlockDirective {
    constructor(elementRef, interactivityChecker) {
        this.elementRef = elementRef;
        this.interactivityChecker = interactivityChecker;
        this.untabbable = false;
        /** Whether focus inside carousel */
        this.untabbableFocused = false;
        this.lastTabindexValueMap = new Map();
    }
    ngOnChanges(changes) {
        if (changes.untabbable && this.viewInitiated) {
            const change = changes.untabbable;
            if (change.currentValue === change.previousValue) {
                return;
            }
            change.currentValue
                ? this.blockTabindex()
                : this.unblockTabindex();
            if (this.untabbableFocused && this.untabbableFocusTrapRef) {
                this.untabbableFocusTrapRef.focusTrap.focusFirstTabbableElement();
            }
        }
    }
    ngAfterViewInit() {
        this.viewInitiated = true;
        this.untabbable
            ? this.blockTabindex()
            : this.unblockTabindex();
    }
    ngOnDestroy() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
        }
    }
    blockTabindex() {
        const elements = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));
        for (const element of elements) {
            this.blockElement(element);
        }
        if (typeof window !== 'undefined' && 'MutationObserver' in window) {
            this.mutationObserver = new MutationObserver((mutationList) => {
                const changesArray = Array.from(mutationList);
                for (const change of changesArray) {
                    if (change.type === 'attributes') {
                        this.blockElement(change.target);
                    }
                    else if (change.type === 'childList') {
                        change.addedNodes.forEach((element) => {
                            this.blockElement(element);
                        });
                    }
                }
            });
            this.mutationObserver.observe(this.elementRef.nativeElement, {
                attributeFilter: ['tabindex'],
                attributes: true,
                childList: true,
                subtree: true,
            });
        }
    }
    unblockTabindex() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
        }
        const elements = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));
        for (const element of elements) {
            this.unblockElement(element);
        }
    }
    blockElement(element) {
        // nodeType is text node, should not be blocked
        if (element.nodeType !== 3 && this.interactivityChecker.isFocusable(element) && this.interactivityChecker.isTabbable(element)) {
            const currentTabindexValue = element.getAttribute('tabindex');
            this.lastTabindexValueMap.set(element, currentTabindexValue);
            if (currentTabindexValue !== '-1') {
                element.setAttribute('tabindex', '-1');
            }
        }
    }
    unblockElement(element) {
        if (this.lastTabindexValueMap.has(element) && typeof this.lastTabindexValueMap.get(element) === 'number') {
            element.setAttribute('tabindex', this.lastTabindexValueMap.get(element));
        }
        else {
            element.removeAttribute('tabindex');
        }
    }
}
FocusBlockDirective.decorators = [
    { type: Directive, args: [{
                selector: '[untabbable]',
            },] }
];
FocusBlockDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: InteractivityChecker }
];
FocusBlockDirective.propDecorators = {
    untabbable: [{ type: Input }],
    untabbableFocusTrapRef: [{ type: Input }],
    untabbableFocused: [{ type: Input }]
};

/**
 * Template context for carousel slide
 */
class CarouselSlideContext {
    constructor($implicit, itemIndex, isActive, inViewport) {
        this.$implicit = $implicit;
        this.itemIndex = itemIndex;
        this.isActive = isActive;
        this.inViewport = inViewport;
    }
}

/**
 * Contains listeners and other DOM controllers
 */
class CarouselEngineComponent {
    constructor(carousel, elementRef, renderer, hammer, 
    // tslint:disable-next-line: ban-types
    platformId) {
        this.carousel = carousel;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.hammer = hammer;
        this.platformId = platformId;
        this.transformValue$ = this.transformValueChanges();
        this.slideWidth$ = this.slideWidthChanges();
        this.template$ = this.templateChanges();
        this.slides$ = this.slidesChanges();
        this.focused = false;
        this.destroyed$ = new Subject();
    }
    get htmlElement() {
        return this.elementRef.nativeElement;
    }
    ngOnInit() {
        this.listenToAutoplay();
        this.listenToDragEvents();
        this.listenToResizeEvents();
        this.listenToKeyEvents();
        this.listenToScrollEvents();
        this.carousel.setContainers(this.htmlElement, this.galleryRef.nativeElement);
    }
    ngOnDestroy() {
        this.destroyMouseListeners();
        this.destroyHammer();
        this.destroyKeyboardListeners();
        this.destroyElementScrollListener();
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    trackByFn(index, item) {
        return item.id;
    }
    contextOf(slide) {
        return new CarouselSlideContext(slide.options.item, slide.itemIndex, slide.options.isActive, slide.options.inViewport);
    }
    focusIn() {
        this.focused = true;
        this.carousel.disableAutoplay("focus" /* FOCUS */);
    }
    focusOut() {
        this.focused = false;
        this.carousel.enableAutoplay("focus" /* FOCUS */);
    }
    destroyMouseListeners() {
        if (this.mouseEnterDestructor) {
            this.mouseEnterDestructor();
        }
        if (this.mouseLeaveDestructor) {
            this.mouseLeaveDestructor();
        }
    }
    destroyHammer() {
        if (this.hammerManager) {
            this.hammerManager.destroy();
        }
    }
    destroyKeyboardListeners() {
        if (this.keyboardListener) {
            this.keyboardListener();
        }
    }
    destroyElementScrollListener() {
        if (this.containerScrollListener) {
            this.containerScrollListener();
        }
    }
    transformValueChanges() {
        return this.carousel.carouselStateChanges()
            .pipe(map((state) => `translateX(${state.offset}${state.config.widthMode})`));
    }
    slideWidthChanges() {
        return this.carousel.carouselStateChanges()
            .pipe(map((state) => `${state.config.slideWidth}${state.config.widthMode}`));
    }
    slidesChanges() {
        return this.carousel.carouselStateChanges()
            .pipe(map((state) => state.slides));
    }
    templateChanges() {
        return this.carousel.carouselStateChanges()
            .pipe(map((state) => state.template));
    }
    listenToAutoplay() {
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        this.carousel.carouselStateChanges()
            .pipe(map((state) => state.config.autoplayEnabled), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe((autoplayEnabled) => {
            if (this.mouseEnterDestructor) {
                this.mouseEnterDestructor();
            }
            if (this.mouseLeaveDestructor) {
                this.mouseLeaveDestructor();
            }
            if (!autoplayEnabled) {
                return;
            }
            this.mouseEnterDestructor = this.renderer.listen(this.htmlElement, 'mouseenter', () => this.carousel.disableAutoplay("mouse" /* MOUSE */));
            this.mouseLeaveDestructor = this.renderer.listen(this.htmlElement, 'mouseleave', () => this.carousel.enableAutoplay("mouse" /* MOUSE */));
        });
    }
    listenToDragEvents() {
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        this.carousel.carouselStateChanges()
            .pipe(map((state) => state.config.dragEnabled), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe((dragEnabled) => {
            if (this.hammerManager) {
                this.hammerManager.destroy();
            }
            if (!dragEnabled) {
                return;
            }
            this.hammerManager = this.hammer.managerFor(this.htmlElement);
            if (!this.hammerManager) {
                return;
            }
            let lastDelta = 0;
            let lastTouchAction;
            this.hammerManager.on('panstart', (event) => {
                // Checking whether pan started with horizontal gesture,
                // we should block all scroll attempts during current pan session then
                // tslint:disable-next-line: no-bitwise
                if (event.offsetDirection & Hammer.DIRECTION_HORIZONTAL) {
                    lastDelta = Math.round(event.deltaX);
                    this.carousel.dragStart();
                    lastTouchAction = this.htmlElement.style.touchAction;
                    this.renderer.setStyle(this.htmlElement, 'touch-action', 'none');
                }
            });
            this.hammerManager.on('panright panleft', (event) => {
                // We should not treat vertical pans as horizontal.
                // Be adviced that pan right/left events still counts
                // vertical pans as legitimate horizontal pan.
                // Next check clarifies that initial gesture was horizontal,
                // otherwise this variable would be falsy
                if (lastTouchAction) {
                    const x = Math.round(event.center.x);
                    const deltaX = Math.round(event.deltaX);
                    this.carousel.drag(x, x + (deltaX - lastDelta));
                    lastDelta = deltaX;
                }
            });
            this.hammerManager.on('panend pancancel', (event) => {
                if (lastTouchAction) {
                    this.carousel.dragEnd(event.deltaX);
                    this.renderer.setStyle(this.htmlElement, 'touch-action', lastTouchAction);
                    lastTouchAction = null;
                }
            });
        });
    }
    listenToResizeEvents() {
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        this.carousel.carouselStateChanges()
            .pipe(filter((state) => state.config.shouldRecalculateOnResize), switchMapTo(fromEvent(window, 'resize')), takeUntil(this.destroyed$))
            .subscribe(() => {
            this.carousel.recalculate();
        });
    }
    listenToKeyEvents() {
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        this.keyboardListener = this.renderer.listen(this.htmlElement, 'keydown', (event) => {
            const key = event.key.toLowerCase();
            if (['arrowright', 'right'].includes(key)) {
                this.carousel.next();
            }
            else if (['arrowleft', 'left'].includes(key)) {
                this.carousel.prev();
            }
        });
    }
    /**
     * Horizontal scroll might accidentaly happen on parent container
     * when pressing arrow buttons too fast. We should return
     * container to initial position when that happens.
     */
    listenToScrollEvents() {
        this.containerScrollListener = this.renderer.listen(this.htmlElement, 'scroll', () => {
            this.htmlElement.scrollTo(0, 0);
        });
    }
}
CarouselEngineComponent.decorators = [
    { type: Component, args: [{
                selector: 'carousel-engine',
                template: "<ul \n    #galleryRef\n    #focusTrapRef=\"cdkTrapFocus\"\n    [style.transform]=\"transformValue$ | async\"\n    [cdkTrapFocus]=\"false\"\n    (focusin)=\"focusIn()\"\n    (focusout)=\"focusOut()\"\n    class=\"ng-carousel-block\">\n    <li\n        *ngFor=\"let slide of (slides$ | async); trackBy: trackByFn;\"\n        [style.width]=\"slideWidth$ | async\"\n        [untabbable]=\"!slide.options.isActive\"\n        [untabbableFocusTrapRef]=\"focusTrapRef\"\n        [untabbableFocused]=\"focused\"\n        class=\"ng-carousel-slide\">\n        <ng-container *ngTemplateOutlet=\"(template$ | async); context: contextOf(slide);\"></ng-container>\n    </li>\n</ul>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".ng-carousel-block{display:flex;margin:0;padding:0;width:100%;will-change:transform}.ng-carousel-slide{flex:none;list-style:none}"]
            },] }
];
CarouselEngineComponent.ctorParameters = () => [
    { type: CarouselService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: HammerProviderService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
CarouselEngineComponent.propDecorators = {
    galleryRef: [{ type: ViewChild, args: ['galleryRef', { static: true },] }]
};

class CarouselModule {
}
CarouselModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    A11yModule,
                ],
                declarations: [
                    CarouselComponent,
                    CarouselSlideDirective,
                    CarouselEngineComponent,
                    FocusBlockDirective,
                    PreventGhostClickDirective,
                ],
                exports: [
                    CarouselComponent,
                    CarouselSlideDirective,
                    PreventGhostClickDirective,
                ],
            },] }
];

/*
 * Public API Surface of ng-carousel
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CarouselAlignMode, CarouselComponent, CarouselConfig, CarouselModule, CarouselSlideDirective, CarouselWidthMode, PreventGhostClickDirective, idGeneratorFactory, IdGenerator as ɵa, CarouselService as ɵb, SLIDE_ID_GENERATOR as ɵc, ANIMATION_ID_GENERATOR as ɵd, CarouselEngineComponent as ɵe, HammerProviderService as ɵf, FocusBlockDirective as ɵg };
//# sourceMappingURL=ng-carousel-cdk.js.map
