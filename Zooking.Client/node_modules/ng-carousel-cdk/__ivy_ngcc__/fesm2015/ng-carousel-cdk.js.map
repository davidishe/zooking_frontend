{"version":3,"file":"ng-carousel-cdk.js","sources":["../../../projects/ng-carousel/src/lib/carousel-width-mode.ts","../../../projects/ng-carousel/src/lib/carousel-align-mode.ts","../../../projects/ng-carousel/src/lib/carousel-config.ts","../../../projects/ng-carousel/src/lib/carousel-slide.directive.ts","../../../projects/ng-carousel/src/lib/private/models/id-generator.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-autoplay.ts","../../../projects/ng-carousel/src/lib/private/models/initialization-state.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-state.ts","../../../projects/ng-carousel/src/lib/private/models/procedure-error.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/procedure-pipe.ts","../../../projects/ng-carousel/src/lib/private/tokens.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/contiue-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/disable-autoplay/disable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/enable-autoplay/enable-autoplay-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width-in-px/get-viewport-width-in-px.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-viewport-width/get-viewport-width.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/models/calculate-active-slide-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-active-slide/calculate-active-slide-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/models/calculate-offset-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/calculate-offset/calculate-offset-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/destroy-animation/destroy-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/models/mark-visible-and-active-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/mark-visible-and-active/mark-visible-and-active-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/models/remove-excessive-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/remove-excessive/remove-excessive-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/copy-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/models/shuffle-slides-result.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/shuffle-slides/shuffle-slides-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/cleanup-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/normalize-passed-distance/normalize-passed-distance-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/animation-offset-snapshot/animation-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/start-animation/start-animation-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-offset-snapshot/set-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-end-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/drag-offset/drag-offset-snapshot-procedure.ts","../../../projects/ng-carousel/src/lib/private/models/procedure/handler/break-with.model.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-drag-enabled/postpone-drag-enabled-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/drag-start-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/find-slide-index/find-slide-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-item-index/postpone-item-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/go-to-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/initialize-carousel/initialize-carousel-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/postpone-initialization/postpone-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-beziers/set-beziers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-first-initalization/set-first-initialization-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/remove-postponed-index/remove-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-postponed-index/set-postponed-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-config/set-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-config-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-containers/set-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/initialize-containers-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-next-index/get-next-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/next-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index.ts","../../../projects/ng-carousel/src/lib/private/service/helpers/get-prev-index/get-prev-index-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/prev-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/recalculate-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/procedures/set-template/set-template-procedure.ts","../../../projects/ng-carousel/src/lib/private/service/carousel.service.ts","../../../projects/ng-carousel/src/lib/carousel.component.ts","../../../projects/ng-carousel/src/lib/private/service/hammer-provider.service.ts","../../../projects/ng-carousel/src/lib/prevent-ghost-click.directive.ts","../../../projects/ng-carousel/src/lib/private/directives/untabbable.directive.ts","../../../projects/ng-carousel/src/lib/private/models/carousel-slide-context.ts","../../../projects/ng-carousel/src/lib/private/views/carousel-engine.component.ts","../../../projects/ng-carousel/src/lib/carousel.module.ts","../../../projects/ng-carousel/src/public-api.ts","../../../projects/ng-carousel/src/ng-carousel-cdk.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Represents how carousel calculates slide width. Be adviced\n * that actual enum value is used in code, so change with caution.\n */\nexport enum CarouselWidthMode {\n    /**\n     * When pixel management is provided, carousel calculates\n     * slide width with pixels. Preferred to use in limited space\n     * where carousel width is more or less is predefined.\n     */\n    PX = 'px',\n    /**\n     * When percent management is provided, carousel calculates\n     * slide width with relative instrument (via percents). Preferred\n     * to use in full-width carousel, where carousel width is unknown.\n     */\n    PERCENT = '%',\n}\n","export enum CarouselAlignMode {\n    /**\n     * Active slide is always centered in carousel viewport\n     */\n    CENTER = 'center',\n    /**\n     * Active slide left border sticks to left border of\n     * carousel\n     */\n    LEFT = 'left',\n}\n","import { CarouselWidthMode } from './carousel-width-mode';\nimport { CarouselAlignMode } from './carousel-align-mode';\n\nexport class CarouselConfig {\n    /**\n     * Array of data to display\n     */\n    items?: any[] = [];\n    /**\n     * Describes how carousel calculates its content width.\n     * Consult with corresponding enum to see what options\n     * are available.\n     */\n    widthMode?: CarouselWidthMode = CarouselWidthMode.PERCENT;\n    /**\n     * Slide width. It could be pixels or percents, based on mode\n     * configuration.\n     */\n    slideWidth ? = 100;\n    /**\n     * Describes how slides should be positioned relative to\n     * carousel viewport\n     */\n    alignMode?: CarouselAlignMode = CarouselAlignMode.CENTER;\n    /**\n     * Whether autoplay is enabled\n     */\n    autoplayEnabled ? = true;\n    /**\n     * Time in ms of how long carousel would wait until automatic\n     * slide increment. Respects `autoplayEnabled` value.\n     */\n    autoplayDelay ? = 6000;\n    /**\n     * Whether mouse drag or gesture panning enabled\n     */\n    dragEnabled ? = true;\n    /**\n     * Whether carousel should start from beginning after last\n     * slide\n     */\n    shouldLoop ? = true;\n    /**\n     * Time in ms of how long transition between slides would last\n     */\n    transitionDuration ? = 280;\n    /**\n     * Whether carousel should automatically recalculate on window resize.\n     * This option is recommended when using pixel width mode or left\n     * alignment.\n     */\n    shouldRecalculateOnResize ? = true;\n    /**\n     * Value in current width mode units which are virtally added to both sides\n     * of viewport. Slides within this virtual zone should always be presented\n     * whether loop mode is on.\n     */\n    threshold ? = 5;\n\n    constructor(config?: CarouselConfig) {\n        // @TODO nullish coalescing here\n        this.items = config && config.items || [];\n        this.widthMode = config && config.widthMode || CarouselWidthMode.PERCENT;\n        this.alignMode = config && config.alignMode || CarouselAlignMode.CENTER;\n        this.slideWidth = config && typeof config.slideWidth === 'number'\n            ? config.slideWidth\n            : 100;\n        this.autoplayEnabled = config && typeof config.autoplayEnabled === 'boolean'\n            ? config.autoplayEnabled\n            : true;\n        this.autoplayDelay = config && typeof config.autoplayDelay === 'number'\n            ? config.autoplayDelay\n            : 6000;\n        this.dragEnabled = config && typeof config.dragEnabled === 'boolean'\n            ? config.dragEnabled\n            : true;\n        this.shouldLoop = config && typeof config.shouldLoop === 'boolean'\n            ? config.shouldLoop\n            : true;\n        this.transitionDuration = config && typeof config.transitionDuration === 'number'\n            ? config.transitionDuration\n            : 600;\n        this.shouldRecalculateOnResize = config && typeof config.shouldRecalculateOnResize === 'boolean'\n            ? config.shouldRecalculateOnResize\n            : true;\n    }\n}\n","import { Directive, TemplateRef } from '@angular/core';\n\n@Directive({\n    selector: '[ngCarouselSlide]',\n})\nexport class CarouselSlideDirective {\n\n    constructor(\n        public templateRef: TemplateRef<any>,\n    ) {\n    }\n\n}\n","/**\n * Generator for `CarouselSlide` id, should be\n * singleton throughout single carousel.\n */\nexport class IdGenerator {\n    private index = 0;\n\n    next(): number {\n        return this.index++;\n    }\n}\n","import { Subscription } from 'rxjs';\n\nimport { AutoplaySuspender } from './autoplay-suspender';\n\n/**\n * Autoplay state of current autoplay timer\n */\nexport class CarouselAutoplay {\n    autoplaySuspenders = new Set<AutoplaySuspender>();\n    autoplaySubscription: Subscription = null;\n    interval: number = null;\n}\n","/**\n * Since we don't want excessive slide recalculation\n * while main inputs are still on their way, we should\n * collect them and then initialize carousel when\n * everything is ready.\n */\nexport class InitializationState {\n    configInitialized = false;\n    viewportWidthInitialized = false;\n    /** Whether slides were created for the first time */\n    firstInitalization = false;\n}\n","import { TemplateRef } from '@angular/core';\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { CarouselAnimation } from './carousel-animation';\nimport { CarouselAutoplay } from './carousel-autoplay';\nimport { CarouselSlide } from './carousel-slide';\nimport { InitializationState } from './initialization-state';\n\n/**\n * Carousel state snapshot. Config is stored here\n * as well as other vital values like offset or\n * active slide index.\n */\nexport class CarouselState {\n    /**\n     * Container to measure gallery width. Type is HTMLElement but\n     * reduced for the ease of testing.\n     */\n    widthContainer: {offsetWidth: number} | null = null;\n    /** Container that should be animated during index change */\n    animatableContainer: HTMLElement | null = null;\n    /** Client-side config which regulates carousel behavior */\n    config: CarouselConfig = new CarouselConfig();\n    activeSlideIndex = 0;\n    /** Item index of config's items array */\n    activeItemIndex = 0;\n    template: TemplateRef<any> | null = null;\n    /** X position of leftmost carousel slide */\n    offset = 0;\n    slides: CarouselSlide[] = [];\n    /** State of multiphase initialization */\n    initializationState = new InitializationState();\n    /** Currently played animation */\n    animation: CarouselAnimation | null = null;\n    autoplay: CarouselAutoplay = new CarouselAutoplay();\n    dragBezierFn: EasingFunction;\n    /** Used to extract values to applied beziers */\n    invertedDragBezierFn: EasingFunction;\n    animationBezierFn: EasingFunction;\n    /**\n     * When no slides available and user intents to set index,\n     * this field would be initialized with desired index, which\n     * should be to activeSlideIndex when slides become available\n     */\n    postponedItemIndex: number;\n    /** Whether drag is in process right now */\n    isDragged: boolean;\n\n    constructor(state?: CarouselState) {\n        if (state) {\n            Object.assign(this, state);\n        }\n    }\n}\n","export class ProcedureError extends Error {\n    constructor(\n        error: Error,\n    ) {\n        super();\n        this.message = error.message;\n        this.stack = error.stack;\n    }\n}\n","import { ProcedureError } from '../procedure-error';\nimport { ComposedProcedure } from './composed-procedure.type';\nimport { ProcedureHandler } from './handler/procedure-handler.interface';\nimport { ProcedureResult } from './procedure-result.type';\nimport { ProcedureStateFacade } from './procedure-state-facade.interface';\nimport { Procedure } from './procedure.type';\n\n/** Organizes array of procedures into single procedure, flattens inner procedures */\nexport function procedurePipe(procedureName: string, ...args: (ComposedProcedure | null)[]): ProcedureResult {\n    return (state: ProcedureStateFacade, parentProcedureName?: string): ProcedureHandler => {\n        let handler: ProcedureHandler;\n        let procedureIndex = 0;\n        for (const procedure of args) {\n            if (typeof procedure !== 'function') {\n                continue;\n            }\n            const procedureState = Object.entries(handler?.procedureState ?? {}).length\n                ? handler.procedureState\n                : state.procedureState;\n            const nextState: ProcedureStateFacade = {\n                state: handler?.state ?? state.state,\n                procedureState: procedureState || {},\n                environment: state.environment,\n            };\n            const procedureSlot = `${procedureName}[${procedureIndex}]`;\n            const procedureChainString = parentProcedureName\n                ? `${parentProcedureName}->${procedureSlot}`\n                : procedureSlot;\n            let localHandler: ProcedureHandler | Procedure;\n            while (typeof localHandler === 'function' || !localHandler) {\n                try {\n                    localHandler = !localHandler\n                        ? procedure(nextState, procedureChainString)\n                        : (localHandler as Procedure)(nextState, procedureChainString);\n                } catch (e) {\n                    if (!(e instanceof ProcedureError)) {\n                        console.error(`Procedure interrupted at ${procedureChainString}`);\n                    }\n                    throw new ProcedureError(e);\n                }\n            }\n            handler = localHandler;\n            procedureIndex++;\n            if (handler.shouldBreakProcedure) {\n                break;\n            }\n        }\n\n        return handler;\n    };\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { IdGenerator } from './models/id-generator';\n\nexport const SLIDE_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\nexport const ANIMATION_ID_GENERATOR = new InjectionToken<IdGenerator>('slideIdGenerator');\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class ContinueWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = false;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: Partial<ProcedureCarouselState> = {},\n    ) {\n    }\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Stops autoplay timer, provides side effect for provided autoplay */\nexport function disableAutoplay(\n    suspender: AutoplaySuspender,\n    autoplay: CarouselAutoplay = new CarouselAutoplay(),\n): CarouselAutoplay {\n    autoplay?.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    autoplay.autoplaySuspenders.add(suspender);\n\n    return autoplay;\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { disableAutoplay } from './disable-autoplay';\n\n/**\n * Turns current autoplay timer off with a specified reason\n */\nexport function disableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = disableAutoplay(\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { interval } from 'rxjs';\n\nimport { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { CarouselAutoplay } from '../../../models/carousel-autoplay';\n\n/** Starts carousel autoplay whether one is enabled */\nexport function enableAutoplay(\n    autoplayEnabled: boolean,\n    transitionDuration: number,\n    autoplayDelay: number,\n    isBrowser: boolean,\n    autoplayAction: () => void,\n    suspender?: AutoplaySuspender,\n    autoplay?: CarouselAutoplay,\n): CarouselAutoplay {\n    if (!autoplay) {\n        autoplay = new CarouselAutoplay();\n    }\n    autoplay.autoplaySubscription?.unsubscribe();\n    if (!autoplay.autoplaySuspenders) {\n        autoplay.autoplaySuspenders = new Set<AutoplaySuspender>();\n    }\n    if (suspender) {\n        autoplay.autoplaySuspenders.delete(suspender);\n    }\n    if (autoplayEnabled && !autoplay.autoplaySuspenders.size && isBrowser) {\n        // Delay can't be smaller than transition itself in order to avoid endless animation\n        autoplay.interval = Math.max(transitionDuration, autoplayDelay);\n        autoplay.autoplaySubscription = interval(autoplay.interval).subscribe(autoplayAction);\n    }\n\n    return autoplay;\n}\n","import { AutoplaySuspender } from '../../../models/autoplay-suspender';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { enableAutoplay } from './enable-autoplay';\n\n/**\n * Enables autoplay when such option is available in config\n */\nexport function enableAutoplayProcedure(suspender: AutoplaySuspender = null): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        state = Object.assign({}, state);\n        const autoplay = enableAutoplay(\n            state.config.autoplayEnabled,\n            state.config.transitionDuration,\n            state.config.autoplayDelay,\n            environment?.isBrowser ?? false,\n            environment?.autoplayAction ?? (() => {}),\n            suspender,\n            state.autoplay,\n        );\n        state.autoplay = autoplay;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselState } from '../../../models/carousel-state';\n\n/**\n * Width of carousel element in pixels. Try to call this as little as\n * possible, since getting this value triggers layout thrashing.\n */\nexport function getViewportWidthInPx(state: CarouselState): number {\n    return state?.widthContainer?.offsetWidth ?? 100;\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselState } from '../../../models/carousel-state';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\n\n/**\n * Width of carousel element in current width mode.\n * Try to call this as little as possible, since getting this value\n * triggers layout thrashing.\n */\nexport function getViewportWidth(state: CarouselState): number {\n    return state?.config?.widthMode === CarouselWidthMode.PX\n        ? getViewportWidthInPx(state)\n        : 100;\n}\n","/**\n * Result for helper function `calculateActiveSlide`\n */\nexport class CalculateActiveSlideResult {\n\n    constructor(\n        public modifiedOffset: number = 0,\n        public slideIndex: number = 0,\n    ) {\n    }\n\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CalculateActiveSlideResult } from './models/calculate-active-slide-result';\n\n/**\n * Based on current whereabouts, returns most possible\n * active slide candidate and proposed offset for it\n */\nexport function calculateActiveSlide(\n    slides: CarouselSlide[],\n    offset: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    swipeThresholdPercent: number | null,\n    /** Distance (whether in px or %) that is aligned to carousel width mode */\n    swipeDistance: number | null = null,\n): CalculateActiveSlideResult {\n    const result = new CalculateActiveSlideResult(offset, 0);\n\n    // Noop run if nothing to calculate\n    if (!slides.length || slideWidth <= 0) {\n\n        return result;\n    }\n    const slidesSumWidth = slideWidth * slides.length;\n\n    // By given align mode, width mode and viewport width, calculate\n    // carousel center position\n    const carouselCenter = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : viewportWidth / 2;\n\n    // Slide center is not always its left side. On such occasion we should\n    // correct its offset using specified align mode.\n    const slideRightAmendment = alignMode === CarouselAlignMode.LEFT\n        ? slideWidth\n        : slideWidth / 2;\n    const slideLeftAmendment = alignMode === CarouselAlignMode.LEFT\n        ? 0\n        : slideRightAmendment;\n\n    // Preset if slides far behind carousel center\n    if (offset + slidesSumWidth < carouselCenter) {\n        result.slideIndex = slides.length - 1;\n        result.modifiedOffset = carouselCenter - slidesSumWidth + slideRightAmendment;\n\n    // Preset if slides far away from carousel center\n    } else if (offset - slideLeftAmendment > carouselCenter) {\n        result.slideIndex = 0;\n        result.modifiedOffset = carouselCenter - slideLeftAmendment;\n\n    // Any other cases (when slides intersect carousel center)\n    } else {\n        result.slideIndex = Math.floor(Math.abs(carouselCenter - offset) / slideWidth);\n        result.modifiedOffset = carouselCenter - result.slideIndex * slideWidth - slideLeftAmendment;\n    }\n\n    // Swipe correction: animation must align with swipe direction meaning\n    // when user swipes right, final animation should also lead to the right\n    const swipeDirection = Math.sign(swipeDistance);\n    const offsetDirection = offset > result.modifiedOffset\n        ? -1\n        : 1;\n    const shouldApplySwipeAlignment =\n        swipeDistance !== null\n        && swipeThresholdPercent !== null\n        && Math.abs(swipeDistance) > Math.abs(swipeThresholdPercent)\n        && swipeDirection !== offsetDirection;\n    if (shouldApplySwipeAlignment) {\n        const appliedSwipeAlignment = result.slideIndex - swipeDirection;\n        const newSlideIndex = Math.min(Math.max(0, appliedSwipeAlignment), slides.length - 1);\n        if (newSlideIndex !== result.slideIndex) {\n            result.slideIndex = newSlideIndex;\n            result.modifiedOffset += swipeDirection * slideWidth;\n        }\n    }\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateActiveSlide } from './calculate-active-slide';\n\n/**\n * Given current slide state, assigns active slide\n */\nexport function calculateActiveSlideProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = calculateActiveSlide(\n            state.slides,\n            state.offset,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            Math.min(state.config.slideWidth / 2, environment.swipeThreshold),\n            procedureState.passedDistance || null,\n        );\n        state.activeSlideIndex = result.slideIndex;\n        state.activeItemIndex = state.slides[result.slideIndex]?.itemIndex ?? 0;\n\n        return new ContinueWith(state);\n    };\n}\n","export class CalculateOffsetResult {\n    constructor(\n        public offset: number,\n    ) {\n    }\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CalculateOffsetResult } from './models/calculate-offset-result';\n\n/**\n * Calculates offset by specified arguments as if current slide was centered\n */\nexport function calculateOffset(\n    currentSlideIndex: number,\n    alignMode: CarouselAlignMode,\n    slideWidth: number,\n    viewportWidth: number,\n    slideQuantity: number,\n    shouldLoop: boolean,\n): CalculateOffsetResult {\n    const activeSlideLeftPosition = alignMode === CarouselAlignMode.CENTER\n        ? (viewportWidth - slideWidth) / 2\n        : 0;\n    const slidesSumWidth = slideWidth * slideQuantity;\n    let newOffset =  activeSlideLeftPosition - (slideWidth * currentSlideIndex);\n\n    // Edge case amendment for left-aligned non-looped slides:\n    // non-looped slides might have their right or left edge visible\n    // so we might amend offset for some situations\n    if (!shouldLoop && alignMode === CarouselAlignMode.LEFT) {\n        // Calculate prequesites\n        const rightmostPoint = newOffset + slidesSumWidth;\n        const allSlidesVisible = slidesSumWidth <= viewportWidth;\n\n        // Apply offset amendment\n        if (!allSlidesVisible && rightmostPoint <= viewportWidth) {\n            // Left aligned slides with their right edge visible:\n            // righmost slide edge should stick to the right viewport edge\n            newOffset = viewportWidth - slidesSumWidth;\n        } else if (allSlidesVisible) {\n            // Left aligned slides which are all visible:\n            // just stick them to the left viewport edge\n            newOffset = 0;\n        }\n    }\n    const result = new CalculateOffsetResult(Math.round(newOffset));\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { calculateOffset } from './calculate-offset';\n\n/**\n * Given current slide state, assigns carousel offset\n */\nexport function calculateOffsetProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        state = Object.assign({}, state);\n        const result = calculateOffset(\n            state.activeSlideIndex,\n            state.config.alignMode,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.slides.length,\n            state.config.shouldLoop,\n        );\n        state.offset = result.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselAnimation } from '../../../models/carousel-animation';\n\n/**\n * Destroys animation player without callback\n */\nexport function destroyAnimation(\n    animation?: CarouselAnimation,\n): void {\n    try {\n        animation?.player?.finish();\n        animation?.player?.destroy();\n    // Ignore exception since player might be already destroyed\n    // at this moment\n    } catch (e) {}\n    animation?.onDoneSubscription$?.unsubscribe();\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { destroyAnimation } from './destroy-animation';\n\n/**\n * Destroys and removes any ongoing animation state\n */\nexport function destroyAnimationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        destroyAnimation(state.animation);\n        state.animation = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlideParams } from './carousel-slide-params';\n\n/**\n * Slide model representation\n */\nexport class CarouselSlide {\n\n    constructor(\n        /**\n         * Id is used in trackBy and should be generated\n         * with `IdGenerator`\n         */\n        public id: number,\n        /**\n         * Represents index from `items` array of carousel\n         * config\n         */\n        public itemIndex: number,\n        /**\n         * Parameters that might be changed over time\n         */\n        public options: Partial<CarouselSlideParams> = {},\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class MarkVisibleAndActiveResult {\n\n    // Viewport range is subarray of slides which are\n    // currently in viewport\n    constructor(\n        public slides: CarouselSlide[],\n        public inViewportRangeStart: number,\n        public inViewportRangeEnd: number,\n    ) {\n    }\n\n}\n","import { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselSlide } from '../../../models/carousel-slide';\nimport { CarouselSlideParams } from '../../../models/carousel-slide-params';\nimport { MarkVisibleAndActiveResult } from './models/mark-visible-and-active-result';\n\n/**\n * Returns cloned slides with modified `inViewport` and `isActive` fields\n */\nexport function markVisibleAndActive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    activeSlideIndex: number,\n    threshold: number,\n    alignMode: CarouselAlignMode,\n): MarkVisibleAndActiveResult {\n    if (!slides || !slides.length) {\n\n        return new MarkVisibleAndActiveResult([], 0, 0);\n    }\n\n    const newSlides: CarouselSlide[] = [];\n    /** Slide index representing first slide inside viewport */\n    let inViewportStart: number = null;\n    /** Slide index representing last slide inside viewport */\n    let inViewportEnd: number = null;\n    for (let i = 0, currentOffset = offset; i < slides.length; i++, currentOffset += slideWidth) {\n        // Calculate slide options\n        const slideBeforeViewportEnd = currentOffset < viewportWidth + threshold;\n        const slideAfterViewportStart = currentOffset + slideWidth + threshold > 0;\n        const inViewport = slideBeforeViewportEnd && slideAfterViewportStart;\n        const options: Partial<CarouselSlideParams> = {\n            inViewport,\n            isActive: i === activeSlideIndex,\n        };\n\n        // Construct new slide\n        const newSlide = new CarouselSlide(\n            slides[i].id,\n            slides[i].itemIndex,\n            Object.assign({}, slides[i].options, options),\n        );\n        newSlides.push(newSlide);\n\n        // Detect viewport range\n        if (inViewport && inViewportStart === null) {\n            inViewportStart = i;\n        } else if (!inViewport && inViewportStart !== null && inViewportEnd === null) {\n            inViewportEnd = Math.max(0, i - 1);\n        }\n    }\n\n    // Edge case when last slide was in viewport:\n    // in such case viewport end index won't be assigned\n    // inside slide cycle due to loop algorithm specifics\n    if (inViewportStart !== null && inViewportEnd === null) {\n        inViewportEnd = slides.length - 1;\n    }\n\n    if (activeSlideIndex >= 0 && activeSlideIndex <= slides.length - 1) { // Active slide might be outside slide range\n        if (activeSlideIndex <= inViewportStart || inViewportStart === null) {\n            const distanceToActiveSlideViewportStart = alignMode === CarouselAlignMode.LEFT\n                ? threshold\n                : viewportWidth / 2 - slideWidth / 2 + threshold;\n            const slidesToViewportStart = Math.ceil(distanceToActiveSlideViewportStart / slideWidth);\n            inViewportStart = Math.max(0, activeSlideIndex - slidesToViewportStart);\n        }\n        if (activeSlideIndex >= inViewportEnd || inViewportEnd === null) {\n            const distanceToActiveSlideViewportEnd = alignMode === CarouselAlignMode.LEFT\n                ? viewportWidth + threshold\n                : viewportWidth / 2 + slideWidth / 2 + threshold;\n            const slidesToViewportEnd = Math.ceil(distanceToActiveSlideViewportEnd / slideWidth);\n            inViewportEnd = Math.min(slides.length - 1, activeSlideIndex + slidesToViewportEnd);\n        }\n    }\n\n    const result = new MarkVisibleAndActiveResult(newSlides, inViewportStart || 0, inViewportEnd || 0);\n\n    return result;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { markVisibleAndActive } from './mark-visible-and-active';\n\n/**\n * Assigns inViewport and isActive option to each slide\n */\nexport function markVisibleAndActiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade) => {\n        const result = markVisibleAndActive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.activeSlideIndex,\n            state.config.threshold,\n            state.config.alignMode,\n        );\n        state.slides = result.slides;\n        state.activeItemIndex = result.slides[state.activeSlideIndex]?.itemIndex ?? 0; // Undefined when no slides available\n        procedureState.inViewportRange = [result.inViewportRangeStart, result.inViewportRangeEnd];\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\nexport class RemoveExcessiveResult {\n    constructor(\n        public slides: CarouselSlide[],\n        public offset: number,\n    ) {\n    }\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { RemoveExcessiveResult } from './models/remove-excessive-result';\n\n/**\n * Removes slides that should not exist in carousel\n * (e.g. copies which are outside viewport)\n */\nexport function removeExcessive(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    /** First slide index that is inside viewport */\n    viewportStart: number,\n    /** Last slide index that is inside viewport */\n    viewportEnd: number,\n): RemoveExcessiveResult {\n    if (!slides || !slides.length) {\n\n        return new RemoveExcessiveResult([], offset);\n    }\n    // Validate inputs\n    viewportStart = Math.max(0, Math.min(viewportStart, viewportEnd));\n    viewportEnd = Math.min(viewportStart, slides.length - 1);\n\n    const rightSlides: CarouselSlide[] = [];\n    const leftSlides: CarouselSlide[] = [];\n    const itemIndexes = new Set<number>();\n    let newOffset = offset;\n    // Next fancy loop traverses through slides array, but in specified order:\n    // first we travel through slides in viewport, so we can collect item ids,\n    // next we go through right and left side outside viewport, cleaning all\n    // found copies. Thus we can cleanse all copies in O(n)\n    for (let i = viewportStart; i <= viewportEnd; i++) {\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = viewportEnd + 1; i < slides.length; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        rightSlides.push(slides[i]);\n    }\n    for (let i = 0; i < viewportStart; i++) {\n        if (itemIndexes.has(slides[i].itemIndex)) {\n            newOffset += slideWidth;\n            continue;\n        }\n        itemIndexes.add(slides[i].itemIndex);\n        leftSlides.push(slides[i]);\n    }\n\n    const newSlides = [\n        ...leftSlides,\n        ...rightSlides,\n    ];\n\n    return new RemoveExcessiveResult(newSlides, newOffset);\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { removeExcessive } from './remove-excessive';\n\n/**\n * Removes slide copies\n */\nexport function removeExcessiveProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        const result = removeExcessive(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            procedureState.inViewportRange[0],\n            procedureState.inViewportRange[1],\n        );\n        state.slides = result.slides;\n        state.offset = result.offset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `moveOrCopySlidesTo`\n */\nexport class CopySlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n        /** Item indexes that should be marked as copy */\n        public unmarkedItemIndexes = [],\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../../models/carousel-slide';\n\n/**\n * Result for helper function `shuffleSlides`\n */\nexport class ShuffleSlidesResult {\n\n    constructor(\n        public slides: CarouselSlide[] = [],\n        public modifiedOffset = 0,\n    ) {\n    }\n\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { CopySlidesResult } from './models/copy-slides-result';\nimport { ShuffleSlidesResult } from './models/shuffle-slides-result';\n\n/**\n * Justifies existing slides in viewport by either\n * - Move slide from one side to another\n * - Copy slide from one side to another\n * - Create slide on one side\n *\n * Task of this function is to leave no empty spaces in viewport.\n *\n * **BE ADVICED**, that inViewport flag should be calculated for each slide\n * that should not be moved beforehand.\n */\nexport function shuffleSlides(\n    slides: CarouselSlide[],\n    offset: number,\n    slideWidth: number,\n    viewportWidth: number,\n    items: any[],\n    shouldLoop: boolean,\n    threshold: number = 0,\n    idGenerator = new IdGenerator(),\n): ShuffleSlidesResult {\n    if (!slides || !slides.length) {\n\n        return new ShuffleSlidesResult([], offset);\n    }\n    if (slideWidth <= 0 || !shouldLoop) {\n\n        return new ShuffleSlidesResult(slides, offset);\n    }\n\n    const slideSumWidth = slides.length * slideWidth;\n\n    // Calculate missing slides for left and right sides\n    const leftSideMissingSlides = Math.max(0, Math.ceil((offset + threshold) / slideWidth));\n    const rightSideMissingSlides = Math.max(0, Math.ceil((viewportWidth + threshold - (offset + slideSumWidth)) / slideWidth));\n\n    // Let's start to fill missing slides\n\n    /**\n     * Item indexes that should be marked as copies after\n     * function completes\n     */\n    let unmarkedItemIndexes = [];\n\n    // Should move slides to right side\n    if (rightSideMissingSlides) {\n        const rightSideMoveResult = moveOrCopySlidesToEnd(\n            slides,\n            offset,\n            rightSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = rightSideMoveResult.slides;\n        offset = rightSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = rightSideMoveResult.unmarkedItemIndexes;\n    }\n\n    // Should move slides to left side\n    if (leftSideMissingSlides) {\n        const leftSideMoveResult = moveOrCopySlidesToStart(\n            slides,\n            offset,\n            leftSideMissingSlides,\n            slideWidth,\n            items,\n            idGenerator,\n        );\n        slides = leftSideMoveResult.slides;\n        offset = leftSideMoveResult.modifiedOffset;\n        unmarkedItemIndexes = unmarkedItemIndexes.concat(leftSideMoveResult.unmarkedItemIndexes);\n    }\n\n    const result = new ShuffleSlidesResult(slides, offset);\n\n    return result;\n}\n\n/**\n * Moves, copies or creates slides to the right side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [3, 4, 5, 0, 1, 2, 3, 4, 5] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the right part,\n * because we can't break sequence (meaning if we'll copy slide `5`\n * on the right to slide `3` on the left, they won't stack).\n * Slide `3` on the left awaits slide with item index `2` to be put\n * near him, so we should create some slides in between. This action\n * is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `5` and item index `3`?\n * Answer is 3: [**5**, 0, 1, 2, **3**]. So let's fill those 3 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 1. Now we can start copy/move slides from the right part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move one slide from the right part, since\n * `quantity` after `Option FILL` equals 1. Lets imagine that slide\n * wasn't in viewport and now our slide row has\n * [5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4], voila!\n */\nexport function moveOrCopySlidesToEnd(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * We can't increase quantity if we encountered slide\n     * with inViewport flag\n     */\n    let canIncreaseQuantity = true;\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from left side for analyzing.\n     */\n    let slideIndex = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    // We going to iterate through item indexes starting from\n    // last slide item index. Let's pick an item index\n    // to start from.\n    const lastSlide = slides[slides.length - 1];\n    const lastSlideHasLastItemIndex = lastSlide.itemIndex >= items.length - 1;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = lastSlideHasLastItemIndex\n        ? 0\n        : lastSlide.itemIndex + 1;\n\n    for (let i = 0; i < quantity; i++) {\n        /**\n         * Having this field as true means slides from left and right\n         * side (including new slides) can stack and we can proceed to\n         * COPY option\n         */\n        const firstSlideHasNextItemId = slides[0].itemIndex === nextItemId;\n\n        if (shouldCopy || firstSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Create new slide procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions\n            );\n            newSlides.push(newSlide);\n\n            // Splice arguments processing\n\n            if (currentSlide.options.inViewport) {\n                canIncreaseQuantity = false;\n            }\n\n            // We can't increase quantity if we have reached end of slides.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (canIncreaseQuantity && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n\n            // Prepare slide to process\n            slideIndex++;\n            if (slideIndex >= slides.length) {\n                slideIndex = 0;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Create new slide procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId++;\n        if (nextItemId >= items.length) {\n            nextItemId = 0;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        slides.splice(0, spliceQuantity);\n    }\n    const resultSlides = [\n        ...slides,\n        ...newSlides\n    ];\n    const resultOffset = offset + spliceQuantity * slideWidth;\n\n    return new CopySlidesResult(resultSlides, resultOffset, unmarkedItemIndexes);\n}\n\n/**\n * Moves, copies or creates slides to the left side in order to fill\n * desired `quantity`.\n *\n * Quantity means of how much new slides will be added.\n * There are two options of how we could fill missing slides.\n * Imagine next slides row mapped to their item index:\n * [0, 1, 2, 3, 4, 5, 0, 1, 2, 3] and lets take `quantity` = 4.\n * We can't just start to move/copy slides from the left part,\n * because we can't break sequence (meaning if we'll copy slide `0`\n * on the right to slide `3` on the right, they won't stack).\n * Slide `3` on the right side awaits slide with item index `2` to be\n * put near him, so we should create some slides in between. This\n * action is named `Option FILL GAP`.\n *\n * `Option FILL GAP`:\n * How much slides are in between item index `0` and item index `3`?\n * Answer is 2: [**3**, 4, 5, **0**]. So let's fill these 2 slides\n * and subtract their length from `quantity`.\n * Now we have row [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5] and `quantity`\n * equals 2. Now we can start copy/move slides from the left part.\n * This action is called `Option COPY`\n *\n * `Option COPY`:\n * When meddling with slides from the other side, we have two options\n * of what to do with them: either copy or move. Slide can be moved\n * when it is not `inViewport`, meaning it has corresponding option\n * flag. Otherwise it should be copied.\n * In our example we should move two slides from the left part, since\n * `quantity` after `Option FILL` equals 2. Lets imagine that slides\n * weren't in viewport and now our row has\n * [2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1], voila!\n */\nexport function moveOrCopySlidesToStart(\n    slides: CarouselSlide[],\n    offset: number,\n    quantity: number,\n    slideWidth: number,\n    items: any[],\n    idGenerator = new IdGenerator(),\n): CopySlidesResult {\n    if (quantity < 1) {\n\n        return new CopySlidesResult(slides, offset, []);\n    }\n\n    const newSlides = [];\n    /** Item indexes that should be marked as copies later */\n    const unmarkedItemIndexes = [];\n    /** Used as argument for splice call later */\n    let spliceFrom = null;\n    /** Used as argument for splice call later */\n    let spliceQuantity = 0;\n    /**\n     * Once we finished with option FILL GAP, then\n     * copy option should take place\n     */\n    let shouldCopy = false;\n\n    /**\n     * Iterator index, used in COPY option. Determines which\n     * slide should be picked from right side for analyzing.\n     */\n    let slideIndex = slides.length - 1;\n\n    // We going to iterate through item indexes starting from\n    // first slide item index. Let's pick an item index\n    // to start from.\n    const firstSlide = slides[0];\n    const firstSlideHasFirstItemId = firstSlide.itemIndex === 0;\n    /**\n     * Iterator index, used in FILL GAP and COPY options.\n     * This index determines which item will next slide have.\n     */\n    let nextItemId = firstSlideHasFirstItemId\n        ? items.length - 1\n        : firstSlide.itemIndex - 1;\n\n    for (let i = 0; i < quantity; i++) {\n        const lastSlideHasNextItemId = slides[slides.length - 1].itemIndex === nextItemId;\n\n        if (shouldCopy || lastSlideHasNextItemId) {\n            // Option COPY\n\n            shouldCopy = true;\n            const currentSlide = slides[slideIndex];\n\n            // Slide copy procedure\n            const newOptions = Object.assign({}, currentSlide.options);\n            // There should be an already existing isActive slide,\n            // so we turning isActive off for copy\n            newOptions.isActive = false;\n            // Every filled item is considered to be in viewport,\n            // because why else would we call this function\n            // otherwise? To fill viewport obviously.\n            newOptions.inViewport = true;\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                newOptions,\n            );\n            newSlides.push(newSlide);\n\n            // Prepare next slide index\n            slideIndex--;\n            if (slideIndex < 0) {\n                slideIndex = slides.length - 1;\n            }\n\n            // Splice arguments processing\n\n            // spliceFrom can be assigned once and equals first inViewport\n            // slide that we met\n            if (spliceFrom === null && currentSlide.options.inViewport) {\n                spliceFrom = slides.length - spliceQuantity;\n            }\n\n            // We can't increase quantity if we have determined\n            // from where we should splice slides\n            const slideCopyNotEncountered = spliceFrom === null;\n            // We can't have splice quantity higher than slides size.\n            // It happens when quantity from argument is higher than\n            // slides size.\n            const canIncrementSpliceQuantity = spliceQuantity + 1 <= slides.length;\n            if (slideCopyNotEncountered && canIncrementSpliceQuantity) {\n                spliceQuantity++;\n            }\n        } else {\n            // Option FILL GAP\n\n            // Slide copy procedure\n            const newSlide = new CarouselSlide(\n                idGenerator.next(),\n                nextItemId,\n                {\n                    // Every filled item is considered to be in viewport,\n                    // because why else would we call this function\n                    // otherwise? To fill viewport obviously.\n                    inViewport: true,\n                    item: items[nextItemId],\n                    // There should be an already existing isActive slide,\n                    // so we turning isActive off for copy\n                    isActive: false,\n                },\n            );\n            newSlides.push(newSlide);\n            unmarkedItemIndexes.push(nextItemId);\n        }\n\n        // Pick index for next item\n        nextItemId--;\n        if (nextItemId < 0) {\n            nextItemId = items.length - 1;\n        }\n    }\n\n    if (spliceQuantity > 0) {\n        spliceFrom = spliceFrom === null\n            ? slides.length - spliceQuantity\n            : spliceFrom;\n        slides.splice(spliceFrom, spliceQuantity);\n    }\n    const result = [\n        ...newSlides.reverse(),\n        ...slides,\n    ];\n\n    return new CopySlidesResult(result, offset - newSlides.length * slideWidth, unmarkedItemIndexes);\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { shuffleSlides } from './shuffle-slides';\n\n/**\n * Moves slide from left side to right or vise versa\n * in order to balance weight or predict offset changes\n */\nexport function shuffleSlidesProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = shuffleSlides(\n            state.slides,\n            state.offset,\n            state.config.slideWidth,\n            getViewportWidth(state),\n            state.config.items,\n            state.config.shouldLoop,\n            state.config.threshold,\n            environment?.slideIdGenerator ?? new IdGenerator(),\n        );\n        state.slides = result.slides;\n        state.activeSlideIndex = result.slides.findIndex((item: CarouselSlide) => item.options.isActive) || 0;\n        if (typeof procedureState.offsetSnapshot !== 'undefined') {\n            procedureState.offsetSnapshot = result.modifiedOffset - state.offset + procedureState.offsetSnapshot;\n        }\n        state.offset = result.modifiedOffset;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { removeExcessiveProcedure } from '../helpers/remove-excessive/remove-excessive-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Cleans state from excessive slides and completes\n * corresponding duties after completed transition\n */\nexport function cleanupProcedure(): Procedure {\n    return procedurePipe('cleanup',\n        destroyAnimationProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        calculateActiveSlideProcedure(),\n        removeExcessiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n    );\n}\n","import { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../../helpers/get-viewport-width-in-px/get-viewport-width-in-px';\n\n/** Converts passed distance to carousel width units */\nexport function normalizePassedDistanceProcedure(passedDistance: number): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.passedDistance = state.config.widthMode === CarouselWidthMode.PERCENT\n            ? 100 * passedDistance / getViewportWidthInPx(state)\n            : passedDistance;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { EasingFunction } from 'bezier-easing';\n\n/**\n * Calculates offset for animation specific tick\n */\nexport function animationOffsetSnapshot(\n    currentPosition: number,\n    totalDuration: number,\n    from: number,\n    to: number,\n    offsetFallback: number,\n    bezierFn: EasingFunction,\n): number {\n    if (typeof from === 'undefined' || typeof to === 'undefined') {\n\n        return offsetFallback;\n    }\n    if (totalDuration <= 0 || currentPosition < 0 || to === from) {\n\n        return to;\n    }\n    const animationDistance = Math.abs(to - from);\n    const completedDistancePercent = currentPosition / totalDuration;\n    const completedDistance = animationDistance * bezierFn(completedDistancePercent);\n    const offsetSnapshot = to > from\n        ? from + completedDistance\n        : from - completedDistance;\n\n    return offsetSnapshot;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { animationOffsetSnapshot } from './animation-offset-snapshot';\n\n/**\n * Assigns offset to state like if animation was paused.\n * If animation is not available, current offset will be assigned.\n */\nexport function animationOffsetSnapshotProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const time = new Date().getTime();\n        const currentPosition = time - (state.animation?.startTime ?? time);\n        const result = animationOffsetSnapshot(\n            currentPosition,\n            state.config.transitionDuration,\n            state.animation?.from,\n            state.animation?.to,\n            state.offset,\n            state.animationBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { AnimationPlayer } from '@angular/animations';\nimport { Subscription } from 'rxjs';\n\n/**\n * Animation state that is currently in process\n */\nexport class CarouselAnimation {\n\n    constructor(\n        public from: number,\n        public to: number,\n        public player?: AnimationPlayer,\n        public onDoneSubscription$?: Subscription,\n        public startTime = new Date().getTime(),\n    ) {\n    }\n\n}\n","import { animate, AnimationBuilder, style } from '@angular/animations';\nimport { bindCallback } from 'rxjs';\n\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\nimport { CarouselAnimation } from '../../../models/carousel-animation';\n\nexport function startAnimation(\n    container: HTMLElement,\n    from: number,\n    to: number,\n    widthMode: CarouselWidthMode,\n    transitionDuration: number,\n    bezierArgs: number[],\n    isBrowser: boolean,\n    afterAnimationAction: () => void,\n    animationBuilder: AnimationBuilder,\n): CarouselAnimation {\n    if (!isBrowser) {\n\n        return null;\n    }\n\n    const cubicBezier = `cubic-bezier(${bezierArgs[0]},${bezierArgs[1]},${bezierArgs[2]},${bezierArgs[3]})`;\n    const animationFactory = animationBuilder.build([\n        style({\n            transform: `translateX(${from}${widthMode})`,\n        }),\n        animate(`${transitionDuration}ms ${cubicBezier}`, style({\n            transform: `translateX(${to}${widthMode})`,\n        })),\n    ]);\n    const animationPlayer = animationFactory.create(container);\n    // Wrap onDone into observable\n    const boundFunction = bindCallback(animationPlayer.onDone); // Wrap function into function that returns observable\n    const onDone$ = boundFunction.call(animationPlayer); // Receive observable with context of animation player\n    const subscription$ = onDone$\n        .subscribe(() => {\n            animationPlayer.destroy();\n            afterAnimationAction();\n        });\n    const animation = new CarouselAnimation(\n        from,\n        to,\n        animationPlayer,\n        subscription$,\n    );\n    animationPlayer.play();\n\n    return animation;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { startAnimation } from './start-animation';\n\n/**\n * Creates new transition from one slide to another\n */\nexport function startAnimationProcedure(): Procedure {\n    return ({state, procedureState, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const animation = startAnimation(\n            state.animatableContainer,\n            procedureState.offsetSnapshot,\n            state.offset,\n            state.config.widthMode,\n            state.config.transitionDuration,\n            environment?.animationBezierArgs ?? [],\n            environment?.isBrowser ?? false,\n            environment?.afterAnimationAction ?? (() => {}),\n            environment?.animationBuilder,\n        );\n        state.animation = animation;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Save offset to procedure state until later use\n */\nexport function setOffsetSnapshotProcedure(): Procedure {\n    return ({state, procedureState}: ProcedureStateFacade): ProcedureHandler => {\n        procedureState.offsetSnapshot = state.offset;\n\n        return new ContinueWith(state, procedureState);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { startAnimationProcedure } from '../helpers/start-animation/start-animation-procedure';\nimport { setOffsetSnapshotProcedure } from './set-offset-snapshot/set-offset-snapshot-procedure';\n\n/**\n * Calculates corresponding parts for current active slide\n */\nexport function setSlideIndexProcedure(): Procedure {\n    return procedurePipe('setSlideIndex',\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        setOffsetSnapshotProcedure(),\n        markVisibleAndActiveProcedure(),\n        calculateOffsetProcedure(),\n        shuffleSlidesProcedure(),\n        startAnimationProcedure(),\n    );\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { normalizePassedDistanceProcedure } from './normalize-passed-distance/normalize-passed-distance-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Calculates state after user finish drag event\n */\nexport function dragEndProcedure(passedDistance: number): Procedure {\n    return procedurePipe('dragEnd',\n        enableAutoplayProcedure(AutoplaySuspender.DRAG),\n        normalizePassedDistanceProcedure(passedDistance),\n        calculateActiveSlideProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","\nimport { EasingFunction } from 'bezier-easing';\n\nimport { CarouselAlignMode } from '../../../../carousel-align-mode';\nimport { CarouselWidthMode } from '../../../../carousel-width-mode';\n\n/**\n * Return new offset modified by last drag operations.\n * Applies overscroll behavior when necessary.\n *\n * @returns modified offset\n */\nexport function dragOffsetSnapshot(\n    /** X position in pixels from where drag event began */\n    fromX: number,\n    /** destination X in pixels of last fired drag event */\n    toX: number,\n    currentOffset: number,\n    widthMode: CarouselWidthMode,\n    alignMode: CarouselAlignMode,\n    shouldLoop: boolean,\n    viewportWidth: number,\n    viewportWidthInPx: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    /** How much in percents user can overscroll unlooped carousel */\n    maxOverscrollPercent: number,\n    bezierFn: EasingFunction,\n    invertedBezierFn: EasingFunction,\n): number {\n    if (fromX === toX) {\n\n        return currentOffset;\n    }\n\n    // Normalize all pixel values to current width mode\n    if (widthMode === CarouselWidthMode.PERCENT) {\n        fromX = fromX * 100 / viewportWidthInPx;\n        toX = toX * 100 / viewportWidthInPx;\n    }\n\n    let offsetDelta = toX - fromX;\n\n    // 1st case: no bezier amendments, just return offset with applied delta\n    if (shouldLoop) {\n\n        return currentOffset + offsetDelta;\n    }\n\n    const overscrollStartPoint = detectOverscrollStartPoint(\n        fromX,\n        currentOffset,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        alignMode,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n\n    // 2nd case where bezier correction haven't started yet,\n    // meaning we're in safe zone at both side\n    if (overscrollStartPoint === null) {\n        const offsetFromSafeZone = applyDeltaFromSafeZone(\n            currentOffset,\n            offsetDelta,\n            alignMode,\n            viewportWidth,\n            slideWidth,\n            slideSumWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n\n        return offsetFromSafeZone;\n    }\n\n    // Seems like we already at overscroll zone, so let's see\n    // the ways we could manage that\n\n    /** Whether drag was performed from overscroll zone to same overscroll zone */\n    const dragStaysInSameOverscrollZone = fromX > overscrollStartPoint\n        ? toX > overscrollStartPoint\n        : toX < overscrollStartPoint;\n\n    // 3rd case: we should not amend when drag pointer is still in overscroll zone\n    // after applying delta\n    if (dragStaysInSameOverscrollZone) {\n        const distanceBefore = fromX - overscrollStartPoint;\n        const distanceAfter = toX - overscrollStartPoint;\n        const distance = distanceBetween(\n            distanceBefore,\n            distanceAfter,\n            viewportWidth,\n            maxOverscrollPercent,\n            bezierFn,\n        );\n        currentOffset = currentOffset - distance;\n\n        return currentOffset;\n    }\n\n    // 4th case where drag pointer has returned to safe zone.\n    // We should do the same calculation like we did in 2nd case.\n    const overscrollDistance = applyDeltaFromOverscrollZone(\n        overscrollStartPoint - fromX,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distancetoSafeZone = overscrollStartPoint - fromX;\n    currentOffset += overscrollDistance;\n    fromX = overscrollStartPoint;\n    offsetDelta -= distancetoSafeZone;\n\n    const result = applyDeltaFromSafeZone(\n        currentOffset,\n        offsetDelta,\n        alignMode,\n        viewportWidth,\n        slideWidth,\n        slideSumWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n\n    return result;\n}\n\n/**\n * Applies bezier on distance and limit with max overscroll distance\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromOverscrollZone(\n    distance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    /** Viewport % from 0 to 1 of delta distance */\n    const deltaPercentage = Math.max(0, Math.min(Math.abs(distance) / viewportWidth, 1));\n    /** Maximal distance of overscroll in pixels */\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    /**\n     * How much delta is actually long when applying bezier\n     * and aligning overscroll max distance\n     */\n    const deltaDistance = maxOverscrollDistance * bezierFn(deltaPercentage) * Math.sign(distance);\n\n    return deltaDistance;\n}\n\n/**\n * Applies delta to current offset which is currently in safe zone at this moment.\n * Applies bezier whether delta intersects overscroll zone.\n *\n * BE ADVICED, that all argument values should be converted to current width mode\n * beforehand.\n */\nfunction applyDeltaFromSafeZone(\n    currentOffset: number,\n    offsetDelta: number,\n    alignMode: CarouselAlignMode,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(viewportWidth, slideSumWidth);\n    /** Whether left side of carousel is in viewport after applying delta */\n    const leftSideExposedAfter = currentOffset + offsetDelta > leftmostPoint;\n    /** Whether right side of carousel is in viewport after applying delta */\n    const rightSideExposedAfter = currentOffset + slideSumWidth + offsetDelta < rightmostPoint;\n\n    const canSafelyTransit = (!leftSideExposedAfter && offsetDelta > 0)\n        || (!rightSideExposedAfter && offsetDelta < 0);\n\n    if (canSafelyTransit) {\n        // We're still safe on both sides, just apply delta\n\n        return currentOffset + offsetDelta;\n    }\n\n    /**\n     * Distance between current offset and point\n     * where overscroll begins\n     */\n    let distanceToSafeZone = 0;\n    // Move offset to the point where overscroll begins\n    if (leftSideExposedAfter) {\n        distanceToSafeZone = currentOffset - leftmostPoint;\n    } else if (rightSideExposedAfter) {\n        distanceToSafeZone = currentOffset + slideSumWidth - rightmostPoint;\n    }\n\n    /**\n     * Distance between current offset and\n     * overscroll zone starting point\n     */\n    const distanceWithoutSafeZone = offsetDelta + distanceToSafeZone;\n    currentOffset -= distanceToSafeZone;\n\n    const overscrollDelta = applyDeltaFromOverscrollZone(\n        distanceWithoutSafeZone,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    currentOffset += overscrollDelta;\n\n    return currentOffset;\n}\n\n/**\n * Returns point where overscroll should potentially start\n * or null if carousel is currently in safe zone.\n */\nfunction detectOverscrollStartPoint(\n    fromX: number,\n    currentOffset: number,\n    viewportWidth: number,\n    slideWidth: number,\n    slideSumWidth: number,\n    alignMode: CarouselAlignMode,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number | null {\n    const leftmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 - slideWidth / 2\n        : 0;\n    const rightmostPoint = alignMode === CarouselAlignMode.CENTER\n        ? viewportWidth / 2 + slideWidth / 2\n        : Math.min(leftmostPoint + slideSumWidth, viewportWidth);\n\n    /** Distance from current offset to safe zone */\n    let overscrollConvertedDistance: number | null = null;\n    // Special case when left-aligned carousel is lesser than viewport width\n    if (alignMode === CarouselAlignMode.LEFT && slideSumWidth < viewportWidth && currentOffset !== 0) {\n        overscrollConvertedDistance = currentOffset;\n    } else if (currentOffset > leftmostPoint) {\n        overscrollConvertedDistance = currentOffset - leftmostPoint;\n    } else if (currentOffset < rightmostPoint - slideSumWidth) {\n        overscrollConvertedDistance = currentOffset - rightmostPoint + slideSumWidth;\n    }\n    if (overscrollConvertedDistance === null) {\n\n        return null;\n    }\n    const overscrollRealDistance = extractDeltaFromOverscrollZone(\n        overscrollConvertedDistance,\n        viewportWidth,\n        maxOverscrollPercent,\n        invertedBezierFn,\n    );\n    const overscrollStartPoint = fromX - overscrollRealDistance;\n\n    return overscrollStartPoint;\n}\n\n/**\n * Converts distance with bezier applied to distance\n * without bezier\n */\nfunction extractDeltaFromOverscrollZone(\n    convertedDistance: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    invertedBezierFn: BezierEasing.EasingFunction,\n): number {\n    const maxOverscrollDistance = viewportWidth * maxOverscrollPercent / 100;\n    const bezierValue = Math.abs(convertedDistance / maxOverscrollDistance);\n    const deltaPercentage = invertedBezierFn(bezierValue) * viewportWidth * Math.sign(convertedDistance);\n\n    return deltaPercentage;\n}\n\n/**\n * Calculates overscroll distance between two points\n */\nfunction distanceBetween(\n    firstPoint: number,\n    secondPoint: number,\n    viewportWidth: number,\n    maxOverscrollPercent: number,\n    bezierFn: BezierEasing.EasingFunction,\n): number {\n    const overscrollBefore = applyDeltaFromOverscrollZone(\n        firstPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const overscrollAfter = applyDeltaFromOverscrollZone(\n        secondPoint,\n        viewportWidth,\n        maxOverscrollPercent,\n        bezierFn,\n    );\n    const distance = overscrollBefore - overscrollAfter;\n\n    return distance;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getViewportWidthInPx } from '../get-viewport-width-in-px/get-viewport-width-in-px';\nimport { getViewportWidth } from '../get-viewport-width/get-viewport-width';\nimport { dragOffsetSnapshot } from './drag-offset-snapshot';\n\n/**\n * Assigns offset to state by given distance coordinates\n */\nexport function dragOffsetSnapshotProcedure(fromX: number, toX: number): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = dragOffsetSnapshot(\n            fromX,\n            toX,\n            state.offset,\n            state.config.widthMode,\n            state.config.alignMode,\n            state.config.shouldLoop,\n            getViewportWidth(state),\n            getViewportWidthInPx(state),\n            state.config.slideWidth,\n            state.slides.length * state.config.slideWidth,\n            environment.maxOverscroll,\n            state.dragBezierFn,\n            state.invertedDragBezierFn,\n        );\n        state.offset = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselState } from '../../carousel-state';\nimport { ProcedureCarouselState } from '../procedure-carousel-state.interface';\nimport { ProcedureHandler } from './procedure-handler.interface';\n\nexport class BreakWith implements ProcedureHandler {\n    public readonly shouldBreakProcedure = true;\n\n    constructor(\n        public state: CarouselState,\n        public procedureState: ProcedureCarouselState = null,\n    ) {\n    }\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure whether drag is disabled\n */\nexport function postponeDragEnabledProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (state?.config?.dragEnabled) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { animationOffsetSnapshotProcedure } from '../helpers/animation-offset-snapshot/animation-offset-snapshot-procedure';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { dragOffsetSnapshotProcedure } from '../helpers/drag-offset/drag-offset-snapshot-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state after single tick of drag event\n */\nexport function dragProcedure(fromX: number, toX: number): Procedure {\n    return procedurePipe('drag',\n        postponeDragEnabledProcedure(),\n        animationOffsetSnapshotProcedure(),\n        destroyAnimationProcedure(),\n        dragOffsetSnapshotProcedure(fromX, toX),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        calculateActiveSlideProcedure(),\n        markVisibleAndActiveProcedure(),\n    );\n}\n","import { AutoplaySuspender } from '../../models/autoplay-suspender';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { disableAutoplayProcedure } from '../helpers/disable-autoplay/disable-autoplay-procedure';\nimport { postponeDragEnabledProcedure } from './postpone-drag-enabled/postpone-drag-enabled-procedure';\n\n/**\n * Processes state when drag event starts\n */\nexport function dragStartProcedure(): Procedure {\n    return procedurePipe('dragStart',\n        postponeDragEnabledProcedure(),\n        disableAutoplayProcedure(AutoplaySuspender.DRAG),\n    );\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IterateSideResult } from './models/iterate-side-result';\n\n/**\n * Finds slide that is marked as `isActive` and returns its index\n */\nexport function findSlideIndex(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): number {\n    if (!slides) {\n\n        return 0;\n    }\n    const currentActiveSlide = slides[currentSlideIndex];\n    if (!currentActiveSlide) {\n\n        return 0;\n    }\n    const currentItemIndex = currentActiveSlide.itemIndex;\n    let targetSlideIndex: IterateSideResult | null = null;\n    if (newItemIndex === currentItemIndex || slides.length <= 1) {\n\n        return currentSlideIndex;\n    } else if (newItemIndex > currentItemIndex) {\n        targetSlideIndex =\n            iterateRightSide(slides, newItemIndex, currentSlideIndex)\n            || iterateLeftSide(slides, newItemIndex, currentSlideIndex);\n    } else {\n        targetSlideIndex =\n            iterateLeftSide(slides, newItemIndex, currentSlideIndex)\n            || iterateRightSide(slides, newItemIndex, currentSlideIndex);\n    }\n\n    return targetSlideIndex?.foundIndex ?? null;\n}\n\nfunction iterateRightSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex + 1; i < slides.length; i++) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n\nfunction iterateLeftSide(\n    slides: CarouselSlide[],\n    newItemIndex: number,\n    currentSlideIndex: number,\n): IterateSideResult | null {\n    for (let i = currentSlideIndex - 1; i >= 0; i--) {\n        if (slides[i].itemIndex === newItemIndex) {\n\n            return {foundIndex: i};\n        }\n    }\n\n    return null;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { findSlideIndex } from './find-slide-index';\n\n/**\n * Assigns slide index by given item index\n */\nexport function findSlideIndexProcedure(itemIndex?: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = findSlideIndex(\n            state.slides,\n            itemIndex ?? state.activeItemIndex,\n            state.activeSlideIndex,\n        );\n        state.activeSlideIndex = result;\n        state.activeItemIndex = itemIndex;\n\n        return new ContinueWith(state);\n    };\n}\n","import { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Guard for assigning item index when no slides are available.\n * Would break procedure on such occasion.\n */\nexport function postponeItemIndexProcedure(newItemIndex: number): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.slides || !state.slides.length) {\n            state.postponedItemIndex = newItemIndex;\n\n            return new BreakWith(state);\n        }\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { findSlideIndexProcedure } from '../helpers/find-slide-index/find-slide-index-procedure';\nimport { postponeItemIndexProcedure } from './postpone-item-index/postpone-item-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/** Assigns item index and shuffles slides accordingly */\nexport function goToProcedure(newItemIndex: number): Procedure {\n    return procedurePipe('goTo',\n        postponeItemIndexProcedure(newItemIndex),\n        enableAutoplayProcedure(),\n        findSlideIndexProcedure(newItemIndex),\n        setSlideIndexProcedure(),\n    );\n}\n","import { CarouselSlide } from '../../../models/carousel-slide';\nimport { IdGenerator } from '../../../models/id-generator';\n\n/**\n * Fills empty carousel with slides without any\n * alignments\n */\nexport function initializeCarousel(\n    items: any[],\n    idGenerator: IdGenerator,\n): CarouselSlide[] {\n    if (!items || !items.length || !idGenerator) {\n\n        return [];\n    }\n\n    const newSlides = new Array(items.length);\n\n    for (let i = 0; i < items.length; i++) {\n        newSlides[i] = new CarouselSlide(idGenerator.next(), i, {item: items[i], isActive: i === 0});\n    }\n\n    return newSlides;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { initializeCarousel } from './initialize-carousel';\n\n/**\n * Creates new slide set from scratch\n */\nexport function initializeCarouselProcedure(): Procedure {\n    return ({state, environment}: ProcedureStateFacade): ProcedureHandler => {\n        const result = initializeCarousel(\n            state.config.items,\n            environment.slideIdGenerator,\n        );\n        state.slides = result;\n        state.offset = 0;\n        state.activeSlideIndex = 0;\n\n        return new ContinueWith(state);\n    };\n}\n","import { InitializationState } from '../../../models/initialization-state';\nimport { BreakWith } from '../../../models/procedure/handler/break-with.model';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Would break procedure when carousel is not ready\n * for first initialization\n */\nexport function postponeInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const phase = state?.initializationState ?? new InitializationState();\n        if (phase.configInitialized && phase.viewportWidthInitialized) {\n\n            return new ContinueWith(state);\n        }\n\n        return new BreakWith(state);\n    };\n}\n","import bezier from 'bezier-easing';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n// Reference: https://easings.net/ru\n// Standard ease\nexport const ANIMATION_BEZIER_ARGS = [0.25, 0.1, 0.25, 1];\n// Ease out quad\nconst DRAG_BEZIER_ARGS = [0.25, 0.46, 0.45, 0.94];\n\n/**\n * Creates bezier functions for different purposes\n */\nexport function setBeziersProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        if (!state.dragBezierFn) {\n            state.dragBezierFn = bezier(\n                DRAG_BEZIER_ARGS[0],\n                DRAG_BEZIER_ARGS[1],\n                DRAG_BEZIER_ARGS[2],\n                DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.invertedDragBezierFn) {\n            state.invertedDragBezierFn = bezier(\n                1 - DRAG_BEZIER_ARGS[0],\n                1 - DRAG_BEZIER_ARGS[1],\n                1 - DRAG_BEZIER_ARGS[2],\n                1 - DRAG_BEZIER_ARGS[3],\n            );\n        }\n        if (!state.animationBezierFn) {\n            state.animationBezierFn = bezier(\n                ANIMATION_BEZIER_ARGS[0],\n                ANIMATION_BEZIER_ARGS[1],\n                ANIMATION_BEZIER_ARGS[2],\n                ANIMATION_BEZIER_ARGS[3],\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Set state as initialized\n */\nexport function setFirstInitializationProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.initializationState.firstInitalization = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\nexport function removePostponedIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade) => {\n        state.postponedItemIndex = null;\n\n        return new ContinueWith(state);\n    };\n}\n","import { ComposedProcedure } from '../../../models/procedure/composed-procedure.type';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { procedurePipe } from '../../../models/procedure/procedure-pipe';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { goToProcedure } from '../go-to-procedure';\nimport { removePostponedIndexProcedure } from '../remove-postponed-index/remove-postponed-index-procedure';\n\n/**\n * Saves freshly selected item index till later\n * until carousel is initialized\n */\nexport function setPostponedIndexProcedure(): ComposedProcedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler | Procedure => {\n        if (state.slides.length && state.postponedItemIndex) {\n            const itemIndex = state.postponedItemIndex;\n\n            return procedurePipe('setPostponedIndex',\n                goToProcedure(itemIndex),\n                removePostponedIndexProcedure(),\n            );\n        }\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateActiveSlideProcedure } from '../helpers/calculate-active-slide/calculate-active-slide-procedure';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { destroyAnimationProcedure } from '../helpers/destroy-animation/destroy-animation-procedure';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { initializeCarouselProcedure } from '../helpers/initialize-carousel/initialize-carousel-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\nimport { postponeInitializationProcedure } from './postpone-initialization/postpone-initialization-procedure';\nimport { setBeziersProcedure } from './set-beziers/set-beziers-procedure';\nimport { setFirstInitializationProcedure } from './set-first-initalization/set-first-initialization-procedure';\nimport { setPostponedIndexProcedure } from './set-postponed-index/set-postponed-index-procedure';\n\n/**\n * Creates slides from scratch\n */\nexport function initializeProcedure(): Procedure {\n    return procedurePipe('initialize',\n        postponeInitializationProcedure(),\n\n        setFirstInitializationProcedure(),\n        initializeCarouselProcedure(),\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n        destroyAnimationProcedure(),\n        enableAutoplayProcedure(),\n        calculateActiveSlideProcedure(),\n        setBeziersProcedure(),\n\n        setPostponedIndexProcedure(),\n    );\n}\n","import { CarouselConfig } from '../../../../carousel-config';\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns carousel config, works as part of multiphase carousel initialization\n */\nexport function setConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.config = newConfig;\n        state.initializationState.configInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { CarouselConfig } from '../../../carousel-config';\nimport { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setConfigProcedure } from './set-config/set-config-procedure';\n\n/**\n * Assigns config and executes initialization effects\n */\nexport function initializeConfigProcedure(newConfig: CarouselConfig): Procedure {\n    return procedurePipe('initializeConfig',\n        setConfigProcedure(newConfig),\n        initializeProcedure(),\n    );\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Saves DOM element containers for carousel as part of initialization phase\n */\nexport function setContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.widthContainer = widthContainer;\n        state.animatableContainer = animatableContainer;\n        state.initializationState.viewportWidthInitialized = true;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { initializeProcedure } from './initialize-procedure';\nimport { setContainersProcedure } from './set-containers/set-containers-procedure';\n\n/**\n * Assigns specified DOM containers to carousel state\n */\nexport function initializeContainersProcedure(widthContainer: HTMLElement, animatableContainer: HTMLElement): Procedure {\n    return procedurePipe('initializeContainers',\n        setContainersProcedure(widthContainer, animatableContainer),\n        initializeProcedure(),\n    );\n}\n","/**\n * Returns next slide index as if user\n * clicked \"next\" button\n */\nexport function getNextIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex + 1;\n    if (newIndex >= slidesLength) {\n        newIndex = shouldLoop\n            ? 0\n            : slidesLength - 1;\n    }\n\n    return newIndex;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getNextIndex } from './get-next-index';\n\n/**\n * Increments current item index\n */\nexport function getNextIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getNextIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getNextIndexProcedure } from '../helpers/get-next-index/get-next-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Increments current slide\n */\nexport function nextProcedure(omitAutoplayReset = false): Procedure {\n    return procedurePipe('next',\n        omitAutoplayReset ? enableAutoplayProcedure() : null,\n        getNextIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","/**\n * Returns previous slide index as if user\n * clicked \"prev\" button\n */\nexport function getPrevIndex(\n    slidesLength: number,\n    activeSlideIndex: number,\n    shouldLoop: boolean,\n): number {\n    let newIndex = activeSlideIndex - 1;\n    if (newIndex < 0) {\n        newIndex = shouldLoop\n            ? slidesLength - 1\n            : 0;\n    }\n\n    return newIndex;\n}\n","import { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\nimport { getPrevIndex } from './get-prev-index';\n\n/**\n * Decrements current item index\n */\nexport function getPrevIndexProcedure(): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        const result = getPrevIndex(\n            state.slides.length,\n            state.activeSlideIndex,\n            state.config.shouldLoop,\n        );\n        state.activeSlideIndex = result;\n\n        return new ContinueWith(state);\n    };\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { enableAutoplayProcedure } from '../helpers/enable-autoplay/enable-autoplay-procedure';\nimport { getPrevIndexProcedure } from '../helpers/get-prev-index/get-prev-index-procedure';\nimport { setSlideIndexProcedure } from './set-slide-index-procedure';\n\n/**\n * Decrements current slide\n */\nexport function prevProcedure(): Procedure {\n    return procedurePipe('prev',\n        enableAutoplayProcedure(),\n        getPrevIndexProcedure(),\n        setSlideIndexProcedure(),\n    );\n}\n","import { procedurePipe } from '../../models/procedure/procedure-pipe';\nimport { Procedure } from '../../models/procedure/procedure.type';\nimport { calculateOffsetProcedure } from '../helpers/calculate-offset/calculate-offset-procedure';\nimport { markVisibleAndActiveProcedure } from '../helpers/mark-visible-and-active/mark-visible-and-active-procedure';\nimport { shuffleSlidesProcedure } from '../helpers/shuffle-slides/shuffle-slides-procedure';\n\n/**\n * Programmaticaly recalculates current state\n */\nexport function recalculateProcedure(): Procedure {\n    return procedurePipe('recalculate',\n        calculateOffsetProcedure(),\n        markVisibleAndActiveProcedure(),\n        shuffleSlidesProcedure(),\n    );\n}\n","import { TemplateRef } from '@angular/core';\n\nimport { ContinueWith } from '../../../models/procedure/handler/contiue-with.model';\nimport { ProcedureHandler } from '../../../models/procedure/handler/procedure-handler.interface';\nimport { ProcedureStateFacade } from '../../../models/procedure/procedure-state-facade.interface';\nimport { Procedure } from '../../../models/procedure/procedure.type';\n\n/**\n * Assigns TemplateRef where slides would be rendered\n */\nexport function setTemplateProcedure(template: TemplateRef<any> | null): Procedure {\n    return ({state}: ProcedureStateFacade): ProcedureHandler => {\n        state.template = template;\n\n        return new ContinueWith(state);\n    };\n}\n","import { AnimationBuilder } from '@angular/animations';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, OnDestroy, PLATFORM_ID, TemplateRef } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nimport { CarouselConfig } from '../../carousel-config';\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselState } from '../models/carousel-state';\nimport { IdGenerator } from '../models/id-generator';\nimport { ProcedureEnvironment } from '../models/procedure/procedure-environment.interface';\nimport { procedurePipe } from '../models/procedure/procedure-pipe';\nimport { Procedure } from '../models/procedure/procedure.type';\nimport { SLIDE_ID_GENERATOR } from '../tokens';\nimport { disableAutoplayProcedure } from './helpers/disable-autoplay/disable-autoplay-procedure';\nimport { enableAutoplayProcedure } from './helpers/enable-autoplay/enable-autoplay-procedure';\nimport { cleanupProcedure } from './procedures/cleanup-procedure';\nimport { dragEndProcedure } from './procedures/drag-end-procedure';\nimport { dragProcedure } from './procedures/drag-procedure';\nimport { dragStartProcedure } from './procedures/drag-start-procedure';\nimport { goToProcedure } from './procedures/go-to-procedure';\nimport { initializeConfigProcedure } from './procedures/initialize-config-procedure';\nimport { initializeContainersProcedure } from './procedures/initialize-containers-procedure';\nimport { nextProcedure } from './procedures/next-procedure';\nimport { prevProcedure } from './procedures/prev-procedure';\nimport { recalculateProcedure } from './procedures/recalculate-procedure';\nimport { ANIMATION_BEZIER_ARGS } from './procedures/set-beziers/set-beziers-procedure';\nimport { setTemplateProcedure } from './procedures/set-template/set-template-procedure';\n\n/**\n * Short swipe might not change slide to next/prev.\n * This const specifies how much (% of viewport) swipe\n * should overcome to trigger next/prev slide change.\n */\nconst MAX_SWIPE_THRESHOLD = 15;\n/**\n * How much % user can stretch carousel, when there's no more\n * drag available\n */\nconst MAX_OVERSCROLL = 10;\n\n@Injectable()\nexport class CarouselService implements OnDestroy {\n\n    private readonly carouselState$ = new BehaviorSubject<CarouselState>(new CarouselState());\n    /** Describes constant entities for procedures */\n    private readonly procedureEnvironment: ProcedureEnvironment = {\n        slideIdGenerator: this.slideIdGenerator,\n        isBrowser: isPlatformBrowser(this.platformId),\n        autoplayAction: this.next.bind(this),\n        afterAnimationAction: this.cleanup.bind(this),\n        animationBuilder: this.animationBuilder,\n        animationBezierArgs: ANIMATION_BEZIER_ARGS,\n        swipeThreshold: MAX_SWIPE_THRESHOLD,\n        maxOverscroll: MAX_OVERSCROLL,\n    };\n\n    constructor(\n        private animationBuilder: AnimationBuilder,\n        @Inject(SLIDE_ID_GENERATOR) private slideIdGenerator: IdGenerator,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnDestroy(): void {\n        this.carouselState$.getValue()?.autoplay?.autoplaySubscription?.unsubscribe();\n    }\n\n    carouselStateChanges(): Observable<CarouselState> {\n        return this.carouselState$.asObservable();\n    }\n\n    setItemIndex(newItemIndex: number): void {\n        this.apply(goToProcedure(newItemIndex));\n    }\n\n    prev(): void {\n        this.apply(prevProcedure());\n    }\n\n    /**\n     * @param omitAutoplayReset whether autoplay timer should not be resetted\n     */\n    next(omitAutoplayReset = false): void {\n        this.apply(nextProcedure(omitAutoplayReset));\n    }\n\n    recalculate(): void {\n        this.apply(recalculateProcedure());\n    }\n\n    /** Update state to announce that drag sequence just started */\n    dragStart(): void {\n        this.apply(dragStartProcedure());\n    }\n\n    /**\n     * Update state to announce that drag sequence just ended\n     * and perform necessary cleanups\n     */\n    dragEnd(passedDistance: number): void {\n        this.apply(dragEndProcedure(passedDistance));\n    }\n\n    /** Process single drag tick with given from and to coordinates */\n    drag(fromX: number, toX: number): void {\n        this.apply(dragProcedure(fromX, toX));\n    }\n\n    setSlideTemplate(newTemplateRef: TemplateRef<any> | null): void {\n        this.apply(setTemplateProcedure(newTemplateRef));\n    }\n\n    disableAutoplay(suspender: AutoplaySuspender): void {\n        this.apply(disableAutoplayProcedure(suspender));\n    }\n\n    /**\n     * Starts new autoplay timer\n     */\n    enableAutoplay(suspender: AutoplaySuspender = null): void {\n        this.apply(enableAutoplayProcedure(suspender));\n    }\n\n    setContainers(widthContainer: HTMLElement, animatableContainer: HTMLElement): void {\n        this.apply(initializeContainersProcedure(widthContainer, animatableContainer));\n    }\n\n    setConfig(newConfig: CarouselConfig): void {\n        this.apply(initializeConfigProcedure(newConfig));\n    }\n\n    private cleanup(): void {\n        this.apply(cleanupProcedure());\n    }\n\n    /**\n     * Applies specified procedure to carousel state\n     */\n    private apply(procedure: Procedure): void {\n        const state: CarouselState = Object.assign({}, this.carouselState$.getValue());\n        const result = procedurePipe('applier', procedure)({state, procedureState: {}, environment: this.procedureEnvironment});\n        this.carouselState$.next(result.state);\n    }\n}\n","import { ChangeDetectionStrategy, Component, ContentChild, Input, Output, ViewEncapsulation } from '@angular/core';\nimport { map } from 'rxjs/operators';\n\nimport { CarouselConfig } from './carousel-config';\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselState } from './private/models/carousel-state';\nimport { IdGenerator } from './private/models/id-generator';\nimport { CarouselService } from './private/service/carousel.service';\nimport { ANIMATION_ID_GENERATOR, SLIDE_ID_GENERATOR } from './private/tokens';\n\nexport function idGeneratorFactory(): IdGenerator {\n    return new IdGenerator();\n}\n\n@Component({\n    selector: 'ng-carousel',\n    templateUrl: 'carousel.component.html',\n    styleUrls: ['carousel.component.scss'],\n    providers: [\n        CarouselService,\n        {\n            provide: SLIDE_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n        {\n            provide: ANIMATION_ID_GENERATOR,\n            useFactory: idGeneratorFactory,\n        },\n    ],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    exportAs: 'ngCarousel',\n})\n/**\n * Defines carousel API to work with\n */\nexport class CarouselComponent {\n\n    @ContentChild(CarouselSlideDirective) set slideRef(newSlideRef: CarouselSlideDirective) {\n        this.carousel.setSlideTemplate(newSlideRef\n            ? newSlideRef.templateRef\n            : null\n        );\n    }\n\n    @Input() set config(newConfig: CarouselConfig) {\n        newConfig = new CarouselConfig(newConfig);\n        this.carousel.setConfig(newConfig);\n    }\n\n    @Output() itemIndexChange = this.carousel.carouselStateChanges()\n        .pipe(\n            map((state: CarouselState) => state.activeItemIndex),\n        );\n\n    constructor(\n        private carousel: CarouselService,\n    ) {\n    }\n\n    next(): void {\n        this.carousel.next();\n    }\n\n    prev(): void {\n        this.carousel.prev();\n    }\n\n    setIndex(newIndex: number): void {\n        this.carousel.setItemIndex(newIndex);\n    }\n\n    /**\n     * Programmaticaly recalculates carousel position in case of\n     * container size changes or other size interactions\n     */\n    recalculate(): void {\n        this.carousel.recalculate();\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, isDevMode, PLATFORM_ID } from '@angular/core';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class HammerProviderService {\n\n    private hammerAbsenceDeclared = false;\n\n    constructor(\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    public managerFor(element: HTMLElement): HammerManager | null {\n        const hasGestures = isPlatformBrowser(this.platformId) && (window as any).Hammer;\n        if (!hasGestures) {\n            if (isDevMode() && !this.hammerAbsenceDeclared) {\n                console.warn(\n                    'Ng-carousel could not listen to drag, because HammerJS was not found. Either disable drag or import HammerJS.'\n                );\n                this.hammerAbsenceDeclared = true;\n            }\n\n            return null;\n        }\n        const hammerManager = new Hammer(element);\n\n        return hammerManager;\n    }\n}\n","import { Directive, ElementRef, HostListener, OnDestroy, OnInit } from '@angular/core';\nimport { asyncScheduler } from 'rxjs';\n\nimport { HammerProviderService } from './private/service/hammer-provider.service';\n\n@Directive({\n    selector: '[ngCarouselPreventGhostClick]',\n})\nexport class PreventGhostClickDirective implements OnInit, OnDestroy {\n\n    private hammerManager: HammerManager;\n    private shouldPreventClick = false;\n\n    @HostListener('click', ['$event'])\n    private processClickEvent(event: Event): void {\n        if (this.shouldPreventClick) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n        }\n    }\n\n    constructor(\n        private elementRef: ElementRef,\n        private hammer: HammerProviderService,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenPanEndEvents();\n    }\n\n    ngOnDestroy() {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private listenPanEndEvents(): void {\n        this.hammerManager = this.hammer.managerFor(this.elementRef.nativeElement);\n        if (!this.hammerManager) {\n\n            return;\n        }\n        this.hammerManager.on('panend pancancel', () => {\n            this.shouldPreventClick = true;\n            asyncScheduler.schedule(() => {\n                this.shouldPreventClick = false;\n            });\n        });\n    }\n\n}\n","import { CdkTrapFocus, InteractivityChecker } from '@angular/cdk/a11y';\nimport { AfterViewInit, Directive, ElementRef, Input, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';\n\n@Directive({\n    selector: '[untabbable]',\n})\n/**\n * Applies tabindex=-1 for interactive elements inside container\n */\nexport class FocusBlockDirective implements OnChanges, AfterViewInit, OnDestroy {\n\n    @Input() untabbable = false;\n    @Input() untabbableFocusTrapRef: CdkTrapFocus;\n    /** Whether focus inside carousel */\n    @Input() untabbableFocused = false;\n\n    private readonly lastTabindexValueMap = new Map<HTMLElement, string | null>();\n    private viewInitiated: boolean;\n    private mutationObserver: MutationObserver;\n\n    constructor(\n        private elementRef: ElementRef,\n        private interactivityChecker: InteractivityChecker,\n    ) {\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (changes.untabbable && this.viewInitiated) {\n            const change = changes.untabbable;\n            if (change.currentValue === change.previousValue) {\n\n                return;\n            }\n            change.currentValue\n                ? this.blockTabindex()\n                : this.unblockTabindex();\n            if (this.untabbableFocused && this.untabbableFocusTrapRef) {\n                this.untabbableFocusTrapRef.focusTrap.focusFirstTabbableElement();\n            }\n        }\n    }\n\n    ngAfterViewInit() {\n        this.viewInitiated = true;\n        this.untabbable\n            ? this.blockTabindex()\n            : this.unblockTabindex();\n    }\n\n    ngOnDestroy() {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n    }\n\n    private blockTabindex(): void {\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.blockElement(element);\n        }\n        if (typeof window !== 'undefined' && 'MutationObserver' in window) {\n            this.mutationObserver = new MutationObserver(\n                (mutationList: MutationRecord[]) => {\n                    const changesArray = Array.from(mutationList);\n                    for (const change of changesArray) {\n                        if (change.type === 'attributes') {\n                            this.blockElement(change.target as HTMLElement);\n                        } else if (change.type === 'childList') {\n                            change.addedNodes.forEach((element: Node) => {\n                                this.blockElement(element as HTMLElement);\n                            });\n                        }\n                    }\n                }\n            );\n            this.mutationObserver.observe(this.elementRef.nativeElement, {\n                attributeFilter: ['tabindex'],\n                attributes: true,\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n\n    private unblockTabindex(): void {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n            this.mutationObserver = null;\n        }\n        const elements: HTMLElement[] = Array.from(this.elementRef.nativeElement.querySelectorAll('*'));\n        for (const element of elements) {\n            this.unblockElement(element);\n        }\n    }\n\n    private blockElement(element: HTMLElement): void {\n        // nodeType is text node, should not be blocked\n        if (element.nodeType !== 3 && this.interactivityChecker.isFocusable(element) && this.interactivityChecker.isTabbable(element)) {\n            const currentTabindexValue = element.getAttribute('tabindex');\n            this.lastTabindexValueMap.set(element, currentTabindexValue);\n            if (currentTabindexValue !== '-1') {\n                element.setAttribute('tabindex', '-1');\n            }\n        }\n    }\n\n    private unblockElement(element: HTMLElement): void {\n        if (this.lastTabindexValueMap.has(element) && typeof this.lastTabindexValueMap.get(element) === 'number') {\n            element.setAttribute('tabindex', this.lastTabindexValueMap.get(element));\n        } else {\n            element.removeAttribute('tabindex');\n        }\n    }\n}\n","/**\n * Template context for carousel slide\n */\nexport class CarouselSlideContext {\n\n    constructor(\n        public $implicit: any,\n        public itemIndex: number,\n        public isActive: boolean,\n        public inViewport: boolean,\n    ) {\n    }\n\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, ElementRef, Inject, OnDestroy, OnInit, PLATFORM_ID, Renderer2, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { fromEvent, Observable, Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMapTo, takeUntil } from 'rxjs/operators';\n\nimport { AutoplaySuspender } from '../models/autoplay-suspender';\nimport { CarouselSlide } from '../models/carousel-slide';\nimport { CarouselSlideContext } from '../models/carousel-slide-context';\nimport { CarouselState } from '../models/carousel-state';\nimport { CarouselService } from '../service/carousel.service';\nimport { HammerProviderService } from '../service/hammer-provider.service';\n\n@Component({\n  selector: 'carousel-engine',\n  templateUrl: './carousel-engine.component.html',\n  styleUrls: ['./carousel-engine.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\n/**\n * Contains listeners and other DOM controllers\n */\nexport class CarouselEngineComponent implements OnInit, OnDestroy {\n\n    @ViewChild('galleryRef', {static: true}) galleryRef: ElementRef;\n    public readonly transformValue$ = this.transformValueChanges();\n    public readonly slideWidth$ = this.slideWidthChanges();\n    public readonly template$ = this.templateChanges();\n    public readonly slides$ = this.slidesChanges();\n    public focused = false;\n    private readonly destroyed$ = new Subject<void>();\n    private mouseEnterDestructor: () => void;\n    private mouseLeaveDestructor: () => void;\n    private keyboardListener: () => void;\n    private containerScrollListener: () => void;\n    private hammerManager: HammerManager;\n\n    private get htmlElement(): HTMLElement {\n        return this.elementRef.nativeElement;\n    }\n\n    constructor(\n        private carousel: CarouselService,\n        private elementRef: ElementRef,\n        private renderer: Renderer2,\n        private hammer: HammerProviderService,\n        // tslint:disable-next-line: ban-types\n        @Inject(PLATFORM_ID) private platformId: Object,\n    ) {\n    }\n\n    ngOnInit() {\n        this.listenToAutoplay();\n        this.listenToDragEvents();\n        this.listenToResizeEvents();\n        this.listenToKeyEvents();\n        this.listenToScrollEvents();\n        this.carousel.setContainers(this.htmlElement, this.galleryRef.nativeElement);\n    }\n\n    ngOnDestroy() {\n        this.destroyMouseListeners();\n        this.destroyHammer();\n        this.destroyKeyboardListeners();\n        this.destroyElementScrollListener();\n        this.destroyed$.next();\n        this.destroyed$.complete();\n    }\n\n    trackByFn(index: number, item: CarouselSlide): number {\n        return item.id;\n    }\n\n    contextOf(slide: CarouselSlide): CarouselSlideContext {\n        return new CarouselSlideContext(\n            slide.options.item,\n            slide.itemIndex,\n            slide.options.isActive,\n            slide.options.inViewport,\n        );\n    }\n\n    focusIn(): void {\n        this.focused = true;\n        this.carousel.disableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    focusOut(): void {\n        this.focused = false;\n        this.carousel.enableAutoplay(AutoplaySuspender.FOCUS);\n    }\n\n    private destroyMouseListeners(): void {\n        if (this.mouseEnterDestructor) {\n            this.mouseEnterDestructor();\n        }\n        if (this.mouseLeaveDestructor) {\n            this.mouseLeaveDestructor();\n        }\n    }\n\n    private destroyHammer(): void {\n        if (this.hammerManager) {\n            this.hammerManager.destroy();\n        }\n    }\n\n    private destroyKeyboardListeners(): void {\n        if (this.keyboardListener) {\n            this.keyboardListener();\n        }\n    }\n\n    private destroyElementScrollListener(): void {\n        if (this.containerScrollListener) {\n            this.containerScrollListener();\n        }\n    }\n\n    private transformValueChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `translateX(${state.offset}${state.config.widthMode})`),\n            );\n    }\n\n    private slideWidthChanges(): Observable<string> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => `${state.config.slideWidth}${state.config.widthMode}`),\n            );\n    }\n\n    private slidesChanges(): Observable<CarouselSlide[]> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.slides),\n            );\n    }\n\n    private templateChanges(): Observable<TemplateRef<any>> {\n        return this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.template),\n            );\n    }\n\n    private listenToAutoplay(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.autoplayEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((autoplayEnabled: boolean) => {\n                if (this.mouseEnterDestructor) {\n                    this.mouseEnterDestructor();\n                }\n                if (this.mouseLeaveDestructor) {\n                    this.mouseLeaveDestructor();\n                }\n                if (!autoplayEnabled) {\n\n                    return;\n                }\n                this.mouseEnterDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseenter',\n                    () => this.carousel.disableAutoplay(AutoplaySuspender.MOUSE),\n                );\n                this.mouseLeaveDestructor = this.renderer.listen(\n                    this.htmlElement,\n                    'mouseleave',\n                    () => this.carousel.enableAutoplay(AutoplaySuspender.MOUSE),\n                );\n            });\n    }\n\n    private listenToDragEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                map((state: CarouselState) => state.config.dragEnabled),\n                distinctUntilChanged(),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe((dragEnabled: boolean) => {\n                if (this.hammerManager) {\n                    this.hammerManager.destroy();\n                }\n                if (!dragEnabled) {\n\n                    return;\n                }\n                this.hammerManager = this.hammer.managerFor(this.htmlElement);\n                if (!this.hammerManager) {\n\n                    return;\n                }\n                let lastDelta = 0;\n                let lastTouchAction: string;\n\n                this.hammerManager.on('panstart', (event: HammerInput) => {\n                    // Checking whether pan started with horizontal gesture,\n                    // we should block all scroll attempts during current pan session then\n                    // tslint:disable-next-line: no-bitwise\n                    if (event.offsetDirection & Hammer.DIRECTION_HORIZONTAL) {\n                        lastDelta = Math.round(event.deltaX);\n                        this.carousel.dragStart();\n                        lastTouchAction = this.htmlElement.style.touchAction;\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', 'none');\n                    }\n                });\n\n                this.hammerManager.on('panright panleft', (event: HammerInput) => {\n                    // We should not treat vertical pans as horizontal.\n                    // Be adviced that pan right/left events still counts\n                    // vertical pans as legitimate horizontal pan.\n\n                    // Next check clarifies that initial gesture was horizontal,\n                    // otherwise this variable would be falsy\n                    if (lastTouchAction) {\n                        const x = Math.round(event.center.x);\n                        const deltaX = Math.round(event.deltaX);\n                        this.carousel.drag(x, x + (deltaX - lastDelta));\n                        lastDelta = deltaX;\n                    }\n                });\n\n                this.hammerManager.on('panend pancancel', (event: HammerInput) => {\n                    if (lastTouchAction) {\n                        this.carousel.dragEnd(event.deltaX);\n                        this.renderer.setStyle(this.htmlElement, 'touch-action', lastTouchAction);\n                        lastTouchAction = null;\n                    }\n                });\n            });\n    }\n\n    private listenToResizeEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.carousel.carouselStateChanges()\n            .pipe(\n                filter((state: CarouselState) => state.config.shouldRecalculateOnResize),\n                switchMapTo(fromEvent(window, 'resize')),\n                takeUntil(this.destroyed$),\n            )\n            .subscribe(() => {\n                this.carousel.recalculate();\n            });\n    }\n\n    private listenToKeyEvents(): void {\n        if (!isPlatformBrowser(this.platformId)) {\n\n            return;\n        }\n        this.keyboardListener = this.renderer.listen(\n            this.htmlElement,\n            'keydown',\n            (event: KeyboardEvent) => {\n                const key = event.key.toLowerCase();\n                if (['arrowright', 'right'].includes(key)) {\n                    this.carousel.next();\n                } else if (['arrowleft', 'left'].includes(key)) {\n                    this.carousel.prev();\n                }\n            }\n        );\n    }\n\n    /**\n     * Horizontal scroll might accidentaly happen on parent container\n     * when pressing arrow buttons too fast. We should return\n     * container to initial position when that happens.\n     */\n    private listenToScrollEvents(): void {\n        this.containerScrollListener = this.renderer.listen(this.htmlElement, 'scroll', () => {\n            this.htmlElement.scrollTo(0, 0);\n        });\n    }\n}\n","import { A11yModule } from '@angular/cdk/a11y';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\n\nimport { CarouselSlideDirective } from './carousel-slide.directive';\nimport { CarouselComponent } from './carousel.component';\nimport { PreventGhostClickDirective } from './prevent-ghost-click.directive';\nimport { FocusBlockDirective } from './private/directives/untabbable.directive';\nimport { CarouselEngineComponent } from './private/views/carousel-engine.component';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        A11yModule,\n    ],\n    declarations: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        CarouselEngineComponent,\n        FocusBlockDirective,\n        PreventGhostClickDirective,\n    ],\n    exports: [\n        CarouselComponent,\n        CarouselSlideDirective,\n        PreventGhostClickDirective,\n    ],\n})\nexport class CarouselModule { }\n","/*\n * Public API Surface of ng-carousel\n */\n\nexport * from './lib/carousel.component';\nexport * from './lib/carousel.module';\nexport * from './lib/carousel-config';\nexport * from './lib/carousel-width-mode';\nexport * from './lib/carousel-align-mode';\nexport * from './lib/carousel-slide.directive';\nexport * from './lib/prevent-ghost-click.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {FocusBlockDirective as ɵg} from './lib/private/directives/untabbable.directive';\nexport {IdGenerator as ɵa} from './lib/private/models/id-generator';\nexport {CarouselService as ɵb} from './lib/private/service/carousel.service';\nexport {HammerProviderService as ɵf} from './lib/private/service/hammer-provider.service';\nexport {ANIMATION_ID_GENERATOR as ɵd,SLIDE_ID_GENERATOR as ɵc} from './lib/private/tokens';\nexport {CarouselEngineComponent as ɵe} from './lib/private/views/carousel-engine.component';"]}